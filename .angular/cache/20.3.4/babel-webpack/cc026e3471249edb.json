{"ast":null,"code":"import { HttpClient } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { BehaviorSubject, interval } from 'rxjs';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"@angular/router\";\nexport class SessionMonitorService {\n  http;\n  router;\n  API_URL = environment.apiUrl;\n  sessionCheckInterval;\n  sessionStatusSubject = new BehaviorSubject(true);\n  sessionStatus$ = this.sessionStatusSubject.asObservable();\n  constructor(http, router) {\n    this.http = http;\n    this.router = router;\n  }\n  /**\n   * Inicia o monitoramento da sess√£o\n   */\n  startMonitoring(token) {\n    if (this.sessionCheckInterval) {\n      this.stopMonitoring();\n    }\n    // Verificar status da sess√£o a cada 10 segundos (mais responsivo)\n    this.sessionCheckInterval = interval(10000).subscribe(() => {\n      this.checkSessionStatus(token);\n    });\n    console.log('üîç Monitoramento de sess√£o iniciado');\n  }\n  /**\n   * Para o monitoramento da sess√£o\n   */\n  stopMonitoring() {\n    if (this.sessionCheckInterval) {\n      this.sessionCheckInterval.unsubscribe();\n      this.sessionCheckInterval = null;\n      console.log('üîç Monitoramento de sess√£o parado');\n    }\n  }\n  /**\n   * Verifica o status da sess√£o no backend\n   */\n  checkSessionStatus(token) {\n    if (!token) {\n      return;\n    }\n    this.http.get(`${this.API_URL}/auth/session-status`, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    }).subscribe({\n      next: response => {\n        if (!response.authenticated || response.status !== 'ACTIVE') {\n          console.warn('‚ö†Ô∏è Sess√£o inv√°lida detectada:', response.reason || 'Sess√£o inativa');\n          this.handleSessionInvalid();\n        } else {\n          this.sessionStatusSubject.next(true);\n        }\n      },\n      error: error => {\n        console.error('‚ùå Erro ao verificar status da sess√£o:', error);\n        // Se for erro 401, 500 com JWT expirado, ou qualquer erro de autentica√ß√£o\n        if (error.status === 401 || error.status === 500 && error.error?.reason === 'Erro interno' || error.status === 500 && error.error?.status === 'ERROR') {\n          console.warn('üö® Sess√£o inv√°lida detectada - Limpando dados locais');\n          this.handleSessionInvalid();\n        }\n      }\n    });\n  }\n  /**\n   * Trata sess√£o inv√°lida\n   */\n  handleSessionInvalid() {\n    this.sessionStatusSubject.next(false);\n    // Parar monitoramento\n    this.stopMonitoring();\n    // Limpar dados locais\n    localStorage.removeItem('token');\n    localStorage.removeItem('nome');\n    localStorage.removeItem('plano');\n    console.warn('üö® Sess√£o invalidada - Redirecionando para login');\n    // Redirecionar para login\n    this.router.navigate(['/login']);\n  }\n  /**\n   * Verifica se a sess√£o est√° ativa\n   */\n  isSessionActive() {\n    return this.sessionStatusSubject.value;\n  }\n  /**\n   * For√ßa verifica√ß√£o imediata do status da sess√£o\n   */\n  forceCheckSession(token) {\n    this.checkSessionStatus(token);\n  }\n  /**\n   * Obt√©m estat√≠sticas da sess√£o (para debug)\n   */\n  getSessionStats(token) {\n    return this.http.get(`${this.API_URL}/auth/session-stats`, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n  }\n  static …µfac = function SessionMonitorService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || SessionMonitorService)(i0.…µ…µinject(i1.HttpClient), i0.…µ…µinject(i2.Router));\n  };\n  static …µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: SessionMonitorService,\n    factory: SessionMonitorService.…µfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["HttpClient","Router","BehaviorSubject","interval","environment","SessionMonitorService","http","router","API_URL","apiUrl","sessionCheckInterval","sessionStatusSubject","sessionStatus$","asObservable","constructor","startMonitoring","token","stopMonitoring","subscribe","checkSessionStatus","console","log","unsubscribe","get","headers","Authorization","next","response","authenticated","status","warn","reason","handleSessionInvalid","error","localStorage","removeItem","navigate","isSessionActive","value","forceCheckSession","getSessionStats","i0","…µ…µinject","i1","i2","factory","…µfac","providedIn"],"sources":["/home/danilo/√Årea de trabalho/formsync-nx/apps/front/src/app/services/session-monitor.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { BehaviorSubject, interval, Observable } from 'rxjs';\nimport { environment } from '../../environments/environment';\n\n@Injectable({ providedIn: 'root' })\nexport class SessionMonitorService {\n    private API_URL = environment.apiUrl;\n    private sessionCheckInterval: any;\n    private sessionStatusSubject = new BehaviorSubject<boolean>(true);\n\n    public sessionStatus$ = this.sessionStatusSubject.asObservable();\n\n    constructor(\n        private http: HttpClient,\n        private router: Router\n    ) { }\n\n    /**\n     * Inicia o monitoramento da sess√£o\n     */\n    startMonitoring(token: string) {\n        if (this.sessionCheckInterval) {\n            this.stopMonitoring();\n        }\n\n        // Verificar status da sess√£o a cada 10 segundos (mais responsivo)\n        this.sessionCheckInterval = interval(10000).subscribe(() => {\n            this.checkSessionStatus(token);\n        });\n\n        console.log('üîç Monitoramento de sess√£o iniciado');\n    }\n\n    /**\n     * Para o monitoramento da sess√£o\n     */\n    stopMonitoring() {\n        if (this.sessionCheckInterval) {\n            this.sessionCheckInterval.unsubscribe();\n            this.sessionCheckInterval = null;\n            console.log('üîç Monitoramento de sess√£o parado');\n        }\n    }\n\n    /**\n     * Verifica o status da sess√£o no backend\n     */\n    private checkSessionStatus(token: string) {\n        if (!token) {\n            return;\n        }\n\n        this.http.get<{ authenticated: boolean; status: string; reason?: string }>(`${this.API_URL}/auth/session-status`, {\n            headers: { Authorization: `Bearer ${token}` }\n        }).subscribe({\n            next: (response) => {\n                if (!response.authenticated || response.status !== 'ACTIVE') {\n                    console.warn('‚ö†Ô∏è Sess√£o inv√°lida detectada:', response.reason || 'Sess√£o inativa');\n                    this.handleSessionInvalid();\n                } else {\n                    this.sessionStatusSubject.next(true);\n                }\n            },\n            error: (error) => {\n                console.error('‚ùå Erro ao verificar status da sess√£o:', error);\n\n                // Se for erro 401, 500 com JWT expirado, ou qualquer erro de autentica√ß√£o\n                if (error.status === 401 ||\n                    (error.status === 500 && error.error?.reason === 'Erro interno') ||\n                    (error.status === 500 && error.error?.status === 'ERROR')) {\n                    console.warn('üö® Sess√£o inv√°lida detectada - Limpando dados locais');\n                    this.handleSessionInvalid();\n                }\n            }\n        });\n    }\n\n    /**\n     * Trata sess√£o inv√°lida\n     */\n    private handleSessionInvalid() {\n        this.sessionStatusSubject.next(false);\n\n        // Parar monitoramento\n        this.stopMonitoring();\n\n        // Limpar dados locais\n        localStorage.removeItem('token');\n        localStorage.removeItem('nome');\n        localStorage.removeItem('plano');\n\n        console.warn('üö® Sess√£o invalidada - Redirecionando para login');\n\n        // Redirecionar para login\n        this.router.navigate(['/login']);\n    }\n\n    /**\n     * Verifica se a sess√£o est√° ativa\n     */\n    isSessionActive(): boolean {\n        return this.sessionStatusSubject.value;\n    }\n\n    /**\n     * For√ßa verifica√ß√£o imediata do status da sess√£o\n     */\n    forceCheckSession(token: string) {\n        this.checkSessionStatus(token);\n    }\n\n    /**\n     * Obt√©m estat√≠sticas da sess√£o (para debug)\n     */\n    getSessionStats(token: string): Observable<any> {\n        return this.http.get(`${this.API_URL}/auth/session-stats`, {\n            headers: { Authorization: `Bearer ${token}` }\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}