{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, inject, NgZone, DOCUMENT, RendererFactory2, Injectable, ElementRef, EventEmitter, Directive, Output } from '@angular/core';\nimport { BehaviorSubject, Subject, of } from 'rxjs';\nimport { skip, distinctUntilChanged, takeUntil } from 'rxjs/operators';\nimport { isFakeMousedownFromScreenReader, isFakeTouchstartFromScreenReader } from './fake-event-detection.mjs';\nimport { ALT, CONTROL, MAC_META, META, SHIFT } from './keycodes2.mjs';\nimport { _getEventTarget, _getShadowRoot } from './shadow-dom.mjs';\nimport { Platform } from './platform2.mjs';\nimport { normalizePassiveListenerOptions } from './passive-listeners.mjs';\nimport { coerceElement } from './element.mjs';\n\n/**\n * Injectable options for the InputModalityDetector. These are shallowly merged with the default\n * options.\n */\nconst INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken('cdk-input-modality-detector-options');\n/**\n * Default options for the InputModalityDetector.\n *\n * Modifier keys are ignored by default (i.e. when pressed won't cause the service to detect\n * keyboard input modality) for two reasons:\n *\n * 1. Modifier keys are commonly used with mouse to perform actions such as 'right click' or 'open\n *    in new tab', and are thus less representative of actual keyboard interaction.\n * 2. VoiceOver triggers some keyboard events when linearly navigating with Control + Option (but\n *    confusingly not with Caps Lock). Thus, to have parity with other screen readers, we ignore\n *    these keys so as to not update the input modality.\n *\n * Note that we do not by default ignore the right Meta key on Safari because it has the same key\n * code as the ContextMenu key on other browsers. When we switch to using event.key, we can\n * distinguish between the two.\n */\nconst INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {\n  ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT]\n};\n/**\n * The amount of time needed to pass after a touchstart event in order for a subsequent mousedown\n * event to be attributed as mouse and not touch.\n *\n * This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n * that a value of around 650ms seems appropriate.\n */\nconst TOUCH_BUFFER_MS = 650;\n/**\n * Event listener options that enable capturing and also mark the listener as passive if the browser\n * supports it.\n */\nconst modalityEventListenerOptions = {\n  passive: true,\n  capture: true\n};\n/**\n * Service that detects the user's input modality.\n *\n * This service does not update the input modality when a user navigates with a screen reader\n * (e.g. linear navigation with VoiceOver, object navigation / browse mode with NVDA, virtual PC\n * cursor mode with JAWS). This is in part due to technical limitations (i.e. keyboard events do not\n * fire as expected in these modes) but is also arguably the correct behavior. Navigating with a\n * screen reader is akin to visually scanning a page, and should not be interpreted as actual user\n * input interaction.\n *\n * When a user is not navigating but *interacting* with a screen reader, this service attempts to\n * update the input modality to keyboard, but in general this service's behavior is largely\n * undefined.\n */\nclass InputModalityDetector {\n  _platform = inject(Platform);\n  _listenerCleanups;\n  /** Emits whenever an input modality is detected. */\n  modalityDetected;\n  /** Emits when the input modality changes. */\n  modalityChanged;\n  /** The most recently detected input modality. */\n  get mostRecentModality() {\n    return this._modality.value;\n  }\n  /**\n   * The most recently detected input modality event target. Is null if no input modality has been\n   * detected or if the associated event target is null for some unknown reason.\n   */\n  _mostRecentTarget = null;\n  /** The underlying BehaviorSubject that emits whenever an input modality is detected. */\n  _modality = new BehaviorSubject(null);\n  /** Options for this InputModalityDetector. */\n  _options;\n  /**\n   * The timestamp of the last touch input modality. Used to determine whether mousedown events\n   * should be attributed to mouse or touch.\n   */\n  _lastTouchMs = 0;\n  /**\n   * Handles keydown events. Must be an arrow function in order to preserve the context when it gets\n   * bound.\n   */\n  _onKeydown = event => {\n    // If this is one of the keys we should ignore, then ignore it and don't update the input\n    // modality to keyboard.\n    if (this._options?.ignoreKeys?.some(keyCode => keyCode === event.keyCode)) {\n      return;\n    }\n    this._modality.next('keyboard');\n    this._mostRecentTarget = _getEventTarget(event);\n  };\n  /**\n   * Handles mousedown events. Must be an arrow function in order to preserve the context when it\n   * gets bound.\n   */\n  _onMousedown = event => {\n    // Touches trigger both touch and mouse events, so we need to distinguish between mouse events\n    // that were triggered via mouse vs touch. To do so, check if the mouse event occurs closely\n    // after the previous touch event.\n    if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {\n      return;\n    }\n    // Fake mousedown events are fired by some screen readers when controls are activated by the\n    // screen reader. Attribute them to keyboard input modality.\n    this._modality.next(isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse');\n    this._mostRecentTarget = _getEventTarget(event);\n  };\n  /**\n   * Handles touchstart events. Must be an arrow function in order to preserve the context when it\n   * gets bound.\n   */\n  _onTouchstart = event => {\n    // Same scenario as mentioned in _onMousedown, but on touch screen devices, fake touchstart\n    // events are fired. Again, attribute to keyboard input modality.\n    if (isFakeTouchstartFromScreenReader(event)) {\n      this._modality.next('keyboard');\n      return;\n    }\n    // Store the timestamp of this touch event, as it's used to distinguish between mouse events\n    // triggered via mouse vs touch.\n    this._lastTouchMs = Date.now();\n    this._modality.next('touch');\n    this._mostRecentTarget = _getEventTarget(event);\n  };\n  constructor() {\n    const ngZone = inject(NgZone);\n    const document = inject(DOCUMENT);\n    const options = inject(INPUT_MODALITY_DETECTOR_OPTIONS, {\n      optional: true\n    });\n    this._options = {\n      ...INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS,\n      ...options\n    };\n    // Skip the first emission as it's null.\n    this.modalityDetected = this._modality.pipe(skip(1));\n    this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());\n    // If we're not in a browser, this service should do nothing, as there's no relevant input\n    // modality to detect.\n    if (this._platform.isBrowser) {\n      const renderer = inject(RendererFactory2).createRenderer(null, null);\n      this._listenerCleanups = ngZone.runOutsideAngular(() => {\n        return [renderer.listen(document, 'keydown', this._onKeydown, modalityEventListenerOptions), renderer.listen(document, 'mousedown', this._onMousedown, modalityEventListenerOptions), renderer.listen(document, 'touchstart', this._onTouchstart, modalityEventListenerOptions)];\n      });\n    }\n  }\n  ngOnDestroy() {\n    this._modality.complete();\n    this._listenerCleanups?.forEach(cleanup => cleanup());\n  }\n  static ɵfac = function InputModalityDetector_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || InputModalityDetector)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InputModalityDetector,\n    factory: InputModalityDetector.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InputModalityDetector, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n\n/** Detection mode used for attributing the origin of a focus event. */\nvar FocusMonitorDetectionMode;\n(function (FocusMonitorDetectionMode) {\n  /**\n   * Any mousedown, keydown, or touchstart event that happened in the previous\n   * tick or the current tick will be used to assign a focus event's origin (to\n   * either mouse, keyboard, or touch). This is the default option.\n   */\n  FocusMonitorDetectionMode[FocusMonitorDetectionMode[\"IMMEDIATE\"] = 0] = \"IMMEDIATE\";\n  /**\n   * A focus event's origin is always attributed to the last corresponding\n   * mousedown, keydown, or touchstart event, no matter how long ago it occurred.\n   */\n  FocusMonitorDetectionMode[FocusMonitorDetectionMode[\"EVENTUAL\"] = 1] = \"EVENTUAL\";\n})(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));\n/** InjectionToken for FocusMonitorOptions. */\nconst FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken('cdk-focus-monitor-default-options');\n/**\n * Event listener options that enable capturing and also\n * mark the listener as passive if the browser supports it.\n */\nconst captureEventListenerOptions = normalizePassiveListenerOptions({\n  passive: true,\n  capture: true\n});\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\nclass FocusMonitor {\n  _ngZone = inject(NgZone);\n  _platform = inject(Platform);\n  _inputModalityDetector = inject(InputModalityDetector);\n  /** The focus origin that the next focus event is a result of. */\n  _origin = null;\n  /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\n  _lastFocusOrigin;\n  /** Whether the window has just been focused. */\n  _windowFocused = false;\n  /** The timeout id of the window focus timeout. */\n  _windowFocusTimeoutId;\n  /** The timeout id of the origin clearing timeout. */\n  _originTimeoutId;\n  /**\n   * Whether the origin was determined via a touch interaction. Necessary as properly attributing\n   * focus events to touch interactions requires special logic.\n   */\n  _originFromTouchInteraction = false;\n  /** Map of elements being monitored to their info. */\n  _elementInfo = new Map();\n  /** The number of elements currently being monitored. */\n  _monitoredElementCount = 0;\n  /**\n   * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\n   * as well as the number of monitored elements that they contain. We have to treat focus/blur\n   * handlers differently from the rest of the events, because the browser won't emit events\n   * to the document when focus moves inside of a shadow root.\n   */\n  _rootNodeFocusListenerCount = new Map();\n  /**\n   * The specified detection mode, used for attributing the origin of a focus\n   * event.\n   */\n  _detectionMode;\n  /**\n   * Event listener for `focus` events on the window.\n   * Needs to be an arrow function in order to preserve the context when it gets bound.\n   */\n  _windowFocusListener = () => {\n    // Make a note of when the window regains focus, so we can\n    // restore the origin info for the focused element.\n    this._windowFocused = true;\n    this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);\n  };\n  /** Used to reference correct document/window */\n  _document = inject(DOCUMENT);\n  /** Subject for stopping our InputModalityDetector subscription. */\n  _stopInputModalityDetector = new Subject();\n  constructor() {\n    const options = inject(FOCUS_MONITOR_DEFAULT_OPTIONS, {\n      optional: true\n    });\n    this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;\n  }\n  /**\n   * Event listener for `focus` and 'blur' events on the document.\n   * Needs to be an arrow function in order to preserve the context when it gets bound.\n   */\n  _rootNodeFocusAndBlurListener = event => {\n    const target = _getEventTarget(event);\n    // We need to walk up the ancestor chain in order to support `checkChildren`.\n    for (let element = target; element; element = element.parentElement) {\n      if (event.type === 'focus') {\n        this._onFocus(event, element);\n      } else {\n        this._onBlur(event, element);\n      }\n    }\n  };\n  monitor(element, checkChildren = false) {\n    const nativeElement = coerceElement(element);\n    // Do nothing if we're not on the browser platform or the passed in node isn't an element.\n    if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {\n      // Note: we don't want the observable to emit at all so we don't pass any parameters.\n      return of();\n    }\n    // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\n    // the shadow root, rather than the `document`, because the browser won't emit focus events\n    // to the `document`, if focus is moving within the same shadow root.\n    const rootNode = _getShadowRoot(nativeElement) || this._document;\n    const cachedInfo = this._elementInfo.get(nativeElement);\n    // Check if we're already monitoring this element.\n    if (cachedInfo) {\n      if (checkChildren) {\n        // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\n        // observers into ones that behave as if `checkChildren` was turned on. We need a more\n        // robust solution.\n        cachedInfo.checkChildren = true;\n      }\n      return cachedInfo.subject;\n    }\n    // Create monitored element info.\n    const info = {\n      checkChildren: checkChildren,\n      subject: new Subject(),\n      rootNode\n    };\n    this._elementInfo.set(nativeElement, info);\n    this._registerGlobalListeners(info);\n    return info.subject;\n  }\n  stopMonitoring(element) {\n    const nativeElement = coerceElement(element);\n    const elementInfo = this._elementInfo.get(nativeElement);\n    if (elementInfo) {\n      elementInfo.subject.complete();\n      this._setClasses(nativeElement);\n      this._elementInfo.delete(nativeElement);\n      this._removeGlobalListeners(elementInfo);\n    }\n  }\n  focusVia(element, origin, options) {\n    const nativeElement = coerceElement(element);\n    const focusedElement = this._document.activeElement;\n    // If the element is focused already, calling `focus` again won't trigger the event listener\n    // which means that the focus classes won't be updated. If that's the case, update the classes\n    // directly without waiting for an event.\n    if (nativeElement === focusedElement) {\n      this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));\n    } else {\n      this._setOrigin(origin);\n      // `focus` isn't available on the server\n      if (typeof nativeElement.focus === 'function') {\n        nativeElement.focus(options);\n      }\n    }\n  }\n  ngOnDestroy() {\n    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n  }\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  _getWindow() {\n    return this._document.defaultView || window;\n  }\n  _getFocusOrigin(focusEventTarget) {\n    if (this._origin) {\n      // If the origin was realized via a touch interaction, we need to perform additional checks\n      // to determine whether the focus origin should be attributed to touch or program.\n      if (this._originFromTouchInteraction) {\n        return this._shouldBeAttributedToTouch(focusEventTarget) ? 'touch' : 'program';\n      } else {\n        return this._origin;\n      }\n    }\n    // If the window has just regained focus, we can restore the most recent origin from before the\n    // window blurred. Otherwise, we've reached the point where we can't identify the source of the\n    // focus. This typically means one of two things happened:\n    //\n    // 1) The element was programmatically focused, or\n    // 2) The element was focused via screen reader navigation (which generally doesn't fire\n    //    events).\n    //\n    // Because we can't distinguish between these two cases, we default to setting `program`.\n    if (this._windowFocused && this._lastFocusOrigin) {\n      return this._lastFocusOrigin;\n    }\n    // If the interaction is coming from an input label, we consider it a mouse interactions.\n    // This is a special case where focus moves on `click`, rather than `mousedown` which breaks\n    // our detection, because all our assumptions are for `mousedown`. We need to handle this\n    // special case, because it's very common for checkboxes and radio buttons.\n    if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {\n      return 'mouse';\n    }\n    return 'program';\n  }\n  /**\n   * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a\n   * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we\n   * handle a focus event following a touch interaction, we need to determine whether (1) the focus\n   * event was directly caused by the touch interaction or (2) the focus event was caused by a\n   * subsequent programmatic focus call triggered by the touch interaction.\n   * @param focusEventTarget The target of the focus event under examination.\n   */\n  _shouldBeAttributedToTouch(focusEventTarget) {\n    // Please note that this check is not perfect. Consider the following edge case:\n    //\n    // <div #parent tabindex=\"0\">\n    //   <div #child tabindex=\"0\" (click)=\"#parent.focus()\"></div>\n    // </div>\n    //\n    // Suppose there is a FocusMonitor in IMMEDIATE mode attached to #parent. When the user touches\n    // #child, #parent is programmatically focused. This code will attribute the focus to touch\n    // instead of program. This is a relatively minor edge-case that can be worked around by using\n    // focusVia(parent, 'program') to focus #parent.\n    return this._detectionMode === FocusMonitorDetectionMode.EVENTUAL || !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget);\n  }\n  /**\n   * Sets the focus classes on the element based on the given focus origin.\n   * @param element The element to update the classes on.\n   * @param origin The focus origin.\n   */\n  _setClasses(element, origin) {\n    element.classList.toggle('cdk-focused', !!origin);\n    element.classList.toggle('cdk-touch-focused', origin === 'touch');\n    element.classList.toggle('cdk-keyboard-focused', origin === 'keyboard');\n    element.classList.toggle('cdk-mouse-focused', origin === 'mouse');\n    element.classList.toggle('cdk-program-focused', origin === 'program');\n  }\n  /**\n   * Updates the focus origin. If we're using immediate detection mode, we schedule an async\n   * function to clear the origin at the end of a timeout. The duration of the timeout depends on\n   * the origin being set.\n   * @param origin The origin to set.\n   * @param isFromInteraction Whether we are setting the origin from an interaction event.\n   */\n  _setOrigin(origin, isFromInteraction = false) {\n    this._ngZone.runOutsideAngular(() => {\n      this._origin = origin;\n      this._originFromTouchInteraction = origin === 'touch' && isFromInteraction;\n      // If we're in IMMEDIATE mode, reset the origin at the next tick (or in `TOUCH_BUFFER_MS` ms\n      // for a touch event). We reset the origin at the next tick because Firefox focuses one tick\n      // after the interaction event. We wait `TOUCH_BUFFER_MS` ms before resetting the origin for\n      // a touch event because when a touch event is fired, the associated focus event isn't yet in\n      // the event queue. Before doing so, clear any pending timeouts.\n      if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {\n        clearTimeout(this._originTimeoutId);\n        const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;\n        this._originTimeoutId = setTimeout(() => this._origin = null, ms);\n      }\n    });\n  }\n  /**\n   * Handles focus events on a registered element.\n   * @param event The focus event.\n   * @param element The monitored element.\n   */\n  _onFocus(event, element) {\n    // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n    // focus event affecting the monitored element. If we want to use the origin of the first event\n    // instead we should check for the cdk-focused class here and return if the element already has\n    // it. (This only matters for elements that have includesChildren = true).\n    // If we are not counting child-element-focus as focused, make sure that the event target is the\n    // monitored element itself.\n    const elementInfo = this._elementInfo.get(element);\n    const focusEventTarget = _getEventTarget(event);\n    if (!elementInfo || !elementInfo.checkChildren && element !== focusEventTarget) {\n      return;\n    }\n    this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);\n  }\n  /**\n   * Handles blur events on a registered element.\n   * @param event The blur event.\n   * @param element The monitored element.\n   */\n  _onBlur(event, element) {\n    // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n    // order to focus another child of the monitored element.\n    const elementInfo = this._elementInfo.get(element);\n    if (!elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget)) {\n      return;\n    }\n    this._setClasses(element);\n    this._emitOrigin(elementInfo, null);\n  }\n  _emitOrigin(info, origin) {\n    if (info.subject.observers.length) {\n      this._ngZone.run(() => info.subject.next(origin));\n    }\n  }\n  _registerGlobalListeners(elementInfo) {\n    if (!this._platform.isBrowser) {\n      return;\n    }\n    const rootNode = elementInfo.rootNode;\n    const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\n    if (!rootNodeFocusListeners) {\n      this._ngZone.runOutsideAngular(() => {\n        rootNode.addEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n        rootNode.addEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n      });\n    }\n    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\n    // Register global listeners when first element is monitored.\n    if (++this._monitoredElementCount === 1) {\n      // Note: we listen to events in the capture phase so we\n      // can detect them even if the user stops propagation.\n      this._ngZone.runOutsideAngular(() => {\n        const window = this._getWindow();\n        window.addEventListener('focus', this._windowFocusListener);\n      });\n      // The InputModalityDetector is also just a collection of global listeners.\n      this._inputModalityDetector.modalityDetected.pipe(takeUntil(this._stopInputModalityDetector)).subscribe(modality => {\n        this._setOrigin(modality, true /* isFromInteraction */);\n      });\n    }\n  }\n  _removeGlobalListeners(elementInfo) {\n    const rootNode = elementInfo.rootNode;\n    if (this._rootNodeFocusListenerCount.has(rootNode)) {\n      const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);\n      if (rootNodeFocusListeners > 1) {\n        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\n      } else {\n        rootNode.removeEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n        rootNode.removeEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n        this._rootNodeFocusListenerCount.delete(rootNode);\n      }\n    }\n    // Unregister global listeners when last element is unmonitored.\n    if (! --this._monitoredElementCount) {\n      const window = this._getWindow();\n      window.removeEventListener('focus', this._windowFocusListener);\n      // Equivalently, stop our InputModalityDetector subscription.\n      this._stopInputModalityDetector.next();\n      // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n      clearTimeout(this._windowFocusTimeoutId);\n      clearTimeout(this._originTimeoutId);\n    }\n  }\n  /** Updates all the state on an element once its focus origin has changed. */\n  _originChanged(element, origin, elementInfo) {\n    this._setClasses(element, origin);\n    this._emitOrigin(elementInfo, origin);\n    this._lastFocusOrigin = origin;\n  }\n  /**\n   * Collects the `MonitoredElementInfo` of a particular element and\n   * all of its ancestors that have enabled `checkChildren`.\n   * @param element Element from which to start the search.\n   */\n  _getClosestElementsInfo(element) {\n    const results = [];\n    this._elementInfo.forEach((info, currentElement) => {\n      if (currentElement === element || info.checkChildren && currentElement.contains(element)) {\n        results.push([currentElement, info]);\n      }\n    });\n    return results;\n  }\n  /**\n   * Returns whether an interaction is likely to have come from the user clicking the `label` of\n   * an `input` or `textarea` in order to focus it.\n   * @param focusEventTarget Target currently receiving focus.\n   */\n  _isLastInteractionFromInputLabel(focusEventTarget) {\n    const {\n      _mostRecentTarget: mostRecentTarget,\n      mostRecentModality\n    } = this._inputModalityDetector;\n    // If the last interaction used the mouse on an element contained by one of the labels\n    // of an `input`/`textarea` that is currently focused, it is very likely that the\n    // user redirected focus using the label.\n    if (mostRecentModality !== 'mouse' || !mostRecentTarget || mostRecentTarget === focusEventTarget || focusEventTarget.nodeName !== 'INPUT' && focusEventTarget.nodeName !== 'TEXTAREA' || focusEventTarget.disabled) {\n      return false;\n    }\n    const labels = focusEventTarget.labels;\n    if (labels) {\n      for (let i = 0; i < labels.length; i++) {\n        if (labels[i].contains(mostRecentTarget)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  static ɵfac = function FocusMonitor_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || FocusMonitor)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FocusMonitor,\n    factory: FocusMonitor.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FocusMonitor, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nclass CdkMonitorFocus {\n  _elementRef = inject(ElementRef);\n  _focusMonitor = inject(FocusMonitor);\n  _monitorSubscription;\n  _focusOrigin = null;\n  cdkFocusChange = new EventEmitter();\n  constructor() {}\n  get focusOrigin() {\n    return this._focusOrigin;\n  }\n  ngAfterViewInit() {\n    const element = this._elementRef.nativeElement;\n    this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute('cdkMonitorSubtreeFocus')).subscribe(origin => {\n      this._focusOrigin = origin;\n      this.cdkFocusChange.emit(origin);\n    });\n  }\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n    if (this._monitorSubscription) {\n      this._monitorSubscription.unsubscribe();\n    }\n  }\n  static ɵfac = function CdkMonitorFocus_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || CdkMonitorFocus)();\n  };\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkMonitorFocus,\n    selectors: [[\"\", \"cdkMonitorElementFocus\", \"\"], [\"\", \"cdkMonitorSubtreeFocus\", \"\"]],\n    outputs: {\n      cdkFocusChange: \"cdkFocusChange\"\n    },\n    exportAs: [\"cdkMonitorFocus\"]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMonitorFocus, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n      exportAs: 'cdkMonitorFocus'\n    }]\n  }], () => [], {\n    cdkFocusChange: [{\n      type: Output\n    }]\n  });\n})();\nexport { CdkMonitorFocus, FOCUS_MONITOR_DEFAULT_OPTIONS, FocusMonitor, FocusMonitorDetectionMode, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS, INPUT_MODALITY_DETECTOR_OPTIONS, InputModalityDetector };","map":{"version":3,"names":["i0","InjectionToken","inject","NgZone","DOCUMENT","RendererFactory2","Injectable","ElementRef","EventEmitter","Directive","Output","BehaviorSubject","Subject","of","skip","distinctUntilChanged","takeUntil","isFakeMousedownFromScreenReader","isFakeTouchstartFromScreenReader","ALT","CONTROL","MAC_META","META","SHIFT","_getEventTarget","_getShadowRoot","Platform","normalizePassiveListenerOptions","coerceElement","INPUT_MODALITY_DETECTOR_OPTIONS","INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS","ignoreKeys","TOUCH_BUFFER_MS","modalityEventListenerOptions","passive","capture","InputModalityDetector","_platform","_listenerCleanups","modalityDetected","modalityChanged","mostRecentModality","_modality","value","_mostRecentTarget","_options","_lastTouchMs","_onKeydown","event","some","keyCode","next","_onMousedown","Date","now","_onTouchstart","constructor","ngZone","document","options","optional","pipe","isBrowser","renderer","createRenderer","runOutsideAngular","listen","ngOnDestroy","complete","forEach","cleanup","ɵfac","InputModalityDetector_Factory","__ngFactoryType__","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ngDevMode","ɵsetClassMetadata","type","args","FocusMonitorDetectionMode","FOCUS_MONITOR_DEFAULT_OPTIONS","captureEventListenerOptions","FocusMonitor","_ngZone","_inputModalityDetector","_origin","_lastFocusOrigin","_windowFocused","_windowFocusTimeoutId","_originTimeoutId","_originFromTouchInteraction","_elementInfo","Map","_monitoredElementCount","_rootNodeFocusListenerCount","_detectionMode","_windowFocusListener","setTimeout","_document","_stopInputModalityDetector","detectionMode","IMMEDIATE","_rootNodeFocusAndBlurListener","target","element","parentElement","_onFocus","_onBlur","monitor","checkChildren","nativeElement","nodeType","rootNode","cachedInfo","get","subject","info","set","_registerGlobalListeners","stopMonitoring","elementInfo","_setClasses","delete","_removeGlobalListeners","focusVia","origin","focusedElement","activeElement","_getClosestElementsInfo","currentElement","_originChanged","_setOrigin","focus","_info","_getWindow","defaultView","window","_getFocusOrigin","focusEventTarget","_shouldBeAttributedToTouch","_isLastInteractionFromInputLabel","EVENTUAL","contains","classList","toggle","isFromInteraction","clearTimeout","ms","relatedTarget","Node","_emitOrigin","observers","length","run","rootNodeFocusListeners","addEventListener","subscribe","modality","has","removeEventListener","results","push","mostRecentTarget","nodeName","disabled","labels","i","FocusMonitor_Factory","CdkMonitorFocus","_elementRef","_focusMonitor","_monitorSubscription","_focusOrigin","cdkFocusChange","focusOrigin","ngAfterViewInit","hasAttribute","emit","unsubscribe","CdkMonitorFocus_Factory","ɵdir","ɵɵdefineDirective","selectors","outputs","exportAs","selector"],"sources":["/home/danilo/Área de trabalho/formsync-nx/apps/front/node_modules/@angular/cdk/fesm2022/focus-monitor.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, inject, NgZone, DOCUMENT, RendererFactory2, Injectable, ElementRef, EventEmitter, Directive, Output } from '@angular/core';\nimport { BehaviorSubject, Subject, of } from 'rxjs';\nimport { skip, distinctUntilChanged, takeUntil } from 'rxjs/operators';\nimport { isFakeMousedownFromScreenReader, isFakeTouchstartFromScreenReader } from './fake-event-detection.mjs';\nimport { ALT, CONTROL, MAC_META, META, SHIFT } from './keycodes2.mjs';\nimport { _getEventTarget, _getShadowRoot } from './shadow-dom.mjs';\nimport { Platform } from './platform2.mjs';\nimport { normalizePassiveListenerOptions } from './passive-listeners.mjs';\nimport { coerceElement } from './element.mjs';\n\n/**\n * Injectable options for the InputModalityDetector. These are shallowly merged with the default\n * options.\n */\nconst INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken('cdk-input-modality-detector-options');\n/**\n * Default options for the InputModalityDetector.\n *\n * Modifier keys are ignored by default (i.e. when pressed won't cause the service to detect\n * keyboard input modality) for two reasons:\n *\n * 1. Modifier keys are commonly used with mouse to perform actions such as 'right click' or 'open\n *    in new tab', and are thus less representative of actual keyboard interaction.\n * 2. VoiceOver triggers some keyboard events when linearly navigating with Control + Option (but\n *    confusingly not with Caps Lock). Thus, to have parity with other screen readers, we ignore\n *    these keys so as to not update the input modality.\n *\n * Note that we do not by default ignore the right Meta key on Safari because it has the same key\n * code as the ContextMenu key on other browsers. When we switch to using event.key, we can\n * distinguish between the two.\n */\nconst INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {\n    ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT],\n};\n/**\n * The amount of time needed to pass after a touchstart event in order for a subsequent mousedown\n * event to be attributed as mouse and not touch.\n *\n * This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n * that a value of around 650ms seems appropriate.\n */\nconst TOUCH_BUFFER_MS = 650;\n/**\n * Event listener options that enable capturing and also mark the listener as passive if the browser\n * supports it.\n */\nconst modalityEventListenerOptions = {\n    passive: true,\n    capture: true,\n};\n/**\n * Service that detects the user's input modality.\n *\n * This service does not update the input modality when a user navigates with a screen reader\n * (e.g. linear navigation with VoiceOver, object navigation / browse mode with NVDA, virtual PC\n * cursor mode with JAWS). This is in part due to technical limitations (i.e. keyboard events do not\n * fire as expected in these modes) but is also arguably the correct behavior. Navigating with a\n * screen reader is akin to visually scanning a page, and should not be interpreted as actual user\n * input interaction.\n *\n * When a user is not navigating but *interacting* with a screen reader, this service attempts to\n * update the input modality to keyboard, but in general this service's behavior is largely\n * undefined.\n */\nclass InputModalityDetector {\n    _platform = inject(Platform);\n    _listenerCleanups;\n    /** Emits whenever an input modality is detected. */\n    modalityDetected;\n    /** Emits when the input modality changes. */\n    modalityChanged;\n    /** The most recently detected input modality. */\n    get mostRecentModality() {\n        return this._modality.value;\n    }\n    /**\n     * The most recently detected input modality event target. Is null if no input modality has been\n     * detected or if the associated event target is null for some unknown reason.\n     */\n    _mostRecentTarget = null;\n    /** The underlying BehaviorSubject that emits whenever an input modality is detected. */\n    _modality = new BehaviorSubject(null);\n    /** Options for this InputModalityDetector. */\n    _options;\n    /**\n     * The timestamp of the last touch input modality. Used to determine whether mousedown events\n     * should be attributed to mouse or touch.\n     */\n    _lastTouchMs = 0;\n    /**\n     * Handles keydown events. Must be an arrow function in order to preserve the context when it gets\n     * bound.\n     */\n    _onKeydown = (event) => {\n        // If this is one of the keys we should ignore, then ignore it and don't update the input\n        // modality to keyboard.\n        if (this._options?.ignoreKeys?.some(keyCode => keyCode === event.keyCode)) {\n            return;\n        }\n        this._modality.next('keyboard');\n        this._mostRecentTarget = _getEventTarget(event);\n    };\n    /**\n     * Handles mousedown events. Must be an arrow function in order to preserve the context when it\n     * gets bound.\n     */\n    _onMousedown = (event) => {\n        // Touches trigger both touch and mouse events, so we need to distinguish between mouse events\n        // that were triggered via mouse vs touch. To do so, check if the mouse event occurs closely\n        // after the previous touch event.\n        if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {\n            return;\n        }\n        // Fake mousedown events are fired by some screen readers when controls are activated by the\n        // screen reader. Attribute them to keyboard input modality.\n        this._modality.next(isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse');\n        this._mostRecentTarget = _getEventTarget(event);\n    };\n    /**\n     * Handles touchstart events. Must be an arrow function in order to preserve the context when it\n     * gets bound.\n     */\n    _onTouchstart = (event) => {\n        // Same scenario as mentioned in _onMousedown, but on touch screen devices, fake touchstart\n        // events are fired. Again, attribute to keyboard input modality.\n        if (isFakeTouchstartFromScreenReader(event)) {\n            this._modality.next('keyboard');\n            return;\n        }\n        // Store the timestamp of this touch event, as it's used to distinguish between mouse events\n        // triggered via mouse vs touch.\n        this._lastTouchMs = Date.now();\n        this._modality.next('touch');\n        this._mostRecentTarget = _getEventTarget(event);\n    };\n    constructor() {\n        const ngZone = inject(NgZone);\n        const document = inject(DOCUMENT);\n        const options = inject(INPUT_MODALITY_DETECTOR_OPTIONS, { optional: true });\n        this._options = {\n            ...INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS,\n            ...options,\n        };\n        // Skip the first emission as it's null.\n        this.modalityDetected = this._modality.pipe(skip(1));\n        this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());\n        // If we're not in a browser, this service should do nothing, as there's no relevant input\n        // modality to detect.\n        if (this._platform.isBrowser) {\n            const renderer = inject(RendererFactory2).createRenderer(null, null);\n            this._listenerCleanups = ngZone.runOutsideAngular(() => {\n                return [\n                    renderer.listen(document, 'keydown', this._onKeydown, modalityEventListenerOptions),\n                    renderer.listen(document, 'mousedown', this._onMousedown, modalityEventListenerOptions),\n                    renderer.listen(document, 'touchstart', this._onTouchstart, modalityEventListenerOptions),\n                ];\n            });\n        }\n    }\n    ngOnDestroy() {\n        this._modality.complete();\n        this._listenerCleanups?.forEach(cleanup => cleanup());\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-rc.1\", ngImport: i0, type: InputModalityDetector, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-rc.1\", ngImport: i0, type: InputModalityDetector, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-rc.1\", ngImport: i0, type: InputModalityDetector, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\n/** Detection mode used for attributing the origin of a focus event. */\nvar FocusMonitorDetectionMode;\n(function (FocusMonitorDetectionMode) {\n    /**\n     * Any mousedown, keydown, or touchstart event that happened in the previous\n     * tick or the current tick will be used to assign a focus event's origin (to\n     * either mouse, keyboard, or touch). This is the default option.\n     */\n    FocusMonitorDetectionMode[FocusMonitorDetectionMode[\"IMMEDIATE\"] = 0] = \"IMMEDIATE\";\n    /**\n     * A focus event's origin is always attributed to the last corresponding\n     * mousedown, keydown, or touchstart event, no matter how long ago it occurred.\n     */\n    FocusMonitorDetectionMode[FocusMonitorDetectionMode[\"EVENTUAL\"] = 1] = \"EVENTUAL\";\n})(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));\n/** InjectionToken for FocusMonitorOptions. */\nconst FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken('cdk-focus-monitor-default-options');\n/**\n * Event listener options that enable capturing and also\n * mark the listener as passive if the browser supports it.\n */\nconst captureEventListenerOptions = normalizePassiveListenerOptions({\n    passive: true,\n    capture: true,\n});\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\nclass FocusMonitor {\n    _ngZone = inject(NgZone);\n    _platform = inject(Platform);\n    _inputModalityDetector = inject(InputModalityDetector);\n    /** The focus origin that the next focus event is a result of. */\n    _origin = null;\n    /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\n    _lastFocusOrigin;\n    /** Whether the window has just been focused. */\n    _windowFocused = false;\n    /** The timeout id of the window focus timeout. */\n    _windowFocusTimeoutId;\n    /** The timeout id of the origin clearing timeout. */\n    _originTimeoutId;\n    /**\n     * Whether the origin was determined via a touch interaction. Necessary as properly attributing\n     * focus events to touch interactions requires special logic.\n     */\n    _originFromTouchInteraction = false;\n    /** Map of elements being monitored to their info. */\n    _elementInfo = new Map();\n    /** The number of elements currently being monitored. */\n    _monitoredElementCount = 0;\n    /**\n     * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\n     * as well as the number of monitored elements that they contain. We have to treat focus/blur\n     * handlers differently from the rest of the events, because the browser won't emit events\n     * to the document when focus moves inside of a shadow root.\n     */\n    _rootNodeFocusListenerCount = new Map();\n    /**\n     * The specified detection mode, used for attributing the origin of a focus\n     * event.\n     */\n    _detectionMode;\n    /**\n     * Event listener for `focus` events on the window.\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\n     */\n    _windowFocusListener = () => {\n        // Make a note of when the window regains focus, so we can\n        // restore the origin info for the focused element.\n        this._windowFocused = true;\n        this._windowFocusTimeoutId = setTimeout(() => (this._windowFocused = false));\n    };\n    /** Used to reference correct document/window */\n    _document = inject(DOCUMENT);\n    /** Subject for stopping our InputModalityDetector subscription. */\n    _stopInputModalityDetector = new Subject();\n    constructor() {\n        const options = inject(FOCUS_MONITOR_DEFAULT_OPTIONS, {\n            optional: true,\n        });\n        this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;\n    }\n    /**\n     * Event listener for `focus` and 'blur' events on the document.\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\n     */\n    _rootNodeFocusAndBlurListener = (event) => {\n        const target = _getEventTarget(event);\n        // We need to walk up the ancestor chain in order to support `checkChildren`.\n        for (let element = target; element; element = element.parentElement) {\n            if (event.type === 'focus') {\n                this._onFocus(event, element);\n            }\n            else {\n                this._onBlur(event, element);\n            }\n        }\n    };\n    monitor(element, checkChildren = false) {\n        const nativeElement = coerceElement(element);\n        // Do nothing if we're not on the browser platform or the passed in node isn't an element.\n        if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {\n            // Note: we don't want the observable to emit at all so we don't pass any parameters.\n            return of();\n        }\n        // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\n        // the shadow root, rather than the `document`, because the browser won't emit focus events\n        // to the `document`, if focus is moving within the same shadow root.\n        const rootNode = _getShadowRoot(nativeElement) || this._document;\n        const cachedInfo = this._elementInfo.get(nativeElement);\n        // Check if we're already monitoring this element.\n        if (cachedInfo) {\n            if (checkChildren) {\n                // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\n                // observers into ones that behave as if `checkChildren` was turned on. We need a more\n                // robust solution.\n                cachedInfo.checkChildren = true;\n            }\n            return cachedInfo.subject;\n        }\n        // Create monitored element info.\n        const info = {\n            checkChildren: checkChildren,\n            subject: new Subject(),\n            rootNode,\n        };\n        this._elementInfo.set(nativeElement, info);\n        this._registerGlobalListeners(info);\n        return info.subject;\n    }\n    stopMonitoring(element) {\n        const nativeElement = coerceElement(element);\n        const elementInfo = this._elementInfo.get(nativeElement);\n        if (elementInfo) {\n            elementInfo.subject.complete();\n            this._setClasses(nativeElement);\n            this._elementInfo.delete(nativeElement);\n            this._removeGlobalListeners(elementInfo);\n        }\n    }\n    focusVia(element, origin, options) {\n        const nativeElement = coerceElement(element);\n        const focusedElement = this._document.activeElement;\n        // If the element is focused already, calling `focus` again won't trigger the event listener\n        // which means that the focus classes won't be updated. If that's the case, update the classes\n        // directly without waiting for an event.\n        if (nativeElement === focusedElement) {\n            this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));\n        }\n        else {\n            this._setOrigin(origin);\n            // `focus` isn't available on the server\n            if (typeof nativeElement.focus === 'function') {\n                nativeElement.focus(options);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document.defaultView || window;\n    }\n    _getFocusOrigin(focusEventTarget) {\n        if (this._origin) {\n            // If the origin was realized via a touch interaction, we need to perform additional checks\n            // to determine whether the focus origin should be attributed to touch or program.\n            if (this._originFromTouchInteraction) {\n                return this._shouldBeAttributedToTouch(focusEventTarget) ? 'touch' : 'program';\n            }\n            else {\n                return this._origin;\n            }\n        }\n        // If the window has just regained focus, we can restore the most recent origin from before the\n        // window blurred. Otherwise, we've reached the point where we can't identify the source of the\n        // focus. This typically means one of two things happened:\n        //\n        // 1) The element was programmatically focused, or\n        // 2) The element was focused via screen reader navigation (which generally doesn't fire\n        //    events).\n        //\n        // Because we can't distinguish between these two cases, we default to setting `program`.\n        if (this._windowFocused && this._lastFocusOrigin) {\n            return this._lastFocusOrigin;\n        }\n        // If the interaction is coming from an input label, we consider it a mouse interactions.\n        // This is a special case where focus moves on `click`, rather than `mousedown` which breaks\n        // our detection, because all our assumptions are for `mousedown`. We need to handle this\n        // special case, because it's very common for checkboxes and radio buttons.\n        if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {\n            return 'mouse';\n        }\n        return 'program';\n    }\n    /**\n     * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a\n     * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we\n     * handle a focus event following a touch interaction, we need to determine whether (1) the focus\n     * event was directly caused by the touch interaction or (2) the focus event was caused by a\n     * subsequent programmatic focus call triggered by the touch interaction.\n     * @param focusEventTarget The target of the focus event under examination.\n     */\n    _shouldBeAttributedToTouch(focusEventTarget) {\n        // Please note that this check is not perfect. Consider the following edge case:\n        //\n        // <div #parent tabindex=\"0\">\n        //   <div #child tabindex=\"0\" (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // Suppose there is a FocusMonitor in IMMEDIATE mode attached to #parent. When the user touches\n        // #child, #parent is programmatically focused. This code will attribute the focus to touch\n        // instead of program. This is a relatively minor edge-case that can be worked around by using\n        // focusVia(parent, 'program') to focus #parent.\n        return (this._detectionMode === FocusMonitorDetectionMode.EVENTUAL ||\n            !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget));\n    }\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param element The element to update the classes on.\n     * @param origin The focus origin.\n     */\n    _setClasses(element, origin) {\n        element.classList.toggle('cdk-focused', !!origin);\n        element.classList.toggle('cdk-touch-focused', origin === 'touch');\n        element.classList.toggle('cdk-keyboard-focused', origin === 'keyboard');\n        element.classList.toggle('cdk-mouse-focused', origin === 'mouse');\n        element.classList.toggle('cdk-program-focused', origin === 'program');\n    }\n    /**\n     * Updates the focus origin. If we're using immediate detection mode, we schedule an async\n     * function to clear the origin at the end of a timeout. The duration of the timeout depends on\n     * the origin being set.\n     * @param origin The origin to set.\n     * @param isFromInteraction Whether we are setting the origin from an interaction event.\n     */\n    _setOrigin(origin, isFromInteraction = false) {\n        this._ngZone.runOutsideAngular(() => {\n            this._origin = origin;\n            this._originFromTouchInteraction = origin === 'touch' && isFromInteraction;\n            // If we're in IMMEDIATE mode, reset the origin at the next tick (or in `TOUCH_BUFFER_MS` ms\n            // for a touch event). We reset the origin at the next tick because Firefox focuses one tick\n            // after the interaction event. We wait `TOUCH_BUFFER_MS` ms before resetting the origin for\n            // a touch event because when a touch event is fired, the associated focus event isn't yet in\n            // the event queue. Before doing so, clear any pending timeouts.\n            if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {\n                clearTimeout(this._originTimeoutId);\n                const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;\n                this._originTimeoutId = setTimeout(() => (this._origin = null), ms);\n            }\n        });\n    }\n    /**\n     * Handles focus events on a registered element.\n     * @param event The focus event.\n     * @param element The monitored element.\n     */\n    _onFocus(event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        const elementInfo = this._elementInfo.get(element);\n        const focusEventTarget = _getEventTarget(event);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== focusEventTarget)) {\n            return;\n        }\n        this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);\n    }\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    _onBlur(event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        const elementInfo = this._elementInfo.get(element);\n        if (!elementInfo ||\n            (elementInfo.checkChildren &&\n                event.relatedTarget instanceof Node &&\n                element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        this._emitOrigin(elementInfo, null);\n    }\n    _emitOrigin(info, origin) {\n        if (info.subject.observers.length) {\n            this._ngZone.run(() => info.subject.next(origin));\n        }\n    }\n    _registerGlobalListeners(elementInfo) {\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        const rootNode = elementInfo.rootNode;\n        const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\n        if (!rootNodeFocusListeners) {\n            this._ngZone.runOutsideAngular(() => {\n                rootNode.addEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                rootNode.addEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n            });\n        }\n        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount === 1) {\n            // Note: we listen to events in the capture phase so we\n            // can detect them even if the user stops propagation.\n            this._ngZone.runOutsideAngular(() => {\n                const window = this._getWindow();\n                window.addEventListener('focus', this._windowFocusListener);\n            });\n            // The InputModalityDetector is also just a collection of global listeners.\n            this._inputModalityDetector.modalityDetected\n                .pipe(takeUntil(this._stopInputModalityDetector))\n                .subscribe(modality => {\n                this._setOrigin(modality, true /* isFromInteraction */);\n            });\n        }\n    }\n    _removeGlobalListeners(elementInfo) {\n        const rootNode = elementInfo.rootNode;\n        if (this._rootNodeFocusListenerCount.has(rootNode)) {\n            const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);\n            if (rootNodeFocusListeners > 1) {\n                this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\n            }\n            else {\n                rootNode.removeEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                rootNode.removeEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                this._rootNodeFocusListenerCount.delete(rootNode);\n            }\n        }\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            const window = this._getWindow();\n            window.removeEventListener('focus', this._windowFocusListener);\n            // Equivalently, stop our InputModalityDetector subscription.\n            this._stopInputModalityDetector.next();\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n            clearTimeout(this._windowFocusTimeoutId);\n            clearTimeout(this._originTimeoutId);\n        }\n    }\n    /** Updates all the state on an element once its focus origin has changed. */\n    _originChanged(element, origin, elementInfo) {\n        this._setClasses(element, origin);\n        this._emitOrigin(elementInfo, origin);\n        this._lastFocusOrigin = origin;\n    }\n    /**\n     * Collects the `MonitoredElementInfo` of a particular element and\n     * all of its ancestors that have enabled `checkChildren`.\n     * @param element Element from which to start the search.\n     */\n    _getClosestElementsInfo(element) {\n        const results = [];\n        this._elementInfo.forEach((info, currentElement) => {\n            if (currentElement === element || (info.checkChildren && currentElement.contains(element))) {\n                results.push([currentElement, info]);\n            }\n        });\n        return results;\n    }\n    /**\n     * Returns whether an interaction is likely to have come from the user clicking the `label` of\n     * an `input` or `textarea` in order to focus it.\n     * @param focusEventTarget Target currently receiving focus.\n     */\n    _isLastInteractionFromInputLabel(focusEventTarget) {\n        const { _mostRecentTarget: mostRecentTarget, mostRecentModality } = this._inputModalityDetector;\n        // If the last interaction used the mouse on an element contained by one of the labels\n        // of an `input`/`textarea` that is currently focused, it is very likely that the\n        // user redirected focus using the label.\n        if (mostRecentModality !== 'mouse' ||\n            !mostRecentTarget ||\n            mostRecentTarget === focusEventTarget ||\n            (focusEventTarget.nodeName !== 'INPUT' && focusEventTarget.nodeName !== 'TEXTAREA') ||\n            focusEventTarget.disabled) {\n            return false;\n        }\n        const labels = focusEventTarget.labels;\n        if (labels) {\n            for (let i = 0; i < labels.length; i++) {\n                if (labels[i].contains(mostRecentTarget)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-rc.1\", ngImport: i0, type: FocusMonitor, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-rc.1\", ngImport: i0, type: FocusMonitor, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-rc.1\", ngImport: i0, type: FocusMonitor, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nclass CdkMonitorFocus {\n    _elementRef = inject(ElementRef);\n    _focusMonitor = inject(FocusMonitor);\n    _monitorSubscription;\n    _focusOrigin = null;\n    cdkFocusChange = new EventEmitter();\n    constructor() { }\n    get focusOrigin() {\n        return this._focusOrigin;\n    }\n    ngAfterViewInit() {\n        const element = this._elementRef.nativeElement;\n        this._monitorSubscription = this._focusMonitor\n            .monitor(element, element.nodeType === 1 && element.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(origin => {\n            this._focusOrigin = origin;\n            this.cdkFocusChange.emit(origin);\n        });\n    }\n    ngOnDestroy() {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n        if (this._monitorSubscription) {\n            this._monitorSubscription.unsubscribe();\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-rc.1\", ngImport: i0, type: CdkMonitorFocus, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-rc.1\", type: CdkMonitorFocus, isStandalone: true, selector: \"[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]\", outputs: { cdkFocusChange: \"cdkFocusChange\" }, exportAs: [\"cdkMonitorFocus\"], ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-rc.1\", ngImport: i0, type: CdkMonitorFocus, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                    exportAs: 'cdkMonitorFocus',\n                }]\n        }], ctorParameters: () => [], propDecorators: { cdkFocusChange: [{\n                type: Output\n            }] } });\n\nexport { CdkMonitorFocus, FOCUS_MONITOR_DEFAULT_OPTIONS, FocusMonitor, FocusMonitorDetectionMode, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS, INPUT_MODALITY_DETECTOR_OPTIONS, InputModalityDetector };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}