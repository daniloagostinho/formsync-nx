{"ast":null,"code":"import _asyncToGenerator from \"/home/danilo/\\xC1rea de trabalho/formsync-nx/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nexport class SecurityService {\n  crypto = window.crypto;\n  subtle = window.crypto.subtle;\n  constructor() {}\n  /**\n   * Valida se uma senha atende aos requisitos de seguran√ßa\n   */\n  validatePassword(password) {\n    const errors = [];\n    const {\n      minPasswordLength,\n      requireSpecialChars,\n      requireNumbers,\n      requireUppercase,\n      blockSequentialPasswords,\n      blockRepetitivePasswords\n    } = environment.security;\n    if (password.length < minPasswordLength) {\n      errors.push(`Senha deve ter pelo menos ${minPasswordLength} caracteres`);\n    }\n    if (requireUppercase && !/[A-Z]/.test(password)) {\n      errors.push('Senha deve conter pelo menos uma letra mai√∫scula');\n    }\n    if (requireNumbers && !/\\d/.test(password)) {\n      errors.push('Senha deve conter pelo menos um n√∫mero');\n    }\n    if (requireSpecialChars && !/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/.test(password)) {\n      errors.push('Senha deve conter pelo menos um caractere especial');\n    }\n    // Valida√ß√µes adicionais para senhas sequenciais e repetitivas\n    if (blockSequentialPasswords && this.isSequentialPassword(password)) {\n      errors.push('Senha sequencial n√£o permitida (ex: 123456, abcdef)');\n    }\n    if (blockRepetitivePasswords && this.isRepetitivePassword(password)) {\n      errors.push('Senha com padr√µes repetitivos n√£o permitida');\n    }\n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n  /**\n   * Verifica se √© uma senha sequencial\n   */\n  isSequentialPassword(password) {\n    const sequentialPatterns = ['123456', '12345', '1234', '123', '12', '000000', '00000', '0000', '000', '00', '111111', '11111', '1111', '111', '11', 'abcdef', 'abcde', 'abcd', 'abc', 'ab', 'qwerty', 'qwert', 'qwer', 'qwe', 'qw', '987654', '98765', '9876', '987', '98', '654321', '65432', '6543', '654', '65'];\n    return sequentialPatterns.some(pattern => password.toLowerCase().includes(pattern.toLowerCase()));\n  }\n  /**\n   * Verifica se √© uma senha repetitiva\n   */\n  isRepetitivePassword(password) {\n    if (password.length < 3) return false;\n    // Verificar repeti√ß√£o de caracteres\n    for (let i = 0; i < password.length - 2; i++) {\n      if (password[i] === password[i + 1] && password[i] === password[i + 2]) {\n        return true;\n      }\n    }\n    // Verificar padr√µes repetitivos\n    const patterns = ['aa', 'bb', 'cc', '11', '22', '33', '00'];\n    return patterns.some(pattern => password.toLowerCase().includes(pattern));\n  }\n  /**\n   * Gera um hash seguro da senha usando Web Crypto API\n   */\n  hashPassword(password) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const encoder = new TextEncoder();\n      const data = encoder.encode(password);\n      // Gerar salt √∫nico\n      const salt = _this.crypto.getRandomValues(new Uint8Array(16));\n      // Combinar senha + salt\n      const combined = new Uint8Array(data.length + salt.length);\n      combined.set(data);\n      combined.set(salt, data.length);\n      // Gerar hash SHA-256\n      const hashBuffer = yield _this.subtle.digest('SHA-256', combined);\n      // Converter para base64\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n      // Retornar hash + salt (separados por :)\n      const saltHex = Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('');\n      return `${hashHex}:${saltHex}`;\n    })();\n  }\n  /**\n   * Verifica se uma senha corresponde ao hash armazenado\n   */\n  verifyPassword(password, storedHash) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const [hashHex, saltHex] = storedHash.split(':');\n        if (!hashHex || !saltHex) return false;\n        const encoder = new TextEncoder();\n        const data = encoder.encode(password);\n        // Converter salt de volta para Uint8Array\n        const salt = new Uint8Array(saltHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n        // Combinar senha + salt\n        const combined = new Uint8Array(data.length + salt.length);\n        combined.set(data);\n        combined.set(salt, data.length);\n        // Gerar hash da senha fornecida\n        const hashBuffer = yield _this2.subtle.digest('SHA-256', combined);\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        const providedHashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n        return providedHashHex === hashHex;\n      } catch (error) {\n        console.error('Erro ao verificar senha:', error);\n        return false;\n      }\n    })();\n  }\n  /**\n   * Criptografa dados sens√≠veis usando AES-GCM\n   */\n  encryptData(data, key) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const secretKey = key || environment.security.encryptionKey || 'default-secret-key';\n        const encoder = new TextEncoder();\n        const dataBuffer = encoder.encode(data);\n        // Gerar chave de criptografia\n        const keyBuffer = encoder.encode(secretKey);\n        const cryptoKey = yield _this3.subtle.importKey('raw', keyBuffer, {\n          name: 'AES-GCM'\n        }, false, ['encrypt']);\n        // Gerar IV √∫nico\n        const iv = _this3.crypto.getRandomValues(new Uint8Array(12));\n        // Criptografar dados\n        const encryptedBuffer = yield _this3.subtle.encrypt({\n          name: 'AES-GCM',\n          iv\n        }, cryptoKey, dataBuffer);\n        // Converter para base64\n        const encryptedArray = Array.from(new Uint8Array(encryptedBuffer));\n        const encryptedHex = encryptedArray.map(b => b.toString(16).padStart(2, '0')).join('');\n        const ivHex = Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join('');\n        return `${encryptedHex}:${ivHex}`;\n      } catch (error) {\n        console.error('Erro ao criptografar dados:', error);\n        throw new Error('Falha na criptografia dos dados');\n      }\n    })();\n  }\n  /**\n   * Descriptografa dados usando AES-GCM\n   */\n  decryptData(encryptedData, key) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const secretKey = key || environment.security.encryptionKey || 'default-secret-key';\n        const [encryptedHex, ivHex] = encryptedData.split(':');\n        if (!encryptedHex || !ivHex) throw new Error('Formato de dados inv√°lido');\n        const encoder = new TextEncoder();\n        const decoder = new TextDecoder();\n        // Converter dados de volta para Uint8Array\n        const encryptedArray = new Uint8Array(encryptedHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n        const iv = new Uint8Array(ivHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n        // Gerar chave de descriptografia\n        const keyBuffer = encoder.encode(secretKey);\n        const cryptoKey = yield _this4.subtle.importKey('raw', keyBuffer, {\n          name: 'AES-GCM'\n        }, false, ['decrypt']);\n        // Descriptografar dados\n        const decryptedBuffer = yield _this4.subtle.decrypt({\n          name: 'AES-GCM',\n          iv\n        }, cryptoKey, encryptedArray);\n        return decoder.decode(decryptedBuffer);\n      } catch (error) {\n        console.error('Erro ao descriptografar dados:', error);\n        throw new Error('Falha na descriptografia dos dados');\n      }\n    })();\n  }\n  /**\n   * Gera um token CSRF seguro\n   */\n  generateCSRFToken() {\n    const array = new Uint8Array(32);\n    this.crypto.getRandomValues(array);\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n  /**\n   * Verifica se o ambiente √© seguro (HTTPS)\n   */\n  isSecureEnvironment() {\n    if (environment.production) {\n      return window.location.protocol === 'https:' || environment.httpsRequired === false;\n    }\n    return true; // Em desenvolvimento, permitir HTTP\n  }\n  /**\n   * For√ßa redirecionamento para HTTPS se necess√°rio\n   */\n  enforceHTTPS() {\n    if (environment.httpsRequired && window.location.protocol === 'http:' && !environment.production) {\n      const httpsUrl = window.location.href.replace('http:', 'https:');\n      console.warn('üîí Redirecionando para HTTPS:', httpsUrl);\n      // Em produ√ß√£o, redirecionar automaticamente\n      // window.location.href = httpsUrl;\n    }\n  }\n  /**\n   * Sanitiza dados de entrada para prevenir XSS\n   */\n  sanitizeInput(input) {\n    return input.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g, '&#x2F;');\n  }\n  /**\n   * Valida se um token JWT est√° expirado\n   */\n  isTokenExpired(token) {\n    try {\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      const currentTime = Date.now() / 1000;\n      return payload.exp < currentTime;\n    } catch (error) {\n      return true; // Se n√£o conseguir decodificar, considerar como expirado\n    }\n  }\n  static …µfac = function SecurityService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || SecurityService)();\n  };\n  static …µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: SecurityService,\n    factory: SecurityService.…µfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["environment","SecurityService","crypto","window","subtle","constructor","validatePassword","password","errors","minPasswordLength","requireSpecialChars","requireNumbers","requireUppercase","blockSequentialPasswords","blockRepetitivePasswords","security","length","push","test","isSequentialPassword","isRepetitivePassword","isValid","sequentialPatterns","some","pattern","toLowerCase","includes","i","patterns","hashPassword","_this","_asyncToGenerator","encoder","TextEncoder","data","encode","salt","getRandomValues","Uint8Array","combined","set","hashBuffer","digest","hashArray","Array","from","hashHex","map","b","toString","padStart","join","saltHex","verifyPassword","storedHash","_this2","split","match","byte","parseInt","providedHashHex","error","console","encryptData","key","_this3","secretKey","encryptionKey","dataBuffer","keyBuffer","cryptoKey","importKey","name","iv","encryptedBuffer","encrypt","encryptedArray","encryptedHex","ivHex","Error","decryptData","encryptedData","_this4","decoder","TextDecoder","decryptedBuffer","decrypt","decode","generateCSRFToken","array","isSecureEnvironment","production","location","protocol","httpsRequired","enforceHTTPS","httpsUrl","href","replace","warn","sanitizeInput","input","isTokenExpired","token","payload","JSON","parse","atob","currentTime","Date","now","exp","factory","…µfac","providedIn"],"sources":["/home/danilo/√Årea de trabalho/formsync-nx/apps/front/src/app/services/security.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { environment } from '../../environments/environment';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SecurityService {\n  private readonly crypto = window.crypto;\n  private readonly subtle = window.crypto.subtle;\n\n  constructor() { }\n\n  /**\n   * Valida se uma senha atende aos requisitos de seguran√ßa\n   */\n  validatePassword(password: string): { isValid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    const { minPasswordLength, requireSpecialChars, requireNumbers, requireUppercase, blockSequentialPasswords, blockRepetitivePasswords } = environment.security;\n\n    if (password.length < minPasswordLength) {\n      errors.push(`Senha deve ter pelo menos ${minPasswordLength} caracteres`);\n    }\n\n    if (requireUppercase && !/[A-Z]/.test(password)) {\n      errors.push('Senha deve conter pelo menos uma letra mai√∫scula');\n    }\n\n    if (requireNumbers && !/\\d/.test(password)) {\n      errors.push('Senha deve conter pelo menos um n√∫mero');\n    }\n\n    if (requireSpecialChars && !/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/.test(password)) {\n      errors.push('Senha deve conter pelo menos um caractere especial');\n    }\n\n    // Valida√ß√µes adicionais para senhas sequenciais e repetitivas\n    if (blockSequentialPasswords && this.isSequentialPassword(password)) {\n      errors.push('Senha sequencial n√£o permitida (ex: 123456, abcdef)');\n    }\n\n    if (blockRepetitivePasswords && this.isRepetitivePassword(password)) {\n      errors.push('Senha com padr√µes repetitivos n√£o permitida');\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n\n  /**\n   * Verifica se √© uma senha sequencial\n   */\n  private isSequentialPassword(password: string): boolean {\n    const sequentialPatterns = [\n      '123456', '12345', '1234', '123', '12',\n      '000000', '00000', '0000', '000', '00',\n      '111111', '11111', '1111', '111', '11',\n      'abcdef', 'abcde', 'abcd', 'abc', 'ab',\n      'qwerty', 'qwert', 'qwer', 'qwe', 'qw',\n      '987654', '98765', '9876', '987', '98',\n      '654321', '65432', '6543', '654', '65'\n    ];\n\n    return sequentialPatterns.some(pattern =>\n      password.toLowerCase().includes(pattern.toLowerCase())\n    );\n  }\n\n  /**\n   * Verifica se √© uma senha repetitiva\n   */\n  private isRepetitivePassword(password: string): boolean {\n    if (password.length < 3) return false;\n\n    // Verificar repeti√ß√£o de caracteres\n    for (let i = 0; i < password.length - 2; i++) {\n      if (password[i] === password[i + 1] && password[i] === password[i + 2]) {\n        return true;\n      }\n    }\n\n    // Verificar padr√µes repetitivos\n    const patterns = ['aa', 'bb', 'cc', '11', '22', '33', '00'];\n    return patterns.some(pattern => password.toLowerCase().includes(pattern));\n  }\n\n  /**\n   * Gera um hash seguro da senha usando Web Crypto API\n   */\n  async hashPassword(password: string): Promise<string> {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(password);\n\n    // Gerar salt √∫nico\n    const salt = this.crypto.getRandomValues(new Uint8Array(16));\n\n    // Combinar senha + salt\n    const combined = new Uint8Array(data.length + salt.length);\n    combined.set(data);\n    combined.set(salt, data.length);\n\n    // Gerar hash SHA-256\n    const hashBuffer = await this.subtle.digest('SHA-256', combined);\n\n    // Converter para base64\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n\n    // Retornar hash + salt (separados por :)\n    const saltHex = Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('');\n    return `${hashHex}:${saltHex}`;\n  }\n\n  /**\n   * Verifica se uma senha corresponde ao hash armazenado\n   */\n  async verifyPassword(password: string, storedHash: string): Promise<boolean> {\n    try {\n      const [hashHex, saltHex] = storedHash.split(':');\n      if (!hashHex || !saltHex) return false;\n\n      const encoder = new TextEncoder();\n      const data = encoder.encode(password);\n\n      // Converter salt de volta para Uint8Array\n      const salt = new Uint8Array(saltHex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));\n\n      // Combinar senha + salt\n      const combined = new Uint8Array(data.length + salt.length);\n      combined.set(data);\n      combined.set(salt, data.length);\n\n      // Gerar hash da senha fornecida\n      const hashBuffer = await this.subtle.digest('SHA-256', combined);\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      const providedHashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n\n      return providedHashHex === hashHex;\n    } catch (error) {\n      console.error('Erro ao verificar senha:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Criptografa dados sens√≠veis usando AES-GCM\n   */\n  async encryptData(data: string, key?: string): Promise<string> {\n    try {\n      const secretKey = key || environment.security.encryptionKey || 'default-secret-key';\n      const encoder = new TextEncoder();\n      const dataBuffer = encoder.encode(data);\n\n      // Gerar chave de criptografia\n      const keyBuffer = encoder.encode(secretKey);\n      const cryptoKey = await this.subtle.importKey(\n        'raw',\n        keyBuffer,\n        { name: 'AES-GCM' },\n        false,\n        ['encrypt']\n      );\n\n      // Gerar IV √∫nico\n      const iv = this.crypto.getRandomValues(new Uint8Array(12));\n\n      // Criptografar dados\n      const encryptedBuffer = await this.subtle.encrypt(\n        { name: 'AES-GCM', iv },\n        cryptoKey,\n        dataBuffer\n      );\n\n      // Converter para base64\n      const encryptedArray = Array.from(new Uint8Array(encryptedBuffer));\n      const encryptedHex = encryptedArray.map(b => b.toString(16).padStart(2, '0')).join('');\n      const ivHex = Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join('');\n\n      return `${encryptedHex}:${ivHex}`;\n    } catch (error) {\n      console.error('Erro ao criptografar dados:', error);\n      throw new Error('Falha na criptografia dos dados');\n    }\n  }\n\n  /**\n   * Descriptografa dados usando AES-GCM\n   */\n  async decryptData(encryptedData: string, key?: string): Promise<string> {\n    try {\n      const secretKey = key || environment.security.encryptionKey || 'default-secret-key';\n      const [encryptedHex, ivHex] = encryptedData.split(':');\n      if (!encryptedHex || !ivHex) throw new Error('Formato de dados inv√°lido');\n\n      const encoder = new TextEncoder();\n      const decoder = new TextDecoder();\n\n      // Converter dados de volta para Uint8Array\n      const encryptedArray = new Uint8Array(encryptedHex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));\n      const iv = new Uint8Array(ivHex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));\n\n      // Gerar chave de descriptografia\n      const keyBuffer = encoder.encode(secretKey);\n      const cryptoKey = await this.subtle.importKey(\n        'raw',\n        keyBuffer,\n        { name: 'AES-GCM' },\n        false,\n        ['decrypt']\n      );\n\n      // Descriptografar dados\n      const decryptedBuffer = await this.subtle.decrypt(\n        { name: 'AES-GCM', iv },\n        cryptoKey,\n        encryptedArray\n      );\n\n      return decoder.decode(decryptedBuffer);\n    } catch (error) {\n      console.error('Erro ao descriptografar dados:', error);\n      throw new Error('Falha na descriptografia dos dados');\n    }\n  }\n\n  /**\n   * Gera um token CSRF seguro\n   */\n  generateCSRFToken(): string {\n    const array = new Uint8Array(32);\n    this.crypto.getRandomValues(array);\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  /**\n   * Verifica se o ambiente √© seguro (HTTPS)\n   */\n  isSecureEnvironment(): boolean {\n    if (environment.production) {\n      return window.location.protocol === 'https:' || environment.httpsRequired === false;\n    }\n    return true; // Em desenvolvimento, permitir HTTP\n  }\n\n  /**\n   * For√ßa redirecionamento para HTTPS se necess√°rio\n   */\n  enforceHTTPS(): void {\n    if (environment.httpsRequired && window.location.protocol === 'http:' && !environment.production) {\n      const httpsUrl = window.location.href.replace('http:', 'https:');\n      console.warn('üîí Redirecionando para HTTPS:', httpsUrl);\n      // Em produ√ß√£o, redirecionar automaticamente\n      // window.location.href = httpsUrl;\n    }\n  }\n\n  /**\n   * Sanitiza dados de entrada para prevenir XSS\n   */\n  sanitizeInput(input: string): string {\n    return input\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#x27;')\n      .replace(/\\//g, '&#x2F;');\n  }\n\n  /**\n   * Valida se um token JWT est√° expirado\n   */\n  isTokenExpired(token: string): boolean {\n    try {\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      const currentTime = Date.now() / 1000;\n      return payload.exp < currentTime;\n    } catch (error) {\n      return true; // Se n√£o conseguir decodificar, considerar como expirado\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}