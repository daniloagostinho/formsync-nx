{"ast":null,"code":"import _asyncToGenerator from \"/home/danilo/\\xC1rea de trabalho/formsync-nx/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, inject, Injectable, ElementRef, Renderer2, makeEnvironmentProviders, input, output, signal, HostListener, Directive, Pipe } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';\nvar MaskExpression;\n(function (MaskExpression) {\n  MaskExpression[\"SEPARATOR\"] = \"separator\";\n  MaskExpression[\"PERCENT\"] = \"percent\";\n  MaskExpression[\"IP\"] = \"IP\";\n  MaskExpression[\"CPF_CNPJ\"] = \"CPF_CNPJ\";\n  MaskExpression[\"MONTH\"] = \"M\";\n  MaskExpression[\"MONTHS\"] = \"M0\";\n  MaskExpression[\"MINUTE\"] = \"m\";\n  MaskExpression[\"HOUR\"] = \"h\";\n  MaskExpression[\"HOURS\"] = \"H\";\n  MaskExpression[\"MINUTES\"] = \"m0\";\n  MaskExpression[\"HOURS_HOUR\"] = \"Hh\";\n  MaskExpression[\"SECONDS\"] = \"s0\";\n  MaskExpression[\"HOURS_MINUTES_SECONDS\"] = \"Hh:m0:s0\";\n  MaskExpression[\"EMAIL_MASK\"] = \"A*@A*.A*\";\n  MaskExpression[\"HOURS_MINUTES\"] = \"Hh:m0\";\n  MaskExpression[\"MINUTES_SECONDS\"] = \"m0:s0\";\n  MaskExpression[\"DAYS_MONTHS_YEARS\"] = \"d0/M0/0000\";\n  MaskExpression[\"DAYS_MONTHS\"] = \"d0/M0\";\n  MaskExpression[\"DAYS\"] = \"d0\";\n  MaskExpression[\"DAY\"] = \"d\";\n  MaskExpression[\"SECOND\"] = \"s\";\n  MaskExpression[\"LETTER_S\"] = \"S\";\n  MaskExpression[\"DOT\"] = \".\";\n  MaskExpression[\"COMMA\"] = \",\";\n  MaskExpression[\"CURLY_BRACKETS_LEFT\"] = \"{\";\n  MaskExpression[\"CURLY_BRACKETS_RIGHT\"] = \"}\";\n  MaskExpression[\"MINUS\"] = \"-\";\n  MaskExpression[\"OR\"] = \"||\";\n  MaskExpression[\"HASH\"] = \"#\";\n  MaskExpression[\"EMPTY_STRING\"] = \"\";\n  MaskExpression[\"SYMBOL_STAR\"] = \"*\";\n  MaskExpression[\"SYMBOL_QUESTION\"] = \"?\";\n  MaskExpression[\"SLASH\"] = \"/\";\n  MaskExpression[\"WHITE_SPACE\"] = \" \";\n  MaskExpression[\"NUMBER_ZERO\"] = \"0\";\n  MaskExpression[\"NUMBER_NINE\"] = \"9\";\n  MaskExpression[\"BACKSPACE\"] = \"Backspace\";\n  MaskExpression[\"DELETE\"] = \"Delete\";\n  MaskExpression[\"ARROW_LEFT\"] = \"ArrowLeft\";\n  MaskExpression[\"ARROW_UP\"] = \"ArrowUp\";\n  MaskExpression[\"DOUBLE_ZERO\"] = \"00\";\n})(MaskExpression || (MaskExpression = {}));\nconst NGX_MASK_CONFIG = new InjectionToken('ngx-mask config');\nconst NEW_CONFIG = new InjectionToken('new ngx-mask config');\nconst INITIAL_CONFIG = new InjectionToken('initial ngx-mask config');\nconst initialConfig = {\n  suffix: '',\n  prefix: '',\n  thousandSeparator: ' ',\n  decimalMarker: ['.', ','],\n  clearIfNotMatch: false,\n  showMaskTyped: false,\n  instantPrefix: false,\n  placeHolderCharacter: '_',\n  dropSpecialCharacters: true,\n  hiddenInput: false,\n  shownMaskExpression: '',\n  separatorLimit: '',\n  allowNegativeNumbers: false,\n  validation: true,\n  specialCharacters: ['-', '/', '(', ')', '.', ':', ' ', '+', ',', '@', '[', ']', '\"', \"'\"],\n  leadZeroDateTime: false,\n  apm: false,\n  leadZero: false,\n  keepCharacterPositions: false,\n  triggerOnMaskChange: false,\n  inputTransformFn: value => value,\n  outputTransformFn: value => value,\n  maskFilled: new EventEmitter(),\n  patterns: {\n    '0': {\n      pattern: new RegExp('\\\\d')\n    },\n    '9': {\n      pattern: new RegExp('\\\\d'),\n      optional: true\n    },\n    X: {\n      pattern: new RegExp('\\\\d'),\n      symbol: '*'\n    },\n    A: {\n      pattern: new RegExp('[a-zA-Z0-9]')\n    },\n    S: {\n      pattern: new RegExp('[a-zA-Z]')\n    },\n    U: {\n      pattern: new RegExp('[A-Z]')\n    },\n    L: {\n      pattern: new RegExp('[a-z]')\n    },\n    d: {\n      pattern: new RegExp('\\\\d')\n    },\n    m: {\n      pattern: new RegExp('\\\\d')\n    },\n    M: {\n      pattern: new RegExp('\\\\d')\n    },\n    H: {\n      pattern: new RegExp('\\\\d')\n    },\n    h: {\n      pattern: new RegExp('\\\\d')\n    },\n    s: {\n      pattern: new RegExp('\\\\d')\n    }\n  }\n};\nconst timeMasks = [MaskExpression.HOURS_MINUTES_SECONDS, MaskExpression.HOURS_MINUTES, MaskExpression.MINUTES_SECONDS];\nconst withoutValidation = [MaskExpression.PERCENT, MaskExpression.HOURS_HOUR, MaskExpression.SECONDS, MaskExpression.MINUTES, MaskExpression.SEPARATOR, MaskExpression.DAYS_MONTHS_YEARS, MaskExpression.DAYS_MONTHS, MaskExpression.DAYS, MaskExpression.MONTHS];\nclass NgxMaskApplierService {\n  _config = inject(NGX_MASK_CONFIG);\n  dropSpecialCharacters = this._config.dropSpecialCharacters;\n  hiddenInput = this._config.hiddenInput;\n  clearIfNotMatch = this._config.clearIfNotMatch;\n  specialCharacters = this._config.specialCharacters;\n  patterns = this._config.patterns;\n  prefix = this._config.prefix;\n  suffix = this._config.suffix;\n  thousandSeparator = this._config.thousandSeparator;\n  decimalMarker = this._config.decimalMarker;\n  customPattern;\n  showMaskTyped = this._config.showMaskTyped;\n  placeHolderCharacter = this._config.placeHolderCharacter;\n  validation = this._config.validation;\n  separatorLimit = this._config.separatorLimit;\n  allowNegativeNumbers = this._config.allowNegativeNumbers;\n  leadZeroDateTime = this._config.leadZeroDateTime;\n  leadZero = this._config.leadZero;\n  apm = this._config.apm;\n  inputTransformFn = this._config.inputTransformFn;\n  outputTransformFn = this._config.outputTransformFn;\n  keepCharacterPositions = this._config.keepCharacterPositions;\n  instantPrefix = this._config.instantPrefix;\n  triggerOnMaskChange = this._config.triggerOnMaskChange;\n  _shift = new Set();\n  plusOnePosition = false;\n  maskExpression = '';\n  actualValue = '';\n  showKeepCharacterExp = '';\n  shownMaskExpression = this._config.shownMaskExpression;\n  deletedSpecialCharacter = false;\n  ipError;\n  cpfCnpjError;\n  applyMask(inputValue, maskExpression, position = 0, justPasted = false, backspaced = false,\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  cb = () => {}) {\n    if (!maskExpression || typeof inputValue !== 'string') {\n      return MaskExpression.EMPTY_STRING;\n    }\n    let cursor = 0;\n    let result = '';\n    let multi = false;\n    let backspaceShift = false;\n    let shift = 1;\n    let stepBack = false;\n    let processedValue = inputValue;\n    let processedPosition = position;\n    const startsWithPrefix = processedValue.slice(0, this.prefix.length) === this.prefix;\n    const pastedFullWithPrefix = justPasted && processedValue.length === this.prefix.length + maskExpression.length;\n    const looksLikeFullPrefixPaste = processedValue === this.prefix + processedValue.slice(this.prefix.length);\n    if (startsWithPrefix && (pastedFullWithPrefix || looksLikeFullPrefixPaste)) {\n      processedValue = processedValue.slice(this.prefix.length);\n    }\n    if (!!this.suffix && processedValue.length > 0) {\n      processedValue = this.checkAndRemoveSuffix(processedValue);\n    }\n    if (processedValue === '(' && this.prefix) {\n      processedValue = '';\n    }\n    const inputArray = processedValue.toString().split(MaskExpression.EMPTY_STRING);\n    if (this.allowNegativeNumbers && processedValue.slice(cursor, cursor + 1) === MaskExpression.MINUS) {\n      result += processedValue.slice(cursor, cursor + 1);\n    }\n    if (maskExpression === MaskExpression.IP) {\n      const valuesIP = processedValue.split(MaskExpression.DOT);\n      this.ipError = this._validIP(valuesIP);\n      // eslint-disable-next-line no-param-reassign\n      maskExpression = '099.099.099.099';\n    }\n    const arr = [];\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < processedValue.length; i++) {\n      if (processedValue[i]?.match('\\\\d')) {\n        arr.push(processedValue[i] ?? MaskExpression.EMPTY_STRING);\n      }\n    }\n    if (maskExpression === MaskExpression.CPF_CNPJ) {\n      this.cpfCnpjError = arr.length !== 11 && arr.length !== 14;\n      if (arr.length > 11) {\n        // eslint-disable-next-line no-param-reassign\n        maskExpression = '00.000.000/0000-00';\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        maskExpression = '000.000.000-00';\n      }\n    }\n    if (maskExpression.startsWith(MaskExpression.PERCENT)) {\n      if (processedValue.match('[a-z]|[A-Z]') ||\n      // eslint-disable-next-line no-useless-escape\n      processedValue.match(/[-!$%^&*()_+|~=`{}\\[\\]:\";'<>?,\\/.]/) && !backspaced) {\n        processedValue = this._stripToDecimal(processedValue);\n        const precision = this.getPrecision(maskExpression);\n        processedValue = this.checkInputPrecision(processedValue, precision, this.decimalMarker);\n      }\n      const decimalMarker = typeof this.decimalMarker === 'string' ? this.decimalMarker : MaskExpression.DOT;\n      if (processedValue.indexOf(decimalMarker) > 0 && !this.percentage(processedValue.substring(0, processedValue.indexOf(decimalMarker)))) {\n        let base = processedValue.substring(0, processedValue.indexOf(decimalMarker) - 1);\n        if (this.allowNegativeNumbers && processedValue.slice(cursor, cursor + 1) === MaskExpression.MINUS && !backspaced) {\n          base = processedValue.substring(0, processedValue.indexOf(decimalMarker));\n        }\n        processedValue = `${base}${processedValue.substring(processedValue.indexOf(decimalMarker), processedValue.length)}`;\n      }\n      let value = '';\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      this.allowNegativeNumbers && processedValue.slice(cursor, cursor + 1) === MaskExpression.MINUS ? value = `${MaskExpression.MINUS}${processedValue.slice(cursor + 1, cursor + processedValue.length)}` : value = processedValue;\n      if (this.percentage(value)) {\n        result = this._splitPercentZero(processedValue);\n      } else {\n        result = this._splitPercentZero(processedValue.substring(0, processedValue.length - 1));\n      }\n    } else if (maskExpression.startsWith(MaskExpression.SEPARATOR)) {\n      if (processedValue.match('[wа-яА-Я]') || processedValue.match('[ЁёА-я]') || processedValue.match('[a-z]|[A-Z]') || processedValue.match(/[-@#!$%\\\\^&*()_£¬'+|~=`{}\\]:\";<>.?/]/) || processedValue.match('[^A-Za-z0-9,]')) {\n        processedValue = this._stripToDecimal(processedValue);\n      }\n      const precision = this.getPrecision(maskExpression);\n      let decimalMarker = this.decimalMarker;\n      if (Array.isArray(this.decimalMarker)) {\n        if (this.actualValue.includes(this.decimalMarker[0]) || this.actualValue.includes(this.decimalMarker[1])) {\n          decimalMarker = this.actualValue.includes(this.decimalMarker[0]) ? this.decimalMarker[0] : this.decimalMarker[1];\n        } else {\n          decimalMarker = this.decimalMarker.find(dm => dm !== this.thousandSeparator);\n        }\n      }\n      if (backspaced) {\n        const {\n          decimalMarkerIndex,\n          nonZeroIndex\n        } = this._findFirstNonZeroAndDecimalIndex(processedValue, decimalMarker);\n        const zeroIndexMinus = processedValue[0] === MaskExpression.MINUS;\n        const zeroIndexNumberZero = processedValue[0] === MaskExpression.NUMBER_ZERO;\n        const zeroIndexDecimalMarker = processedValue[0] === decimalMarker;\n        const firstIndexDecimalMarker = processedValue[1] === decimalMarker;\n        if (zeroIndexDecimalMarker && !nonZeroIndex || zeroIndexMinus && firstIndexDecimalMarker && !nonZeroIndex || zeroIndexNumberZero && !decimalMarkerIndex && !nonZeroIndex) {\n          processedValue = MaskExpression.NUMBER_ZERO;\n        }\n        if (decimalMarkerIndex && nonZeroIndex && zeroIndexMinus && processedPosition === 1) {\n          if (decimalMarkerIndex < nonZeroIndex || decimalMarkerIndex > nonZeroIndex) {\n            processedValue = MaskExpression.MINUS + processedValue.slice(nonZeroIndex);\n          }\n        }\n        if (!decimalMarkerIndex && nonZeroIndex && processedValue.length > nonZeroIndex) {\n          processedValue = zeroIndexMinus ? MaskExpression.MINUS + processedValue.slice(nonZeroIndex) : processedValue.slice(nonZeroIndex);\n        }\n        if (decimalMarkerIndex && nonZeroIndex && processedPosition === 0) {\n          if (decimalMarkerIndex < nonZeroIndex) {\n            processedValue = processedValue.slice(decimalMarkerIndex - 1);\n          }\n          if (decimalMarkerIndex > nonZeroIndex) {\n            processedValue = processedValue.slice(nonZeroIndex);\n          }\n        }\n      }\n      if (precision === 0) {\n        processedValue = this.allowNegativeNumbers ? processedValue.length > 2 && processedValue[0] === MaskExpression.MINUS && processedValue[1] === MaskExpression.NUMBER_ZERO && processedValue[2] !== this.thousandSeparator && processedValue[2] !== MaskExpression.COMMA && processedValue[2] !== MaskExpression.DOT ? '-' + processedValue.slice(2, processedValue.length) : processedValue[0] === MaskExpression.NUMBER_ZERO && processedValue.length > 1 && processedValue[1] !== this.thousandSeparator && processedValue[1] !== MaskExpression.COMMA && processedValue[1] !== MaskExpression.DOT ? processedValue.slice(1, processedValue.length) : processedValue : processedValue.length > 1 && processedValue[0] === MaskExpression.NUMBER_ZERO && processedValue[1] !== this.thousandSeparator && processedValue[1] !== MaskExpression.COMMA && processedValue[1] !== MaskExpression.DOT ? processedValue.slice(1, processedValue.length) : processedValue;\n      } else {\n        if (processedValue[0] === decimalMarker && processedValue.length > 1 && !backspaced) {\n          processedValue = MaskExpression.NUMBER_ZERO + processedValue.slice(0, processedValue.length + 1);\n          this.plusOnePosition = true;\n        }\n        if (processedValue[0] === MaskExpression.NUMBER_ZERO && processedValue[1] !== decimalMarker && processedValue[1] !== this.thousandSeparator && !backspaced) {\n          processedValue = processedValue.length > 1 ? processedValue.slice(0, 1) + decimalMarker + processedValue.slice(1, processedValue.length + 1) : processedValue;\n          this.plusOnePosition = true;\n        }\n        if (this.allowNegativeNumbers && !backspaced && processedValue[0] === MaskExpression.MINUS && (processedValue[1] === decimalMarker || processedValue[1] === MaskExpression.NUMBER_ZERO)) {\n          processedValue = processedValue[1] === decimalMarker && processedValue.length > 2 ? processedValue.slice(0, 1) + MaskExpression.NUMBER_ZERO + processedValue.slice(1, processedValue.length) : processedValue[1] === MaskExpression.NUMBER_ZERO && processedValue.length > 2 && processedValue[2] !== decimalMarker ? processedValue.slice(0, 2) + decimalMarker + processedValue.slice(2, processedValue.length) : processedValue;\n          this.plusOnePosition = true;\n        }\n      }\n      // TODO: we had different rexexps here for the different cases... but tests dont seam to bother - check this\n      //  separator: no COMMA, dot-sep: no SPACE, COMMA OK, comma-sep: no SPACE, COMMA OK\n      const thousandSeparatorCharEscaped = this._charToRegExpExpression(this.thousandSeparator);\n      let invalidChars = '@#!$%^&*()_+|~=`{}\\\\[\\\\]:\\\\s,\\\\.\";<>?\\\\/'.replace(thousandSeparatorCharEscaped, '');\n      //.replace(decimalMarkerEscaped, '');\n      if (Array.isArray(this.decimalMarker)) {\n        for (const marker of this.decimalMarker) {\n          invalidChars = invalidChars.replace(this._charToRegExpExpression(marker), MaskExpression.EMPTY_STRING);\n        }\n      } else {\n        invalidChars = invalidChars.replace(this._charToRegExpExpression(this.decimalMarker), '');\n      }\n      const invalidCharRegexp = new RegExp('[' + invalidChars + ']');\n      if (processedValue.match(invalidCharRegexp)) {\n        processedValue = processedValue.substring(0, processedValue.length - 1);\n      }\n      processedValue = this.checkInputPrecision(processedValue, precision, this.decimalMarker);\n      const strForSep = processedValue.replace(new RegExp(thousandSeparatorCharEscaped, 'g'), '');\n      result = this._formatWithSeparators(strForSep, this.thousandSeparator, this.decimalMarker, precision);\n      const commaShift = result.indexOf(MaskExpression.COMMA) - processedValue.indexOf(MaskExpression.COMMA);\n      const shiftStep = result.length - processedValue.length;\n      const backspacedDecimalMarkerWithSeparatorLimit = backspaced && result.length < inputValue.length - this.suffix.length && this.separatorLimit;\n      if ((result[processedPosition - 1] === this.thousandSeparator || result[processedPosition - this.prefix.length]) && this.prefix && backspaced) {\n        processedPosition = processedPosition - 1;\n      } else if (shiftStep > 0 && result[processedPosition] !== this.thousandSeparator || backspacedDecimalMarkerWithSeparatorLimit) {\n        backspaceShift = true;\n        let _shift = 0;\n        do {\n          this._shift.add(processedPosition + _shift);\n          _shift++;\n        } while (_shift < shiftStep);\n      } else if (result[processedPosition - 1] === this.thousandSeparator || shiftStep === -4 || shiftStep === -3 || result[processedPosition] === this.thousandSeparator) {\n        this._shift.clear();\n        this._shift.add(processedPosition - 1);\n      } else if (commaShift !== 0 && processedPosition > 0 && !(result.indexOf(MaskExpression.COMMA) >= processedPosition && processedPosition > 3) || !(result.indexOf(MaskExpression.DOT) >= processedPosition && processedPosition > 3) && shiftStep <= 0) {\n        this._shift.clear();\n        backspaceShift = true;\n        shift = shiftStep;\n        processedPosition += shiftStep;\n        this._shift.add(processedPosition);\n      } else {\n        this._shift.clear();\n      }\n    } else {\n      for (\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      let i = 0, inputSymbol = inputArray[0]; i < inputArray.length; i++, inputSymbol = inputArray[i] ?? MaskExpression.EMPTY_STRING) {\n        if (cursor === maskExpression.length) {\n          break;\n        }\n        const symbolStarInPattern = MaskExpression.SYMBOL_STAR in this.patterns;\n        if (this._checkSymbolMask(inputSymbol, maskExpression[cursor] ?? MaskExpression.EMPTY_STRING) && maskExpression[cursor + 1] === MaskExpression.SYMBOL_QUESTION) {\n          result += inputSymbol;\n          cursor += 2;\n        } else if (maskExpression[cursor + 1] === MaskExpression.SYMBOL_STAR && multi && this._checkSymbolMask(inputSymbol, maskExpression[cursor + 2] ?? MaskExpression.EMPTY_STRING)) {\n          result += inputSymbol;\n          cursor += 3;\n          multi = false;\n        } else if (this._checkSymbolMask(inputSymbol, maskExpression[cursor] ?? MaskExpression.EMPTY_STRING) && maskExpression[cursor + 1] === MaskExpression.SYMBOL_STAR && !symbolStarInPattern) {\n          result += inputSymbol;\n          multi = true;\n        } else if (maskExpression[cursor + 1] === MaskExpression.SYMBOL_QUESTION && this._checkSymbolMask(inputSymbol, maskExpression[cursor + 2] ?? MaskExpression.EMPTY_STRING)) {\n          result += inputSymbol;\n          cursor += 3;\n        } else if (this._checkSymbolMask(inputSymbol, maskExpression[cursor] ?? MaskExpression.EMPTY_STRING)) {\n          if (maskExpression[cursor] === MaskExpression.HOURS) {\n            if (this.apm ? Number(inputSymbol) > 9 : Number(inputSymbol) > 2) {\n              processedPosition = !this.leadZeroDateTime ? processedPosition + 1 : processedPosition;\n              cursor += 1;\n              this._shiftStep(cursor);\n              i--;\n              if (this.leadZeroDateTime) {\n                result += '0';\n              }\n              continue;\n            }\n          }\n          if (maskExpression[cursor] === MaskExpression.HOUR) {\n            if (this.apm ? result.length === 1 && Number(result) > 1 || result === '1' && Number(inputSymbol) > 2 || processedValue.slice(cursor - 1, cursor).length === 1 && Number(processedValue.slice(cursor - 1, cursor)) > 2 || processedValue.slice(cursor - 1, cursor) === '1' && Number(inputSymbol) > 2 : result === '2' && Number(inputSymbol) > 3 || (result.slice(cursor - 2, cursor) === '2' || result.slice(cursor - 3, cursor) === '2' || result.slice(cursor - 4, cursor) === '2' || result.slice(cursor - 1, cursor) === '2') && Number(inputSymbol) > 3 && cursor > 10) {\n              processedPosition = processedPosition + 1;\n              cursor += 1;\n              i--;\n              continue;\n            }\n          }\n          if (maskExpression[cursor] === MaskExpression.MINUTE || maskExpression[cursor] === MaskExpression.SECOND) {\n            if (Number(inputSymbol) > 5) {\n              processedPosition = !this.leadZeroDateTime ? processedPosition + 1 : processedPosition;\n              cursor += 1;\n              this._shiftStep(cursor);\n              i--;\n              if (this.leadZeroDateTime) {\n                result += '0';\n              }\n              continue;\n            }\n          }\n          const daysCount = 31;\n          const inputValueCursor = processedValue[cursor];\n          const inputValueCursorPlusOne = processedValue[cursor + 1];\n          const inputValueCursorPlusTwo = processedValue[cursor + 2];\n          const inputValueCursorMinusOne = processedValue[cursor - 1];\n          const inputValueCursorMinusTwo = processedValue[cursor - 2];\n          const inputValueSliceMinusThreeMinusOne = processedValue.slice(cursor - 3, cursor - 1);\n          const inputValueSliceMinusOnePlusOne = processedValue.slice(cursor - 1, cursor + 1);\n          const inputValueSliceCursorPlusTwo = processedValue.slice(cursor, cursor + 2);\n          const inputValueSliceMinusTwoCursor = processedValue.slice(cursor - 2, cursor);\n          if (maskExpression[cursor] === MaskExpression.DAY) {\n            const maskStartWithMonth = maskExpression.slice(0, 2) === MaskExpression.MONTHS;\n            const startWithMonthInput = maskExpression.slice(0, 2) === MaskExpression.MONTHS && this.specialCharacters.includes(inputValueCursorMinusTwo);\n            if (Number(inputSymbol) > 3 && this.leadZeroDateTime || !maskStartWithMonth && (Number(inputValueSliceCursorPlusTwo) > daysCount || Number(inputValueSliceMinusOnePlusOne) > daysCount || this.specialCharacters.includes(inputValueCursorPlusOne)) || (startWithMonthInput ? Number(inputValueSliceMinusOnePlusOne) > daysCount || !this.specialCharacters.includes(inputValueCursor) && this.specialCharacters.includes(inputValueCursorPlusTwo) || this.specialCharacters.includes(inputValueCursor) : Number(inputValueSliceCursorPlusTwo) > daysCount || this.specialCharacters.includes(inputValueCursorPlusOne) && !backspaced)) {\n              processedPosition = !this.leadZeroDateTime ? processedPosition + 1 : processedPosition;\n              cursor += 1;\n              this._shiftStep(cursor);\n              i--;\n              if (this.leadZeroDateTime) {\n                result += '0';\n              }\n              continue;\n            }\n          }\n          if (maskExpression[cursor] === MaskExpression.MONTH) {\n            const monthsCount = 12;\n            // mask without day\n            const withoutDays = cursor === 0 && (Number(inputSymbol) > 2 || Number(inputValueSliceCursorPlusTwo) > monthsCount || this.specialCharacters.includes(inputValueCursorPlusOne) && !backspaced);\n            // day<10 && month<12 for input\n            const specialChart = maskExpression.slice(cursor + 2, cursor + 3);\n            const day1monthInput = inputValueSliceMinusThreeMinusOne.includes(specialChart) && maskExpression.includes('d0') && (this.specialCharacters.includes(inputValueCursorMinusTwo) && Number(inputValueSliceMinusOnePlusOne) > monthsCount && !this.specialCharacters.includes(inputValueCursor) || this.specialCharacters.includes(inputValueCursor));\n            //  month<12 && day<10 for input\n            const day2monthInput = Number(inputValueSliceMinusThreeMinusOne) <= daysCount && !this.specialCharacters.includes(inputValueSliceMinusThreeMinusOne) && this.specialCharacters.includes(inputValueCursorMinusOne) && (Number(inputValueSliceCursorPlusTwo) > monthsCount || this.specialCharacters.includes(inputValueCursorPlusOne));\n            // cursor === 5 && without days\n            const day2monthInputDot = Number(inputValueSliceCursorPlusTwo) > monthsCount && cursor === 5 || this.specialCharacters.includes(inputValueCursorPlusOne) && cursor === 5;\n            // // day<10 && month<12 for paste whole data\n            const day1monthPaste = Number(inputValueSliceMinusThreeMinusOne) > daysCount && !this.specialCharacters.includes(inputValueSliceMinusThreeMinusOne) && !this.specialCharacters.includes(inputValueSliceMinusTwoCursor) && Number(inputValueSliceMinusTwoCursor) > monthsCount && maskExpression.includes('d0');\n            // 10<day<31 && month<12 for paste whole data\n            const day2monthPaste = Number(inputValueSliceMinusThreeMinusOne) <= daysCount && !this.specialCharacters.includes(inputValueSliceMinusThreeMinusOne) && !this.specialCharacters.includes(inputValueCursorMinusOne) && Number(inputValueSliceMinusOnePlusOne) > monthsCount;\n            if (Number(inputSymbol) > 1 && this.leadZeroDateTime || withoutDays || day1monthInput || day2monthPaste || day1monthPaste || day2monthInput || day2monthInputDot && !this.leadZeroDateTime) {\n              processedPosition = !this.leadZeroDateTime ? processedPosition + 1 : processedPosition;\n              cursor += 1;\n              this._shiftStep(cursor);\n              i--;\n              if (this.leadZeroDateTime) {\n                result += '0';\n              }\n              continue;\n            }\n          }\n          result += inputSymbol;\n          cursor++;\n        } else if (this.specialCharacters.includes(inputSymbol) && maskExpression[cursor] === inputSymbol) {\n          result += inputSymbol;\n          cursor++;\n        } else if (this.specialCharacters.indexOf(maskExpression[cursor] ?? MaskExpression.EMPTY_STRING) !== -1) {\n          result += maskExpression[cursor];\n          cursor++;\n          this._shiftStep(cursor);\n          i--;\n        } else if (maskExpression[cursor] === MaskExpression.NUMBER_NINE && this.showMaskTyped) {\n          this._shiftStep(cursor);\n        } else if (this.patterns[maskExpression[cursor] ?? MaskExpression.EMPTY_STRING] && this.patterns[maskExpression[cursor] ?? MaskExpression.EMPTY_STRING]?.optional) {\n          if (!!inputArray[cursor] && maskExpression !== '099.099.099.099' && maskExpression !== '000.000.000-00' && maskExpression !== '00.000.000/0000-00' && !maskExpression.match(/^9+\\.0+$/) && !this.patterns[maskExpression[cursor] ?? MaskExpression.EMPTY_STRING]?.optional) {\n            result += inputArray[cursor];\n          }\n          if (maskExpression.includes(MaskExpression.NUMBER_NINE + MaskExpression.SYMBOL_STAR) && maskExpression.includes(MaskExpression.NUMBER_ZERO + MaskExpression.SYMBOL_STAR)) {\n            cursor++;\n          }\n          cursor++;\n          i--;\n        } else if (this.maskExpression[cursor + 1] === MaskExpression.SYMBOL_STAR && this._findSpecialChar(this.maskExpression[cursor + 2] ?? MaskExpression.EMPTY_STRING) && this._findSpecialChar(inputSymbol) === this.maskExpression[cursor + 2] && multi) {\n          cursor += 3;\n          result += inputSymbol;\n        } else if (this.maskExpression[cursor + 1] === MaskExpression.SYMBOL_QUESTION && this._findSpecialChar(this.maskExpression[cursor + 2] ?? MaskExpression.EMPTY_STRING) && this._findSpecialChar(inputSymbol) === this.maskExpression[cursor + 2] && multi) {\n          cursor += 3;\n          result += inputSymbol;\n        } else if (this.showMaskTyped && this.specialCharacters.indexOf(inputSymbol) < 0 && inputSymbol !== this.placeHolderCharacter && this.placeHolderCharacter.length === 1) {\n          stepBack = true;\n        }\n      }\n    }\n    if (result[processedPosition - 1] && result.length + 1 === maskExpression.length && this.specialCharacters.indexOf(maskExpression[maskExpression.length - 1] ?? MaskExpression.EMPTY_STRING) !== -1) {\n      result += maskExpression[maskExpression.length - 1];\n    }\n    let newPosition = processedPosition + 1;\n    while (this._shift.has(newPosition)) {\n      shift++;\n      newPosition++;\n    }\n    let actualShift = justPasted && !maskExpression.startsWith(MaskExpression.SEPARATOR) ? cursor : this._shift.has(processedPosition) ? shift : 0;\n    if (stepBack) {\n      actualShift--;\n    }\n    cb(actualShift, backspaceShift);\n    if (shift < 0) {\n      this._shift.clear();\n    }\n    let onlySpecial = false;\n    if (backspaced) {\n      onlySpecial = inputArray.every(char => this.specialCharacters.includes(char));\n    }\n    let res = `${this.prefix}${onlySpecial ? MaskExpression.EMPTY_STRING : result}${this.showMaskTyped ? '' : this.suffix}`;\n    if (result.length === 0) {\n      res = this.instantPrefix ? `${this.prefix}${result}` : `${result}`;\n    }\n    const isSpecialCharacterMaskFirstSymbol = processedValue.length === 1 && this.specialCharacters.includes(maskExpression[0]) && processedValue !== maskExpression[0];\n    if (!this._checkSymbolMask(processedValue, maskExpression[1]) && isSpecialCharacterMaskFirstSymbol) {\n      return '';\n    }\n    if (result.includes(MaskExpression.MINUS) && this.prefix && this.allowNegativeNumbers) {\n      if (backspaced && result === MaskExpression.MINUS) {\n        return '';\n      }\n      res = `${MaskExpression.MINUS}${this.prefix}${result.split(MaskExpression.MINUS).join(MaskExpression.EMPTY_STRING)}${this.suffix}`;\n    }\n    return res;\n  }\n  _findDropSpecialChar(inputSymbol) {\n    if (Array.isArray(this.dropSpecialCharacters)) {\n      return this.dropSpecialCharacters.find(val => val === inputSymbol);\n    }\n    return this._findSpecialChar(inputSymbol);\n  }\n  _findSpecialChar(inputSymbol) {\n    return this.specialCharacters.find(val => val === inputSymbol);\n  }\n  _checkSymbolMask(inputSymbol, maskSymbol) {\n    this.patterns = this.customPattern ? this.customPattern : this.patterns;\n    return (this.patterns[maskSymbol]?.pattern && this.patterns[maskSymbol]?.pattern.test(inputSymbol)) ?? false;\n  }\n  _formatWithSeparators = (str, thousandSeparatorChar, decimalChars, precision) => {\n    let x = [];\n    let decimalChar = '';\n    if (Array.isArray(decimalChars)) {\n      const regExp = new RegExp(decimalChars.map(v => '[\\\\^$.|?*+()'.indexOf(v) >= 0 ? `\\\\${v}` : v).join('|'));\n      x = str.split(regExp);\n      decimalChar = str.match(regExp)?.[0] ?? MaskExpression.EMPTY_STRING;\n    } else {\n      x = str.split(decimalChars);\n      decimalChar = decimalChars;\n    }\n    const decimals = x.length > 1 ? `${decimalChar}${x[1]}` : MaskExpression.EMPTY_STRING;\n    let res = x[0] ?? MaskExpression.EMPTY_STRING;\n    const separatorLimit = this.separatorLimit.replace(/\\s/g, MaskExpression.EMPTY_STRING);\n    if (separatorLimit && +separatorLimit) {\n      if (res[0] === MaskExpression.MINUS) {\n        res = `-${res.slice(1, res.length).slice(0, separatorLimit.length)}`;\n      } else {\n        res = res.slice(0, separatorLimit.length);\n      }\n    }\n    const rgx = /(\\d+)(\\d{3})/;\n    while (thousandSeparatorChar && rgx.test(res)) {\n      res = res.replace(rgx, '$1' + thousandSeparatorChar + '$2');\n    }\n    if (typeof precision === 'undefined') {\n      return res + decimals;\n    } else if (precision === 0) {\n      return res;\n    }\n    return res + decimals.substring(0, precision + 1);\n  };\n  percentage = str => {\n    const sanitizedStr = str.replace(',', '.');\n    const value = Number(this.allowNegativeNumbers && str.includes(MaskExpression.MINUS) ? sanitizedStr.slice(1, str.length) : sanitizedStr);\n    return !isNaN(value) && value >= 0 && value <= 100;\n  };\n  getPrecision = maskExpression => {\n    const x = maskExpression.split(MaskExpression.DOT);\n    if (x.length > 1) {\n      return Number(x[x.length - 1]);\n    }\n    return Infinity;\n  };\n  checkAndRemoveSuffix = inputValue => {\n    for (let i = this.suffix?.length - 1; i >= 0; i--) {\n      const substr = this.suffix.substring(i, this.suffix?.length);\n      if (inputValue.includes(substr) && i !== this.suffix?.length - 1 && (i - 1 < 0 || !inputValue.includes(this.suffix.substring(i - 1, this.suffix?.length)))) {\n        return inputValue.replace(substr, MaskExpression.EMPTY_STRING);\n      }\n    }\n    return inputValue;\n  };\n  checkInputPrecision = (inputValue, precision, decimalMarker) => {\n    let processedInputValue = inputValue;\n    let processedDecimalMarker = decimalMarker;\n    if (precision < Infinity) {\n      // TODO need think about decimalMarker\n      if (Array.isArray(processedDecimalMarker)) {\n        const marker = processedDecimalMarker.find(dm => dm !== this.thousandSeparator);\n        processedDecimalMarker = marker ? marker : processedDecimalMarker[0];\n      }\n      const precisionRegEx = new RegExp(this._charToRegExpExpression(processedDecimalMarker) + `\\\\d{${precision}}.*$`);\n      const precisionMatch = processedInputValue.match(precisionRegEx);\n      const precisionMatchLength = (precisionMatch && precisionMatch[0]?.length) ?? 0;\n      if (precisionMatchLength - 1 > precision) {\n        const diff = precisionMatchLength - 1 - precision;\n        processedInputValue = processedInputValue.substring(0, processedInputValue.length - diff);\n      }\n      if (precision === 0 && this._compareOrIncludes(processedInputValue[processedInputValue.length - 1], processedDecimalMarker, this.thousandSeparator)) {\n        processedInputValue = processedInputValue.substring(0, processedInputValue.length - 1);\n      }\n    }\n    return processedInputValue;\n  };\n  _stripToDecimal(str) {\n    return str.split(MaskExpression.EMPTY_STRING).filter((i, idx) => {\n      const isDecimalMarker = typeof this.decimalMarker === 'string' ? i === this.decimalMarker :\n      // TODO (inepipenko) use utility type\n      this.decimalMarker.includes(i);\n      return i.match('^-?\\\\d') || i === this.thousandSeparator || isDecimalMarker || i === MaskExpression.MINUS && idx === 0 && this.allowNegativeNumbers;\n    }).join(MaskExpression.EMPTY_STRING);\n  }\n  _charToRegExpExpression(char) {\n    // if (Array.isArray(char)) {\n    // \treturn char.map((v) => ('[\\\\^$.|?*+()'.indexOf(v) >= 0 ? `\\\\${v}` : v)).join('|');\n    // }\n    if (char) {\n      const charsToEscape = '[\\\\^$.|?*+()';\n      return char === ' ' ? '\\\\s' : charsToEscape.indexOf(char) >= 0 ? `\\\\${char}` : char;\n    }\n    return char;\n  }\n  _shiftStep(cursor) {\n    this._shift.add(cursor + this.prefix.length || 0);\n  }\n  _compareOrIncludes(value, comparedValue, excludedValue) {\n    return Array.isArray(comparedValue) ? comparedValue.filter(v => v !== excludedValue).includes(value) : value === comparedValue;\n  }\n  _validIP(valuesIP) {\n    return !(valuesIP.length === 4 && !valuesIP.some((value, index) => {\n      if (valuesIP.length !== index + 1) {\n        return value === MaskExpression.EMPTY_STRING || Number(value) > 255;\n      }\n      return value === MaskExpression.EMPTY_STRING || Number(value.substring(0, 3)) > 255;\n    }));\n  }\n  _splitPercentZero(value) {\n    if (value === MaskExpression.MINUS && this.allowNegativeNumbers) {\n      return value;\n    }\n    const decimalIndex = typeof this.decimalMarker === 'string' ? value.indexOf(this.decimalMarker) : value.indexOf(MaskExpression.DOT);\n    const emptyOrMinus = this.allowNegativeNumbers && value.includes(MaskExpression.MINUS) ? '-' : '';\n    if (decimalIndex === -1) {\n      const parsedValue = parseInt(emptyOrMinus ? value.slice(1, value.length) : value, 10);\n      return isNaN(parsedValue) ? MaskExpression.EMPTY_STRING : `${emptyOrMinus}${parsedValue}`;\n    } else {\n      const integerPart = parseInt(value.replace('-', '').substring(0, decimalIndex), 10);\n      const decimalPart = value.substring(decimalIndex + 1);\n      const integerString = isNaN(integerPart) ? '' : integerPart.toString();\n      const decimal = typeof this.decimalMarker === 'string' ? this.decimalMarker : MaskExpression.DOT;\n      return integerString === MaskExpression.EMPTY_STRING ? MaskExpression.EMPTY_STRING : `${emptyOrMinus}${integerString}${decimal}${decimalPart}`;\n    }\n  }\n  _findFirstNonZeroAndDecimalIndex(inputString, decimalMarker) {\n    let decimalMarkerIndex = null;\n    let nonZeroIndex = null;\n    for (let i = 0; i < inputString.length; i++) {\n      const char = inputString[i];\n      if (char === decimalMarker && decimalMarkerIndex === null) {\n        decimalMarkerIndex = i;\n      }\n      if (char && char >= '1' && char <= '9' && nonZeroIndex === null) {\n        nonZeroIndex = i;\n      }\n      if (decimalMarkerIndex !== null && nonZeroIndex !== null) {\n        break;\n      }\n    }\n    return {\n      decimalMarkerIndex,\n      nonZeroIndex\n    };\n  }\n  static ɵfac = function NgxMaskApplierService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxMaskApplierService)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxMaskApplierService,\n    factory: NgxMaskApplierService.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxMaskApplierService, [{\n    type: Injectable\n  }], null, null);\n})();\nclass NgxMaskService extends NgxMaskApplierService {\n  isNumberValue = false;\n  maskIsShown = '';\n  selStart = null;\n  selEnd = null;\n  maskChanged = false;\n  maskExpressionArray = [];\n  previousValue = '';\n  currentValue = '';\n  /**\n   * Whether we are currently in writeValue function, in this case when applying the mask we don't want to trigger onChange function,\n   * since writeValue should be a one way only process of writing the DOM value based on the Angular model value.\n   */\n  writingValue = false;\n  isInitialized = false;\n  _emitValue = false;\n  _start;\n  _end;\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  onChange = _ => {};\n  _elementRef = inject(ElementRef, {\n    optional: true\n  });\n  document = inject(DOCUMENT);\n  _config = inject(NGX_MASK_CONFIG);\n  _renderer = inject(Renderer2, {\n    optional: true\n  });\n  /**\n   * Applies the mask to the input value.\n   * @param inputValue The input value to be masked.\n   * @param maskExpression The mask expression to apply.\n   * @param position The position in the input value.\n   * @param justPasted Whether the value was just pasted.\n   * @param backspaced Whether the value was backspaced.\n   * @param cb Callback function.\n   * @returns The masked value.\n   */\n  applyMask(inputValue, maskExpression, position = 0, justPasted = false, backspaced = false,\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  cb = () => {}) {\n    // If no mask expression, return the input value or the actual value\n    if (!maskExpression) {\n      return inputValue !== this.actualValue ? this.actualValue : inputValue;\n    }\n    // Show mask in input if required\n    this.maskIsShown = this.showMaskTyped ? this.showMaskInInput() : MaskExpression.EMPTY_STRING;\n    // Handle specific mask expressions\n    if (this.maskExpression === MaskExpression.IP && this.showMaskTyped) {\n      this.maskIsShown = this.showMaskInInput(inputValue || MaskExpression.HASH);\n    }\n    if (this.maskExpression === MaskExpression.CPF_CNPJ && this.showMaskTyped) {\n      this.maskIsShown = this.showMaskInInput(inputValue || MaskExpression.HASH);\n    }\n    // Handle empty input value with mask typed\n    if (!inputValue && this.showMaskTyped) {\n      this.formControlResult(this.prefix);\n      return `${this.prefix}${this.maskIsShown}${this.suffix}`;\n    }\n    const getSymbol = !!inputValue && typeof this.selStart === 'number' ? inputValue[this.selStart] ?? MaskExpression.EMPTY_STRING : MaskExpression.EMPTY_STRING;\n    let newInputValue = '';\n    let newPosition = position;\n    // Handle hidden input or input with asterisk symbol\n    if ((this.hiddenInput || inputValue && inputValue.indexOf(MaskExpression.SYMBOL_STAR) >= 0) && !this.writingValue) {\n      let actualResult = inputValue && inputValue.length === 1 ? inputValue.split(MaskExpression.EMPTY_STRING) : this.actualValue.split(MaskExpression.EMPTY_STRING);\n      // Handle backspace\n      if (backspaced) {\n        actualResult = actualResult.slice(0, position).concat(actualResult.slice(position + 1));\n      }\n      // Remove mask if showMaskTyped is true\n      if (this.showMaskTyped) {\n        // eslint-disable-next-line no-param-reassign\n        inputValue = this.removeMask(inputValue);\n        actualResult = this.removeMask(actualResult.join('')).split(MaskExpression.EMPTY_STRING);\n      }\n      // Handle selection start and end\n      if (typeof this.selStart === 'object' && typeof this.selEnd === 'object') {\n        this.selStart = Number(this.selStart);\n        this.selEnd = Number(this.selEnd);\n      } else {\n        if (inputValue !== MaskExpression.EMPTY_STRING && actualResult.length) {\n          if (typeof this.selStart === 'number' && typeof this.selEnd === 'number') {\n            if (inputValue.length > actualResult.length) {\n              actualResult.splice(this.selStart, 0, getSymbol);\n            } else if (inputValue.length < actualResult.length) {\n              if (actualResult.length - inputValue.length === 1) {\n                if (backspaced) {\n                  actualResult.splice(this.selStart - 1, 1);\n                } else {\n                  actualResult.splice(inputValue.length - 1, 1);\n                }\n              } else {\n                actualResult.splice(this.selStart, this.selEnd - this.selStart);\n              }\n            }\n          }\n        } else {\n          actualResult = [];\n        }\n      }\n      // Remove mask if showMaskTyped is true and hiddenInput is false\n      if (this.showMaskTyped && !this.hiddenInput) {\n        newInputValue = this.removeMask(inputValue);\n      }\n      // Handle actual value length\n      if (this.actualValue.length) {\n        if (actualResult.length < inputValue.length) {\n          newInputValue = this.shiftTypedSymbols(actualResult.join(MaskExpression.EMPTY_STRING));\n        } else if (actualResult.length === inputValue.length) {\n          newInputValue = actualResult.join(MaskExpression.EMPTY_STRING);\n        } else {\n          newInputValue = inputValue;\n        }\n      } else {\n        newInputValue = inputValue;\n      }\n    }\n    // Handle just pasted input\n    if (justPasted && (this.hiddenInput || !this.hiddenInput)) {\n      newInputValue = inputValue;\n    }\n    // Handle backspace with special characters\n    if (backspaced && this.specialCharacters.indexOf(this.maskExpression[newPosition] ?? MaskExpression.EMPTY_STRING) !== -1 && this.showMaskTyped && !this.prefix) {\n      newInputValue = this.currentValue;\n    }\n    // Handle deleted special character\n    if (this.deletedSpecialCharacter && newPosition) {\n      if (this.specialCharacters.includes(this.actualValue.slice(newPosition, newPosition + 1))) {\n        newPosition = newPosition + 1;\n      } else if (maskExpression.slice(newPosition - 1, newPosition + 1) !== MaskExpression.MONTHS) {\n        newPosition = newPosition - 2;\n      }\n      this.deletedSpecialCharacter = false;\n    }\n    // Remove mask if showMaskTyped is true and placeHolderCharacter length is 1\n    if (this.showMaskTyped && this.placeHolderCharacter.length === 1 && !this.leadZeroDateTime) {\n      newInputValue = this.removeMask(newInputValue);\n    }\n    // Handle mask changed\n    if (this.maskChanged) {\n      newInputValue = inputValue;\n    } else {\n      newInputValue = Boolean(newInputValue) && newInputValue.length ? newInputValue : inputValue;\n    }\n    // Handle showMaskTyped and keepCharacterPositions\n    if (this.showMaskTyped && this.keepCharacterPositions && this.actualValue && !justPasted && !this.writingValue) {\n      const value = this.dropSpecialCharacters ? this.removeMask(this.actualValue) : this.actualValue;\n      this.formControlResult(value);\n      return this.actualValue ? this.actualValue : `${this.prefix}${this.maskIsShown}${this.suffix}`;\n    }\n    // Apply the mask using the parent class method\n    const result = super.applyMask(newInputValue, maskExpression, newPosition, justPasted, backspaced, cb);\n    this.actualValue = this.getActualValue(result);\n    // handle some separator implications:\n    // a.) adjust decimalMarker default (. -> ,) if thousandSeparator is a dot\n    if (this.thousandSeparator === MaskExpression.DOT && this.decimalMarker === MaskExpression.DOT) {\n      this.decimalMarker = MaskExpression.COMMA;\n    }\n    // b) remove decimal marker from list of special characters to mask\n    if (this.maskExpression.startsWith(MaskExpression.SEPARATOR) && this.dropSpecialCharacters === true) {\n      this.specialCharacters = this.specialCharacters.filter(item => !this._compareOrIncludes(item, this.decimalMarker, this.thousandSeparator) //item !== this.decimalMarker, // !\n      );\n    }\n    // Update previous and current values\n    if (result || result === '') {\n      this.previousValue = this.currentValue;\n      this.currentValue = result;\n      this._emitValue = this.previousValue !== this.currentValue || this.previousValue === this.currentValue && justPasted;\n    }\n    // Propagate the input value back to the Angular model\n    // eslint-disable-next-line no-unused-expressions,@typescript-eslint/no-unused-expressions\n    this._emitValue ? this.formControlResult(result) : '';\n    // Handle hidden input and showMaskTyped\n    if (!this.showMaskTyped || this.showMaskTyped && this.hiddenInput) {\n      if (this.hiddenInput) {\n        return `${this.hideInput(result, this.maskExpression)}${this.maskIsShown.slice(result.length)}`;\n      }\n      return result;\n    }\n    const resLen = result.length;\n    const prefNmask = `${this.prefix}${this.maskIsShown}${this.suffix}`;\n    // Handle specific mask expressions\n    if (this.maskExpression.includes(MaskExpression.HOURS)) {\n      const countSkipedSymbol = this._numberSkipedSymbols(result);\n      return `${result}${prefNmask.slice(resLen + countSkipedSymbol)}`;\n    } else if (this.maskExpression === MaskExpression.IP || this.maskExpression === MaskExpression.CPF_CNPJ) {\n      return `${result}${prefNmask}`;\n    }\n    return `${result}${prefNmask.slice(resLen)}`;\n  }\n  // get the number of characters that were shifted\n  _numberSkipedSymbols(value) {\n    const regex = /(^|\\D)(\\d\\D)/g;\n    let match = regex.exec(value);\n    let countSkipedSymbol = 0;\n    while (match != null) {\n      countSkipedSymbol += 1;\n      match = regex.exec(value);\n    }\n    return countSkipedSymbol;\n  }\n  applyValueChanges(position, justPasted, backspaced,\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  cb = () => {}) {\n    const formElement = this._elementRef?.nativeElement;\n    if (!formElement) {\n      return;\n    }\n    formElement.value = this.applyMask(formElement.value, this.maskExpression, position, justPasted, backspaced, cb);\n    if (formElement === this._getActiveElement()) {\n      return;\n    }\n    this.clearIfNotMatchFn();\n  }\n  hideInput(inputValue, maskExpression) {\n    return inputValue.split(MaskExpression.EMPTY_STRING).map((curr, index) => {\n      if (this.patterns && this.patterns[maskExpression[index] ?? MaskExpression.EMPTY_STRING] && this.patterns[maskExpression[index] ?? MaskExpression.EMPTY_STRING]?.symbol) {\n        return this.patterns[maskExpression[index] ?? MaskExpression.EMPTY_STRING]?.symbol;\n      }\n      return curr;\n    }).join(MaskExpression.EMPTY_STRING);\n  }\n  // this function is not necessary, it checks result against maskExpression\n  getActualValue(res) {\n    const compare = res.split(MaskExpression.EMPTY_STRING).filter((symbol, i) => {\n      const maskChar = this.maskExpression[i] ?? MaskExpression.EMPTY_STRING;\n      return this._checkSymbolMask(symbol, maskChar) || this.specialCharacters.includes(maskChar) && symbol === maskChar;\n    });\n    if (compare.join(MaskExpression.EMPTY_STRING) === res) {\n      return compare.join(MaskExpression.EMPTY_STRING);\n    }\n    return res;\n  }\n  shiftTypedSymbols(inputValue) {\n    let symbolToReplace = '';\n    const newInputValue = inputValue && inputValue.split(MaskExpression.EMPTY_STRING).map((currSymbol, index) => {\n      if (this.specialCharacters.includes(inputValue[index + 1] ?? MaskExpression.EMPTY_STRING) && inputValue[index + 1] !== this.maskExpression[index + 1]) {\n        symbolToReplace = currSymbol;\n        return inputValue[index + 1];\n      }\n      if (symbolToReplace.length) {\n        const replaceSymbol = symbolToReplace;\n        symbolToReplace = MaskExpression.EMPTY_STRING;\n        return replaceSymbol;\n      }\n      return currSymbol;\n    }) || [];\n    return newInputValue.join(MaskExpression.EMPTY_STRING);\n  }\n  /**\n   * Convert number value to string\n   * 3.1415 -> '3.1415'\n   * 1e-7 -> '0.0000001'\n   */\n  numberToString(value) {\n    if (!value && value !== 0 || this.maskExpression.startsWith(MaskExpression.SEPARATOR) && (this.leadZero || !this.dropSpecialCharacters) || this.maskExpression.startsWith(MaskExpression.SEPARATOR) && this.separatorLimit.length > 14 && String(value).length > 14) {\n      return String(value);\n    }\n    return Number(value).toLocaleString('fullwide', {\n      useGrouping: false,\n      maximumFractionDigits: 20\n    }).replace(`/${MaskExpression.MINUS}/`, MaskExpression.MINUS);\n  }\n  showMaskInInput(inputVal) {\n    if (this.showMaskTyped && !!this.shownMaskExpression) {\n      if (this.maskExpression.length !== this.shownMaskExpression.length) {\n        throw new Error('Mask expression must match mask placeholder length');\n      } else {\n        return this.shownMaskExpression;\n      }\n    } else if (this.showMaskTyped) {\n      if (inputVal) {\n        if (this.maskExpression === MaskExpression.IP) {\n          return this._checkForIp(inputVal);\n        }\n        if (this.maskExpression === MaskExpression.CPF_CNPJ) {\n          return this._checkForCpfCnpj(inputVal);\n        }\n      }\n      if (this.placeHolderCharacter.length === this.maskExpression.length) {\n        return this.placeHolderCharacter;\n      }\n      return this.maskExpression.replace(/\\w/g, this.placeHolderCharacter);\n    }\n    return '';\n  }\n  clearIfNotMatchFn() {\n    const formElement = this._elementRef?.nativeElement;\n    if (!formElement) {\n      return;\n    }\n    if (this.clearIfNotMatch && this.prefix.length + this.maskExpression.length + this.suffix.length !== formElement.value.replace(this.placeHolderCharacter, MaskExpression.EMPTY_STRING).length) {\n      this.formElementProperty = ['value', MaskExpression.EMPTY_STRING];\n      this.applyMask('', this.maskExpression);\n    }\n  }\n  set formElementProperty([name, value]) {\n    if (!this._renderer || !this._elementRef) {\n      return;\n    }\n    //[TODO]: andriikamaldinov1 find better solution\n    Promise.resolve().then(() => this._renderer?.setProperty(this._elementRef?.nativeElement, name, value));\n  }\n  checkDropSpecialCharAmount(mask) {\n    const chars = mask.split(MaskExpression.EMPTY_STRING).filter(item => this._findDropSpecialChar(item));\n    return chars.length;\n  }\n  removeMask(inputValue) {\n    return this._removeMask(this._removeSuffix(this._removePrefix(inputValue)), this.specialCharacters.concat('_').concat(this.placeHolderCharacter));\n  }\n  _checkForIp(inputVal) {\n    if (inputVal === MaskExpression.HASH) {\n      return `${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n    }\n    const arr = [];\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < inputVal.length; i++) {\n      const value = inputVal[i] ?? MaskExpression.EMPTY_STRING;\n      if (!value) {\n        continue;\n      }\n      if (value.match('\\\\d')) {\n        arr.push(value);\n      }\n    }\n    if (arr.length <= 3) {\n      return `${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n    }\n    if (arr.length > 3 && arr.length <= 6) {\n      return `${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n    }\n    if (arr.length > 6 && arr.length <= 9) {\n      return this.placeHolderCharacter;\n    }\n    if (arr.length > 9 && arr.length <= 12) {\n      return '';\n    }\n    return '';\n  }\n  _checkForCpfCnpj(inputVal) {\n    const cpf = `${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `-${this.placeHolderCharacter}${this.placeHolderCharacter}`;\n    const cnpj = `${this.placeHolderCharacter}${this.placeHolderCharacter}` + `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `/${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `-${this.placeHolderCharacter}${this.placeHolderCharacter}`;\n    if (inputVal === MaskExpression.HASH) {\n      return cpf;\n    }\n    const arr = [];\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < inputVal.length; i++) {\n      const value = inputVal[i] ?? MaskExpression.EMPTY_STRING;\n      if (!value) {\n        continue;\n      }\n      if (value.match('\\\\d')) {\n        arr.push(value);\n      }\n    }\n    if (arr.length <= 3) {\n      return cpf.slice(arr.length, cpf.length);\n    }\n    if (arr.length > 3 && arr.length <= 6) {\n      return cpf.slice(arr.length + 1, cpf.length);\n    }\n    if (arr.length > 6 && arr.length <= 9) {\n      return cpf.slice(arr.length + 2, cpf.length);\n    }\n    if (arr.length > 9 && arr.length < 11) {\n      return cpf.slice(arr.length + 3, cpf.length);\n    }\n    if (arr.length === 11) {\n      return '';\n    }\n    if (arr.length === 12) {\n      if (inputVal.length === 17) {\n        return cnpj.slice(16, cnpj.length);\n      }\n      return cnpj.slice(15, cnpj.length);\n    }\n    if (arr.length > 12 && arr.length <= 14) {\n      return cnpj.slice(arr.length + 4, cnpj.length);\n    }\n    return '';\n  }\n  /**\n   * Recursively determine the current active element by navigating the Shadow DOM until the Active Element is found.\n   */\n  _getActiveElement(document = this.document) {\n    const shadowRootEl = document?.activeElement?.shadowRoot;\n    if (!shadowRootEl?.activeElement) {\n      return document.activeElement;\n    } else {\n      return this._getActiveElement(shadowRootEl);\n    }\n  }\n  /**\n   * Propogates the input value back to the Angular model by triggering the onChange function. It won't do this if writingValue\n   * is true. If that is true it means we are currently in the writeValue function, which is supposed to only update the actual\n   * DOM element based on the Angular model value. It should be a one way process, i.e. writeValue should not be modifying the Angular\n   * model value too. Therefore, we don't trigger onChange in this scenario.\n   * @param inputValue the current form input value\n   */\n  formControlResult(inputValue) {\n    const outputTransformFn = this.outputTransformFn ? this.outputTransformFn : v => v;\n    this.writingValue = false;\n    this.maskChanged = false;\n    if (!this.isInitialized && this._emitValue) {\n      return;\n    }\n    if (Array.isArray(this.dropSpecialCharacters)) {\n      this.onChange(outputTransformFn(this._toNumber(this._checkSymbols(this._removeMask(this._removeSuffix(this._removePrefix(inputValue)), this.dropSpecialCharacters)))));\n    } else if (this.dropSpecialCharacters || !this.dropSpecialCharacters && this.prefix === inputValue) {\n      this.onChange(outputTransformFn(this._toNumber(this._checkSymbols(this._removeSuffix(this._removePrefix(inputValue))))));\n    } else {\n      this.onChange(outputTransformFn(this._toNumber(inputValue)));\n    }\n  }\n  _toNumber(value) {\n    if (!this.isNumberValue || value === MaskExpression.EMPTY_STRING) {\n      return value;\n    }\n    if (this.maskExpression.startsWith(MaskExpression.SEPARATOR) && (this.leadZero || !this.dropSpecialCharacters)) {\n      return value;\n    }\n    if (String(value).length > 14 && this.maskExpression.startsWith(MaskExpression.SEPARATOR)) {\n      return String(value);\n    }\n    const num = Number(value);\n    if (this.maskExpression.startsWith(MaskExpression.SEPARATOR) && Number.isNaN(num)) {\n      const val = String(value).replace(',', '.');\n      return Number(val);\n    }\n    return Number.isNaN(num) ? value : num;\n  }\n  _removeMask(value, specialCharactersForRemove) {\n    if (this.maskExpression.startsWith(MaskExpression.PERCENT) && value.includes(MaskExpression.DOT)) {\n      return value;\n    }\n    return value ? value.replace(this._regExpForRemove(specialCharactersForRemove), MaskExpression.EMPTY_STRING) : value;\n  }\n  _removePrefix(value) {\n    if (!this.prefix) {\n      return value;\n    }\n    return value ? value.replace(this.prefix, MaskExpression.EMPTY_STRING) : value;\n  }\n  _removeSuffix(value) {\n    if (!this.suffix) {\n      return value;\n    }\n    return value ? value.replace(this.suffix, MaskExpression.EMPTY_STRING) : value;\n  }\n  _retrieveSeparatorValue(result) {\n    let specialCharacters = Array.isArray(this.dropSpecialCharacters) ? this.specialCharacters.filter(v => {\n      return this.dropSpecialCharacters.includes(v);\n    }) : this.specialCharacters;\n    if (!this.deletedSpecialCharacter && this._checkPatternForSpace() && result.includes(MaskExpression.WHITE_SPACE) && this.maskExpression.includes(MaskExpression.SYMBOL_STAR)) {\n      specialCharacters = specialCharacters.filter(char => char !== MaskExpression.WHITE_SPACE);\n    }\n    return this._removeMask(result, specialCharacters);\n  }\n  _regExpForRemove(specialCharactersForRemove) {\n    return new RegExp(specialCharactersForRemove.map(item => `\\\\${item}`).join('|'), 'gi');\n  }\n  _replaceDecimalMarkerToDot(value) {\n    const markers = Array.isArray(this.decimalMarker) ? this.decimalMarker : [this.decimalMarker];\n    return value.replace(this._regExpForRemove(markers), MaskExpression.DOT);\n  }\n  _checkSymbols(result) {\n    let processedResult = result;\n    if (processedResult === MaskExpression.EMPTY_STRING) {\n      return processedResult;\n    }\n    if (this.maskExpression.startsWith(MaskExpression.PERCENT) && this.decimalMarker === MaskExpression.COMMA) {\n      processedResult = processedResult.replace(MaskExpression.COMMA, MaskExpression.DOT);\n    }\n    const separatorPrecision = this._retrieveSeparatorPrecision(this.maskExpression);\n    const separatorValue = this.specialCharacters.length === 0 ? this._retrieveSeparatorValue(processedResult) : this._replaceDecimalMarkerToDot(this._retrieveSeparatorValue(processedResult));\n    if (!this.isNumberValue) {\n      return separatorValue;\n    }\n    if (separatorPrecision) {\n      if (processedResult === this.decimalMarker) {\n        return null;\n      }\n      if (separatorValue.length > 14) {\n        return String(separatorValue);\n      }\n      return this._checkPrecision(this.maskExpression, separatorValue);\n    } else {\n      return separatorValue;\n    }\n  }\n  _checkPatternForSpace() {\n    for (const key in this.patterns) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.patterns[key] && this.patterns[key]?.hasOwnProperty('pattern')) {\n        const patternString = this.patterns[key]?.pattern.toString();\n        const pattern = this.patterns[key]?.pattern;\n        if (patternString?.includes(MaskExpression.WHITE_SPACE) && pattern?.test(this.maskExpression)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  // TODO should think about helpers or separting decimal precision to own property\n  _retrieveSeparatorPrecision(maskExpretion) {\n    const matcher = maskExpretion.match(new RegExp(`^separator\\\\.([^d]*)`));\n    return matcher ? Number(matcher[1]) : null;\n  }\n  _checkPrecision(separatorExpression, separatorValue) {\n    const separatorPrecision = this.getPrecision(separatorExpression);\n    let value = separatorValue;\n    if (separatorExpression.indexOf('2') > 0 || this.leadZero && Number(separatorPrecision) > 0 && Number.isFinite(separatorPrecision)) {\n      if (this.decimalMarker === MaskExpression.COMMA && this.leadZero) {\n        value = value.replace(',', '.');\n      }\n      return this.leadZero ? Number(value).toFixed(Number(separatorPrecision)) : Number(value).toFixed(2);\n    }\n    return this.numberToString(value);\n  }\n  _repeatPatternSymbols(maskExp) {\n    return maskExp.match(/{[0-9]+}/) && maskExp.split(MaskExpression.EMPTY_STRING).reduce((accum, currVal, index) => {\n      this._start = currVal === MaskExpression.CURLY_BRACKETS_LEFT ? index : this._start;\n      if (currVal !== MaskExpression.CURLY_BRACKETS_RIGHT) {\n        return this._findSpecialChar(currVal) ? accum + currVal : accum;\n      }\n      this._end = index;\n      const repeatNumber = Number(maskExp.slice(this._start + 1, this._end));\n      const replaceWith = new Array(repeatNumber + 1).join(maskExp[this._start - 1]);\n      if (maskExp.slice(0, this._start).length > 1 && maskExp.includes(MaskExpression.LETTER_S)) {\n        const symbols = maskExp.slice(0, this._start - 1);\n        return symbols.includes(MaskExpression.CURLY_BRACKETS_LEFT) ? accum + replaceWith : symbols + accum + replaceWith;\n      } else {\n        return accum + replaceWith;\n      }\n    }, '') || maskExp;\n  }\n  currentLocaleDecimalMarker() {\n    return 1.1.toLocaleString().substring(1, 2);\n  }\n  static ɵfac = /* @__PURE__ */(() => {\n    let ɵNgxMaskService_BaseFactory;\n    return function NgxMaskService_Factory(__ngFactoryType__) {\n      return (ɵNgxMaskService_BaseFactory || (ɵNgxMaskService_BaseFactory = i0.ɵɵgetInheritedFactory(NgxMaskService)))(__ngFactoryType__ || NgxMaskService);\n    };\n  })();\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxMaskService,\n    factory: NgxMaskService.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxMaskService, [{\n    type: Injectable\n  }], null, null);\n})();\n\n/**\n * @internal\n */\nfunction _configFactory() {\n  const initConfig = inject(INITIAL_CONFIG);\n  const configValue = inject(NEW_CONFIG);\n  return configValue instanceof Function ? {\n    ...initConfig,\n    ...configValue()\n  } : {\n    ...initConfig,\n    ...configValue\n  };\n}\nfunction provideNgxMask(configValue) {\n  return [{\n    provide: NEW_CONFIG,\n    useValue: configValue\n  }, {\n    provide: INITIAL_CONFIG,\n    useValue: initialConfig\n  }, {\n    provide: NGX_MASK_CONFIG,\n    useFactory: _configFactory\n  }, NgxMaskService];\n}\nfunction provideEnvironmentNgxMask(configValue) {\n  return makeEnvironmentProviders(provideNgxMask(configValue));\n}\nclass NgxMaskDirective {\n  mask = input('', ...(ngDevMode ? [{\n    debugName: \"mask\"\n  }] : []));\n  specialCharacters = input([], ...(ngDevMode ? [{\n    debugName: \"specialCharacters\"\n  }] : []));\n  patterns = input({}, ...(ngDevMode ? [{\n    debugName: \"patterns\"\n  }] : []));\n  prefix = input('', ...(ngDevMode ? [{\n    debugName: \"prefix\"\n  }] : []));\n  suffix = input('', ...(ngDevMode ? [{\n    debugName: \"suffix\"\n  }] : []));\n  thousandSeparator = input(' ', ...(ngDevMode ? [{\n    debugName: \"thousandSeparator\"\n  }] : []));\n  decimalMarker = input('.', ...(ngDevMode ? [{\n    debugName: \"decimalMarker\"\n  }] : []));\n  dropSpecialCharacters = input(null, ...(ngDevMode ? [{\n    debugName: \"dropSpecialCharacters\"\n  }] : []));\n  hiddenInput = input(null, ...(ngDevMode ? [{\n    debugName: \"hiddenInput\"\n  }] : []));\n  showMaskTyped = input(null, ...(ngDevMode ? [{\n    debugName: \"showMaskTyped\"\n  }] : []));\n  placeHolderCharacter = input(null, ...(ngDevMode ? [{\n    debugName: \"placeHolderCharacter\"\n  }] : []));\n  shownMaskExpression = input(null, ...(ngDevMode ? [{\n    debugName: \"shownMaskExpression\"\n  }] : []));\n  clearIfNotMatch = input(null, ...(ngDevMode ? [{\n    debugName: \"clearIfNotMatch\"\n  }] : []));\n  validation = input(null, ...(ngDevMode ? [{\n    debugName: \"validation\"\n  }] : []));\n  separatorLimit = input('', ...(ngDevMode ? [{\n    debugName: \"separatorLimit\"\n  }] : []));\n  allowNegativeNumbers = input(null, ...(ngDevMode ? [{\n    debugName: \"allowNegativeNumbers\"\n  }] : []));\n  leadZeroDateTime = input(null, ...(ngDevMode ? [{\n    debugName: \"leadZeroDateTime\"\n  }] : []));\n  leadZero = input(null, ...(ngDevMode ? [{\n    debugName: \"leadZero\"\n  }] : []));\n  triggerOnMaskChange = input(null, ...(ngDevMode ? [{\n    debugName: \"triggerOnMaskChange\"\n  }] : []));\n  apm = input(null, ...(ngDevMode ? [{\n    debugName: \"apm\"\n  }] : []));\n  inputTransformFn = input(null, ...(ngDevMode ? [{\n    debugName: \"inputTransformFn\"\n  }] : []));\n  outputTransformFn = input(null, ...(ngDevMode ? [{\n    debugName: \"outputTransformFn\"\n  }] : []));\n  keepCharacterPositions = input(null, ...(ngDevMode ? [{\n    debugName: \"keepCharacterPositions\"\n  }] : []));\n  instantPrefix = input(null, ...(ngDevMode ? [{\n    debugName: \"instantPrefix\"\n  }] : []));\n  maskFilled = output();\n  _maskValue = signal('', ...(ngDevMode ? [{\n    debugName: \"_maskValue\"\n  }] : []));\n  _inputValue = signal('', ...(ngDevMode ? [{\n    debugName: \"_inputValue\"\n  }] : []));\n  _position = signal(null, ...(ngDevMode ? [{\n    debugName: \"_position\"\n  }] : []));\n  _code = signal('', ...(ngDevMode ? [{\n    debugName: \"_code\"\n  }] : []));\n  _maskExpressionArray = signal([], ...(ngDevMode ? [{\n    debugName: \"_maskExpressionArray\"\n  }] : []));\n  _justPasted = signal(false, ...(ngDevMode ? [{\n    debugName: \"_justPasted\"\n  }] : []));\n  _isFocused = signal(false, ...(ngDevMode ? [{\n    debugName: \"_isFocused\"\n  }] : []));\n  /**For IME composition event */\n  _isComposing = signal(false, ...(ngDevMode ? [{\n    debugName: \"_isComposing\"\n  }] : []));\n  _maskService = inject(NgxMaskService, {\n    self: true\n  });\n  document = inject(DOCUMENT);\n  _config = inject(NGX_MASK_CONFIG);\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  onChange = _ => {};\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  onTouch = () => {};\n  ngOnChanges(changes) {\n    const {\n      mask,\n      specialCharacters,\n      patterns,\n      prefix,\n      suffix,\n      thousandSeparator,\n      decimalMarker,\n      dropSpecialCharacters,\n      hiddenInput,\n      showMaskTyped,\n      placeHolderCharacter,\n      shownMaskExpression,\n      clearIfNotMatch,\n      validation,\n      separatorLimit,\n      allowNegativeNumbers,\n      leadZeroDateTime,\n      leadZero,\n      triggerOnMaskChange,\n      apm,\n      inputTransformFn,\n      outputTransformFn,\n      keepCharacterPositions,\n      instantPrefix\n    } = changes;\n    if (mask) {\n      if (mask.currentValue !== mask.previousValue && !mask.firstChange) {\n        this._maskService.maskChanged = true;\n      }\n      if (mask.currentValue && mask.currentValue.split(MaskExpression.OR).length > 1) {\n        this._maskExpressionArray.set(mask.currentValue.split(MaskExpression.OR).sort((a, b) => {\n          return a.length - b.length;\n        }));\n        this._setMask();\n      } else {\n        this._maskExpressionArray.set([]);\n        this._maskValue.set(mask.currentValue || MaskExpression.EMPTY_STRING);\n        this._maskService.maskExpression = this._maskValue();\n      }\n    }\n    if (specialCharacters) {\n      if (!specialCharacters.currentValue || !Array.isArray(specialCharacters.currentValue)) {\n        return;\n      } else {\n        this._maskService.specialCharacters = specialCharacters.currentValue || [];\n      }\n    }\n    if (allowNegativeNumbers) {\n      this._maskService.allowNegativeNumbers = allowNegativeNumbers.currentValue;\n      if (this._maskService.allowNegativeNumbers) {\n        this._maskService.specialCharacters = this._maskService.specialCharacters.filter(c => c !== MaskExpression.MINUS);\n      }\n    }\n    // Only overwrite the mask available patterns if a pattern has actually been passed in\n    if (patterns && patterns.currentValue) {\n      this._maskService.patterns = patterns.currentValue;\n    }\n    if (apm && apm.currentValue) {\n      this._maskService.apm = apm.currentValue;\n    }\n    if (instantPrefix) {\n      this._maskService.instantPrefix = instantPrefix.currentValue;\n    }\n    if (prefix) {\n      this._maskService.prefix = prefix.currentValue;\n    }\n    if (suffix) {\n      this._maskService.suffix = suffix.currentValue;\n    }\n    if (thousandSeparator) {\n      this._maskService.thousandSeparator = thousandSeparator.currentValue;\n      if (thousandSeparator.previousValue && thousandSeparator.currentValue) {\n        const previousDecimalMarker = this._maskService.decimalMarker;\n        if (thousandSeparator.currentValue === this._maskService.decimalMarker) {\n          this._maskService.decimalMarker = thousandSeparator.currentValue === MaskExpression.COMMA ? MaskExpression.DOT : MaskExpression.COMMA;\n        }\n        if (this._maskService.dropSpecialCharacters === true) {\n          this._maskService.specialCharacters = this._config.specialCharacters;\n        }\n        if (typeof previousDecimalMarker === 'string' && typeof this._maskService.decimalMarker === 'string') {\n          this._inputValue.set(this._inputValue().split(thousandSeparator.previousValue).join('').replace(previousDecimalMarker, this._maskService.decimalMarker));\n          this._maskService.actualValue = this._inputValue();\n        }\n        this._maskService.writingValue = true;\n      }\n    }\n    if (decimalMarker) {\n      this._maskService.decimalMarker = decimalMarker.currentValue;\n    }\n    if (dropSpecialCharacters) {\n      this._maskService.dropSpecialCharacters = dropSpecialCharacters.currentValue;\n    }\n    if (hiddenInput) {\n      this._maskService.hiddenInput = hiddenInput.currentValue;\n      if (hiddenInput.previousValue === true && hiddenInput.currentValue === false) {\n        this._inputValue.set(this._maskService.actualValue);\n      }\n    }\n    if (showMaskTyped) {\n      this._maskService.showMaskTyped = showMaskTyped.currentValue;\n      if (showMaskTyped.previousValue === false && showMaskTyped.currentValue === true && this._isFocused()) {\n        requestAnimationFrame(() => {\n          this._maskService._elementRef?.nativeElement.click();\n        });\n      }\n    }\n    if (placeHolderCharacter) {\n      this._maskService.placeHolderCharacter = placeHolderCharacter.currentValue;\n    }\n    if (shownMaskExpression) {\n      this._maskService.shownMaskExpression = shownMaskExpression.currentValue;\n    }\n    if (clearIfNotMatch) {\n      this._maskService.clearIfNotMatch = clearIfNotMatch.currentValue;\n    }\n    if (validation) {\n      this._maskService.validation = validation.currentValue;\n    }\n    if (separatorLimit) {\n      this._maskService.separatorLimit = separatorLimit.currentValue;\n    }\n    if (leadZeroDateTime) {\n      this._maskService.leadZeroDateTime = leadZeroDateTime.currentValue;\n    }\n    if (leadZero) {\n      this._maskService.leadZero = leadZero.currentValue;\n    }\n    if (triggerOnMaskChange) {\n      this._maskService.triggerOnMaskChange = triggerOnMaskChange.currentValue;\n    }\n    if (inputTransformFn) {\n      this._maskService.inputTransformFn = inputTransformFn.currentValue;\n    }\n    if (outputTransformFn) {\n      this._maskService.outputTransformFn = outputTransformFn.currentValue;\n    }\n    if (keepCharacterPositions) {\n      this._maskService.keepCharacterPositions = keepCharacterPositions.currentValue;\n    }\n    this._applyMask();\n  }\n  validate({\n    value\n  }) {\n    const processedValue = typeof value === 'number' ? String(value) : value;\n    const maskValue = this._maskValue();\n    if (!this._maskService.validation || !maskValue) {\n      return null;\n    }\n    if (this._maskService.ipError) {\n      return this._createValidationError(processedValue);\n    }\n    if (this._maskService.cpfCnpjError) {\n      return this._createValidationError(processedValue);\n    }\n    if (maskValue.startsWith(MaskExpression.SEPARATOR)) {\n      return null;\n    }\n    if (withoutValidation.includes(maskValue)) {\n      return null;\n    }\n    if (this._maskService.clearIfNotMatch) {\n      return null;\n    }\n    if (timeMasks.includes(maskValue)) {\n      return this._validateTime(processedValue);\n    }\n    if (maskValue === MaskExpression.EMAIL_MASK) {\n      const emailPattern = /^[^@]+@[^@]+\\.[^@]+$/;\n      if (!emailPattern.test(processedValue) && processedValue) {\n        return this._createValidationError(processedValue);\n      } else {\n        return null;\n      }\n    }\n    if (processedValue && processedValue.length >= 1) {\n      let counterOfOpt = 0;\n      if (maskValue.includes(MaskExpression.CURLY_BRACKETS_LEFT) && maskValue.includes(MaskExpression.CURLY_BRACKETS_RIGHT)) {\n        const lengthInsideCurlyBrackets = maskValue.slice(maskValue.indexOf(MaskExpression.CURLY_BRACKETS_LEFT) + 1, maskValue.indexOf(MaskExpression.CURLY_BRACKETS_RIGHT));\n        return lengthInsideCurlyBrackets === String(processedValue.length) ? null : this._createValidationError(processedValue);\n      }\n      if (maskValue.startsWith(MaskExpression.PERCENT)) {\n        return null;\n      }\n      for (const key in this._maskService.patterns) {\n        if (this._maskService.patterns[key]?.optional) {\n          if (maskValue.indexOf(key) !== maskValue.lastIndexOf(key)) {\n            const opt = maskValue.split(MaskExpression.EMPTY_STRING).filter(i => i === key).join(MaskExpression.EMPTY_STRING);\n            counterOfOpt += opt.length;\n          } else if (maskValue.indexOf(key) !== -1) {\n            counterOfOpt++;\n          }\n          if (maskValue.indexOf(key) !== -1 && processedValue.length >= maskValue.indexOf(key)) {\n            return null;\n          }\n          if (counterOfOpt === maskValue.length) {\n            return null;\n          }\n        }\n      }\n      if (maskValue.indexOf(MaskExpression.SYMBOL_STAR) > 1 && processedValue.length < maskValue.indexOf(MaskExpression.SYMBOL_STAR) || maskValue.indexOf(MaskExpression.SYMBOL_QUESTION) > 1 && processedValue.length < maskValue.indexOf(MaskExpression.SYMBOL_QUESTION)) {\n        return this._createValidationError(processedValue);\n      }\n      if (maskValue.indexOf(MaskExpression.SYMBOL_STAR) === -1 || maskValue.indexOf(MaskExpression.SYMBOL_QUESTION) === -1) {\n        const array = maskValue.split('*');\n        const length = this._maskService.dropSpecialCharacters ? maskValue.length - this._maskService.checkDropSpecialCharAmount(maskValue) - counterOfOpt : this.prefix() ? maskValue.length + this.prefix().length - counterOfOpt : maskValue.length - counterOfOpt;\n        if (array.length === 1) {\n          if (processedValue.length < length) {\n            return this._createValidationError(processedValue);\n          }\n        }\n        if (array.length > 1) {\n          const lastIndexArray = array[array.length - 1];\n          if (lastIndexArray && this._maskService.specialCharacters.includes(lastIndexArray[0]) && String(processedValue).includes(lastIndexArray[0] ?? '') && !this.dropSpecialCharacters()) {\n            const special = value.split(lastIndexArray[0]);\n            return special[special.length - 1].length === lastIndexArray.length - 1 ? null : this._createValidationError(processedValue);\n          } else if ((lastIndexArray && !this._maskService.specialCharacters.includes(lastIndexArray[0]) || !lastIndexArray || this._maskService.dropSpecialCharacters) && processedValue.length >= length - 1) {\n            return null;\n          } else {\n            return this._createValidationError(processedValue);\n          }\n        }\n      }\n      if (maskValue.indexOf(MaskExpression.SYMBOL_STAR) === 1 || maskValue.indexOf(MaskExpression.SYMBOL_QUESTION) === 1) {\n        return null;\n      }\n    }\n    if (value) {\n      this.maskFilled.emit();\n      return null;\n    }\n    return null;\n  }\n  onPaste() {\n    this._justPasted.set(true);\n  }\n  onFocus() {\n    this._isFocused.set(true);\n  }\n  onModelChange(value) {\n    // on form reset we need to update the actualValue\n    if ((value === MaskExpression.EMPTY_STRING || value === null || typeof value === 'undefined') && this._maskService.actualValue) {\n      this._maskService.actualValue = this._maskService.getActualValue(MaskExpression.EMPTY_STRING);\n    }\n  }\n  onInput(e) {\n    this._maskService.isInitialized = true;\n    // If IME is composing text, we wait for the composed text.\n    if (this._isComposing()) {\n      return;\n    }\n    const el = e.target;\n    const transformedValue = this._maskService.inputTransformFn ? this._maskService.inputTransformFn(el.value) : el.value;\n    if (el.type !== 'number') {\n      if (typeof transformedValue === 'string' || typeof transformedValue === 'number') {\n        el.value = transformedValue.toString();\n        this._inputValue.set(el.value);\n        this._setMask();\n        if (!this._maskValue()) {\n          this.onChange(el.value);\n          return;\n        }\n        let position = el.selectionStart === 1 ? el.selectionStart + this._maskService.prefix.length : el.selectionStart;\n        if (this.showMaskTyped() && this.keepCharacterPositions() && this._maskService.placeHolderCharacter.length === 1) {\n          const suffix = this.suffix();\n          const prefix = this.prefix();\n          const inputSymbol = el.value.slice(position - 1, position);\n          const prefixLength = prefix.length;\n          const checkSymbols = this._maskService._checkSymbolMask(inputSymbol, this._maskService.maskExpression[position - 1 - prefixLength] ?? MaskExpression.EMPTY_STRING);\n          const checkSpecialCharacter = this._maskService._checkSymbolMask(inputSymbol, this._maskService.maskExpression[position + 1 - prefixLength] ?? MaskExpression.EMPTY_STRING);\n          const selectRangeBackspace = this._maskService.selStart === this._maskService.selEnd;\n          const selStart = Number(this._maskService.selStart) - prefixLength;\n          const selEnd = Number(this._maskService.selEnd) - prefixLength;\n          const backspaceOrDelete = this._code() === MaskExpression.BACKSPACE || this._code() === MaskExpression.DELETE;\n          if (backspaceOrDelete) {\n            if (!selectRangeBackspace) {\n              if (this._maskService.selStart === prefixLength) {\n                this._maskService.actualValue = `${prefix}${this._maskService.maskIsShown.slice(0, selEnd)}${this._inputValue().split(prefix).join('')}`;\n              } else if (this._maskService.selStart === this._maskService.maskIsShown.length + prefixLength) {\n                this._maskService.actualValue = `${this._inputValue()}${this._maskService.maskIsShown.slice(selStart, selEnd)}`;\n              } else {\n                this._maskService.actualValue = `${prefix}${this._inputValue().split(prefix).join('').slice(0, selStart)}${this._maskService.maskIsShown.slice(selStart, selEnd)}${this._maskService.actualValue.slice(selEnd + prefixLength, this._maskService.maskIsShown.length + prefixLength)}${suffix}`;\n              }\n            } else if (!this._maskService.specialCharacters.includes(this._maskService.maskExpression.slice(position - prefixLength, position + 1 - prefixLength)) && selectRangeBackspace) {\n              if (selStart === 1 && prefix) {\n                this._maskService.actualValue = `${prefix}${this._maskService.placeHolderCharacter}${el.value.split(prefix).join('').split(suffix).join('')}${suffix}`;\n                position = position - 1;\n              } else {\n                const part1 = el.value.substring(0, position);\n                const part2 = el.value.substring(position);\n                this._maskService.actualValue = `${part1}${this._maskService.placeHolderCharacter}${part2}`;\n              }\n            }\n            position = this._code() === MaskExpression.DELETE ? position + 1 : position;\n          }\n          if (!backspaceOrDelete) {\n            if (!checkSymbols && !checkSpecialCharacter && selectRangeBackspace) {\n              position = Number(el.selectionStart) - 1;\n            } else if (this._maskService.specialCharacters.includes(el.value.slice(position, position + 1)) && checkSpecialCharacter && !this._maskService.specialCharacters.includes(el.value.slice(position + 1, position + 2))) {\n              this._maskService.actualValue = `${el.value.slice(0, position - 1)}${el.value.slice(position, position + 1)}${inputSymbol}${el.value.slice(position + 2)}`;\n              position = position + 1;\n            } else if (checkSymbols) {\n              if (el.value.length === 1 && position === 1) {\n                this._maskService.actualValue = `${prefix}${inputSymbol}${this._maskService.maskIsShown.slice(1, this._maskService.maskIsShown.length)}${suffix}`;\n              } else {\n                this._maskService.actualValue = `${el.value.slice(0, position - 1)}${inputSymbol}${el.value.slice(position + 1).split(suffix).join('')}${suffix}`;\n              }\n            } else if (prefix && el.value.length === 1 && position - prefixLength === 1 && this._maskService._checkSymbolMask(el.value, this._maskService.maskExpression[position - 1 - prefixLength] ?? MaskExpression.EMPTY_STRING)) {\n              this._maskService.actualValue = `${prefix}${el.value}${this._maskService.maskIsShown.slice(1, this._maskService.maskIsShown.length)}${suffix}`;\n            }\n          }\n        }\n        let caretShift = 0;\n        let backspaceShift = false;\n        if (this._code() === MaskExpression.DELETE && MaskExpression.SEPARATOR) {\n          this._maskService.deletedSpecialCharacter = true;\n        }\n        if (this._inputValue().length >= this._maskService.maskExpression.length - 1 && this._code() !== MaskExpression.BACKSPACE && this._maskService.maskExpression === MaskExpression.DAYS_MONTHS_YEARS && position < 10) {\n          const inputSymbol = this._inputValue().slice(position - 1, position);\n          el.value = this._inputValue().slice(0, position - 1) + inputSymbol + this._inputValue().slice(position + 1);\n        }\n        if (this._maskService.maskExpression === MaskExpression.DAYS_MONTHS_YEARS && this.leadZeroDateTime()) {\n          if (position < 3 && Number(el.value) > 31 && Number(el.value) < 40 || position === 5 && Number(el.value.slice(3, 5)) > 12) {\n            position = position + 2;\n          }\n        }\n        if (this._maskService.maskExpression === MaskExpression.HOURS_MINUTES_SECONDS && this.apm()) {\n          if (this._justPasted() && el.value.slice(0, 2) === MaskExpression.DOUBLE_ZERO) {\n            el.value = el.value.slice(1, 2) + el.value.slice(2, el.value.length);\n          }\n          el.value = el.value === MaskExpression.DOUBLE_ZERO ? MaskExpression.NUMBER_ZERO : el.value;\n        }\n        this._maskService.applyValueChanges(position, this._justPasted(), this._code() === MaskExpression.BACKSPACE || this._code() === MaskExpression.DELETE, (shift, _backspaceShift) => {\n          this._justPasted.set(false);\n          caretShift = shift;\n          backspaceShift = _backspaceShift;\n        });\n        // only set the selection if the element is active\n        if (this._getActiveElement() !== el) {\n          return;\n        }\n        if (this._maskService.plusOnePosition) {\n          position = position + 1;\n          this._maskService.plusOnePosition = false;\n        }\n        // update position after applyValueChanges to prevent cursor on wrong position when it has an array of maskExpression\n        if (this._maskExpressionArray().length) {\n          if (this._code() === MaskExpression.BACKSPACE) {\n            const specialChartMinusOne = this.specialCharacters().includes(this._maskService.actualValue.slice(position - 1, position));\n            const allowFewMaskChangeMask = this._maskService.removeMask(this._inputValue())?.length === this._maskService.removeMask(this._maskService.maskExpression)?.length;\n            const specialChartPlusOne = this.specialCharacters().includes(this._maskService.actualValue.slice(position, position + 1));\n            if (allowFewMaskChangeMask && !specialChartPlusOne) {\n              position = el.selectionStart + 1;\n            } else {\n              position = specialChartMinusOne ? position - 1 : position;\n            }\n          } else {\n            position = el.selectionStart === 1 ? el.selectionStart + this._maskService.prefix.length : el.selectionStart;\n          }\n        }\n        this._position.set(this._position() === 1 && this._inputValue().length === 1 ? null : this._position());\n        let positionToApply = this._position() ? this._inputValue().length + position + caretShift : position + (this._code() === MaskExpression.BACKSPACE && !backspaceShift ? 0 : caretShift);\n        if (positionToApply > this._getActualInputLength()) {\n          positionToApply = el.value === this._maskService.decimalMarker && el.value.length === 1 ? this._getActualInputLength() + 1 : this._getActualInputLength();\n        }\n        if (positionToApply < 0) {\n          positionToApply = 0;\n        }\n        el.setSelectionRange(positionToApply, positionToApply);\n        this._position.set(null);\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn('Ngx-mask writeValue work with string | number, your current value:', typeof transformedValue);\n      }\n    } else {\n      if (!this._maskValue()) {\n        this.onChange(el.value);\n        return;\n      }\n      this._maskService.applyValueChanges(el.value.length, this._justPasted(), this._code() === MaskExpression.BACKSPACE || this._code() === MaskExpression.DELETE);\n    }\n  }\n  // IME starts\n  onCompositionStart() {\n    this._isComposing.set(true);\n  }\n  // IME completes\n  onCompositionEnd(e) {\n    this._isComposing.set(false);\n    this._justPasted.set(true);\n    this.onInput(e);\n  }\n  onBlur(e) {\n    if (this._maskValue()) {\n      const el = e.target;\n      if (this._maskService.leadZero && el.value.length > 0 && typeof this._maskService.decimalMarker === 'string') {\n        const maskExpression = this._maskService.maskExpression;\n        const decimalMarker = this._maskService.decimalMarker;\n        const suffix = this._maskService.suffix;\n        const precision = Number(this._maskService.maskExpression.slice(maskExpression.length - 1, maskExpression.length));\n        if (precision > 0) {\n          el.value = suffix ? el.value.split(suffix).join('') : el.value;\n          const decimalPart = el.value.split(decimalMarker)[1];\n          el.value = el.value.includes(decimalMarker) ? el.value + MaskExpression.NUMBER_ZERO.repeat(precision - decimalPart.length) + suffix : el.value + decimalMarker + MaskExpression.NUMBER_ZERO.repeat(precision) + suffix;\n          this._maskService.actualValue = el.value;\n        }\n      }\n      this._maskService.clearIfNotMatchFn();\n    }\n    this._isFocused.set(false);\n    this.onTouch();\n  }\n  onClick(e) {\n    if (!this._maskValue()) {\n      return;\n    }\n    const el = e.target;\n    const posStart = 0;\n    const posEnd = 0;\n    if (el !== null && el.selectionStart !== null && el.selectionStart === el.selectionEnd && el.selectionStart > this._maskService.prefix.length && e.keyCode !== 38) {\n      if (this._maskService.showMaskTyped && !this.keepCharacterPositions()) {\n        // We are showing the mask in the input\n        this._maskService.maskIsShown = this._maskService.showMaskInInput();\n        if (el.setSelectionRange && this._maskService.prefix + this._maskService.maskIsShown === el.value) {\n          // the input ONLY contains the mask, so position the cursor at the start\n          el.focus();\n          el.setSelectionRange(posStart, posEnd);\n        } else {\n          // the input contains some characters already\n          if (el.selectionStart > this._maskService.actualValue.length) {\n            // if the user clicked beyond our value's length, position the cursor at the end of our value\n            el.setSelectionRange(this._maskService.actualValue.length, this._maskService.actualValue.length);\n          }\n        }\n      }\n    }\n    const nextValue = el && (el.value === this._maskService.prefix ? this._maskService.prefix + this._maskService.maskIsShown : el.value);\n    /** Fix of cursor position jumping to end in most browsers no matter where cursor is inserted onFocus */\n    if (el && el.value !== nextValue) {\n      el.value = nextValue;\n    }\n    /** fix of cursor position with prefix when mouse click occur */\n    if (el && el.type !== 'number' && (el.selectionStart || el.selectionEnd) <= this._maskService.prefix.length) {\n      const specialCharactersAtTheStart = this._maskService.maskExpression.match(new RegExp(`^[${this._maskService.specialCharacters.map(c => `\\\\${c}`).join('')}]+`))?.[0].length || 0;\n      el.selectionStart = this._maskService.prefix.length + specialCharactersAtTheStart;\n      return;\n    }\n    /** select only inserted text */\n    if (el && el.selectionEnd > this._getActualInputLength()) {\n      el.selectionEnd = this._getActualInputLength();\n    }\n  }\n  onKeyDown(e) {\n    if (!this._maskValue()) {\n      return;\n    }\n    if (this._isComposing()) {\n      // User finalize their choice from IME composition, so trigger onInput() for the composed text.\n      if (e.key === 'Enter') {\n        this.onCompositionEnd(e);\n      }\n      return;\n    }\n    this._code.set(e.code ? e.code : e.key);\n    const el = e.target;\n    this._inputValue.set(el.value);\n    this._setMask();\n    const isTextarea = el.tagName.toLowerCase() === 'textarea';\n    if (el.type !== 'number') {\n      if (e.key === MaskExpression.ARROW_UP && !isTextarea) {\n        e.preventDefault();\n      }\n      if (e.key === MaskExpression.ARROW_LEFT || e.key === MaskExpression.BACKSPACE || e.key === MaskExpression.DELETE) {\n        if (e.key === MaskExpression.BACKSPACE && el.value.length === 0) {\n          el.selectionStart = el.selectionEnd;\n        }\n        if (e.key === MaskExpression.BACKSPACE && el.selectionStart !== 0) {\n          const prefixLength = this.prefix().length;\n          // If specialChars is false, (shouldn't ever happen) then set to the defaults\n          const specialCharacters = this.specialCharacters().length ? this.specialCharacters() : this._config.specialCharacters;\n          if (prefixLength > 1 && el.selectionStart <= prefixLength) {\n            el.setSelectionRange(prefixLength, el.selectionEnd);\n          } else {\n            if (this._inputValue().length !== el.selectionStart && el.selectionStart !== 1) {\n              while (specialCharacters.includes((this._inputValue()[el.selectionStart - 1] ?? MaskExpression.EMPTY_STRING).toString()) && (prefixLength >= 1 && el.selectionStart > prefixLength || prefixLength === 0)) {\n                el.setSelectionRange(el.selectionStart - 1, el.selectionEnd);\n              }\n            }\n          }\n        }\n        this.checkSelectionOnDeletion(el);\n        if (this._maskService.prefix.length && el.selectionStart <= this._maskService.prefix.length && el.selectionEnd <= this._maskService.prefix.length) {\n          e.preventDefault();\n        }\n        const cursorStart = el.selectionStart;\n        if (e.key === MaskExpression.BACKSPACE && !el.readOnly && cursorStart === 0 && el.selectionEnd === el.value.length && el.value.length !== 0) {\n          this._position.set(this._maskService.prefix ? this._maskService.prefix.length : 0);\n          this._maskService.applyMask(this._maskService.prefix, this._maskService.maskExpression, this._position());\n        }\n      }\n      if (!!this.suffix() && this.suffix().length > 1 && this._inputValue().length - this.suffix().length < el.selectionStart) {\n        el.setSelectionRange(this._inputValue().length - this.suffix().length, this._inputValue().length);\n      } else if (e.code === 'KeyA' && e.ctrlKey || e.code === 'KeyA' && e.metaKey // Cmd + A (Mac)\n      ) {\n        el.setSelectionRange(0, this._getActualInputLength());\n        e.preventDefault();\n      }\n      this._maskService.selStart = el.selectionStart;\n      this._maskService.selEnd = el.selectionEnd;\n    }\n  }\n  /** It writes the value in the input */\n  writeValue(controlValue) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      let value = controlValue;\n      const inputTransformFn = _this._maskService.inputTransformFn;\n      if (typeof value === 'object' && value !== null && 'value' in value) {\n        if ('disable' in value) {\n          _this.setDisabledState(Boolean(value.disable));\n        }\n        value = value.value;\n      }\n      if (value !== null) {\n        value = inputTransformFn ? inputTransformFn(value) : value;\n      }\n      if (typeof value === 'string' || typeof value === 'number' || value === null || typeof value === 'undefined') {\n        if (value === null || typeof value === 'undefined' || value === '') {\n          _this._maskService.currentValue = '';\n          _this._maskService.previousValue = '';\n        }\n        let inputValue = value;\n        if (typeof inputValue === 'number' || _this._maskValue().startsWith(MaskExpression.SEPARATOR)) {\n          inputValue = String(inputValue);\n          const localeDecimalMarker = _this._maskService.currentLocaleDecimalMarker();\n          if (!Array.isArray(_this._maskService.decimalMarker)) {\n            inputValue = _this._maskService.decimalMarker !== localeDecimalMarker ? inputValue.replace(localeDecimalMarker, _this._maskService.decimalMarker) : inputValue;\n          }\n          if (_this._maskService.leadZero && inputValue && _this.mask() && _this.dropSpecialCharacters() !== false) {\n            inputValue = _this._maskService._checkPrecision(_this._maskService.maskExpression, inputValue);\n          }\n          if (_this._maskService.decimalMarker === MaskExpression.COMMA || Array.isArray(_this._maskService.decimalMarker) && _this._maskService.thousandSeparator === MaskExpression.DOT) {\n            inputValue = inputValue.toString().replace(MaskExpression.DOT, MaskExpression.COMMA);\n          }\n          if (_this.mask()?.startsWith(MaskExpression.SEPARATOR) && _this.leadZero()) {\n            requestAnimationFrame(() => {\n              _this._maskService.applyMask(inputValue?.toString() ?? '', _this._maskService.maskExpression);\n            });\n          }\n          _this._maskService.isNumberValue = true;\n        }\n        if (typeof inputValue !== 'string' || value === null || typeof value === 'undefined') {\n          inputValue = '';\n        }\n        _this._inputValue.set(inputValue);\n        _this._setMask();\n        if (inputValue && _this._maskService.maskExpression || _this._maskService.maskExpression && (_this._maskService.prefix || _this._maskService.showMaskTyped)) {\n          // Let the service we know we are writing value so that triggering onChange function won't happen during applyMask\n          _this._maskService.writingValue = true;\n          _this._maskService.formElementProperty = ['value', _this._maskService.applyMask(inputValue, _this._maskService.maskExpression)];\n          // Let the service know we've finished writing value\n          _this._maskService.writingValue = false;\n          _this._maskService.isInitialized = true;\n        } else {\n          _this._maskService.formElementProperty = ['value', inputValue];\n          _this._maskService.isInitialized = true;\n        }\n        _this._inputValue.set(inputValue);\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn('Ngx-mask writeValue work with string | number, your current value:', typeof value);\n      }\n    })();\n  }\n  registerOnChange(fn) {\n    this._maskService.onChange = this.onChange = fn;\n  }\n  registerOnTouched(fn) {\n    this.onTouch = fn;\n  }\n  _getActiveElement(document = this.document) {\n    const shadowRootEl = document?.activeElement?.shadowRoot;\n    if (!shadowRootEl?.activeElement) {\n      return document.activeElement;\n    } else {\n      return this._getActiveElement(shadowRootEl);\n    }\n  }\n  checkSelectionOnDeletion(el) {\n    const prefixLength = this.prefix().length;\n    const suffixLength = this.suffix().length;\n    const inputValueLength = this._inputValue().length;\n    el.selectionStart = Math.min(Math.max(prefixLength, el.selectionStart), inputValueLength - suffixLength);\n    el.selectionEnd = Math.min(Math.max(prefixLength, el.selectionEnd), inputValueLength - suffixLength);\n  }\n  /** It disables the input element */\n  setDisabledState(isDisabled) {\n    this._maskService.formElementProperty = ['disabled', isDisabled];\n  }\n  _applyMask() {\n    this._maskService.maskExpression = this._maskService._repeatPatternSymbols(this._maskValue() || '');\n    this._maskService.formElementProperty = ['value', this._maskService.applyMask(this._inputValue(), this._maskService.maskExpression)];\n  }\n  _validateTime(value) {\n    const rowMaskLen = this._maskValue().split(MaskExpression.EMPTY_STRING).filter(s => s !== ':').length;\n    if (!value) {\n      return null; // Don't validate empty values to allow for optional form control\n    }\n    if (+(value[value.length - 1] ?? -1) === 0 && value.length < rowMaskLen || value.length <= rowMaskLen - 2) {\n      return this._createValidationError(value);\n    }\n    return null;\n  }\n  _getActualInputLength() {\n    return this._maskService.actualValue.length || this._maskService.actualValue.length + this._maskService.prefix.length;\n  }\n  _createValidationError(actualValue) {\n    return {\n      mask: {\n        requiredMask: this._maskValue(),\n        actualValue\n      }\n    };\n  }\n  _setMask() {\n    this._maskExpressionArray().some(mask => {\n      const specialChart = mask.split(MaskExpression.EMPTY_STRING).some(char => this._maskService.specialCharacters.includes(char));\n      if (specialChart && this._inputValue() && this._areAllCharactersInEachStringSame(this._maskExpressionArray()) || mask.includes(MaskExpression.CURLY_BRACKETS_LEFT)) {\n        const test = this._maskService.removeMask(this._inputValue())?.length <= this._maskService.removeMask(mask)?.length;\n        if (test) {\n          const maskValue = mask.includes(MaskExpression.CURLY_BRACKETS_LEFT) ? this._maskService._repeatPatternSymbols(mask) : mask;\n          this._maskValue.set(maskValue);\n          this._maskService.maskExpression = maskValue;\n          return test;\n        } else {\n          const expression = this._maskExpressionArray()[this._maskExpressionArray().length - 1] ?? MaskExpression.EMPTY_STRING;\n          const maskValue = expression.includes(MaskExpression.CURLY_BRACKETS_LEFT) ? this._maskService._repeatPatternSymbols(expression) : expression;\n          this._maskValue.set(maskValue);\n          this._maskService.maskExpression = maskValue;\n        }\n      } else {\n        const cleanMask = this._maskService.removeMask(mask);\n        const check = this._maskService.removeMask(this._inputValue())?.split(MaskExpression.EMPTY_STRING).every((character, index) => {\n          const indexMask = cleanMask.charAt(index);\n          return this._maskService._checkSymbolMask(character, indexMask);\n        });\n        if (check || this._justPasted()) {\n          this._maskValue.set(mask);\n          this._maskService.maskExpression = mask;\n          return check;\n        }\n      }\n    });\n  }\n  _areAllCharactersInEachStringSame(array) {\n    const specialCharacters = this._maskService.specialCharacters;\n    function removeSpecialCharacters(str) {\n      const regex = new RegExp(`[${specialCharacters.map(ch => `\\\\${ch}`).join('')}]`, 'g');\n      return str.replace(regex, '');\n    }\n    const processedArr = array.map(removeSpecialCharacters);\n    return processedArr.every(str => {\n      const uniqueCharacters = new Set(str);\n      return uniqueCharacters.size === 1;\n    });\n  }\n  static ɵfac = function NgxMaskDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxMaskDirective)();\n  };\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxMaskDirective,\n    selectors: [[\"input\", \"mask\", \"\"], [\"textarea\", \"mask\", \"\"]],\n    hostBindings: function NgxMaskDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"paste\", function NgxMaskDirective_paste_HostBindingHandler() {\n          return ctx.onPaste();\n        })(\"focus\", function NgxMaskDirective_focus_HostBindingHandler($event) {\n          return ctx.onFocus($event);\n        })(\"ngModelChange\", function NgxMaskDirective_ngModelChange_HostBindingHandler($event) {\n          return ctx.onModelChange($event);\n        })(\"input\", function NgxMaskDirective_input_HostBindingHandler($event) {\n          return ctx.onInput($event);\n        })(\"compositionstart\", function NgxMaskDirective_compositionstart_HostBindingHandler($event) {\n          return ctx.onCompositionStart($event);\n        })(\"compositionend\", function NgxMaskDirective_compositionend_HostBindingHandler($event) {\n          return ctx.onCompositionEnd($event);\n        })(\"blur\", function NgxMaskDirective_blur_HostBindingHandler($event) {\n          return ctx.onBlur($event);\n        })(\"click\", function NgxMaskDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"keydown\", function NgxMaskDirective_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n    },\n    inputs: {\n      mask: [1, \"mask\"],\n      specialCharacters: [1, \"specialCharacters\"],\n      patterns: [1, \"patterns\"],\n      prefix: [1, \"prefix\"],\n      suffix: [1, \"suffix\"],\n      thousandSeparator: [1, \"thousandSeparator\"],\n      decimalMarker: [1, \"decimalMarker\"],\n      dropSpecialCharacters: [1, \"dropSpecialCharacters\"],\n      hiddenInput: [1, \"hiddenInput\"],\n      showMaskTyped: [1, \"showMaskTyped\"],\n      placeHolderCharacter: [1, \"placeHolderCharacter\"],\n      shownMaskExpression: [1, \"shownMaskExpression\"],\n      clearIfNotMatch: [1, \"clearIfNotMatch\"],\n      validation: [1, \"validation\"],\n      separatorLimit: [1, \"separatorLimit\"],\n      allowNegativeNumbers: [1, \"allowNegativeNumbers\"],\n      leadZeroDateTime: [1, \"leadZeroDateTime\"],\n      leadZero: [1, \"leadZero\"],\n      triggerOnMaskChange: [1, \"triggerOnMaskChange\"],\n      apm: [1, \"apm\"],\n      inputTransformFn: [1, \"inputTransformFn\"],\n      outputTransformFn: [1, \"outputTransformFn\"],\n      keepCharacterPositions: [1, \"keepCharacterPositions\"],\n      instantPrefix: [1, \"instantPrefix\"]\n    },\n    outputs: {\n      maskFilled: \"maskFilled\"\n    },\n    exportAs: [\"mask\", \"ngxMask\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: NgxMaskDirective,\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: NgxMaskDirective,\n      multi: true\n    }, NgxMaskService]), i0.ɵɵNgOnChangesFeature]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxMaskDirective, [{\n    type: Directive,\n    args: [{\n      selector: 'input[mask], textarea[mask]',\n      standalone: true,\n      providers: [{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: NgxMaskDirective,\n        multi: true\n      }, {\n        provide: NG_VALIDATORS,\n        useExisting: NgxMaskDirective,\n        multi: true\n      }, NgxMaskService],\n      exportAs: 'mask,ngxMask'\n    }]\n  }], null, {\n    onPaste: [{\n      type: HostListener,\n      args: ['paste']\n    }],\n    onFocus: [{\n      type: HostListener,\n      args: ['focus', ['$event']]\n    }],\n    onModelChange: [{\n      type: HostListener,\n      args: ['ngModelChange', ['$event']]\n    }],\n    onInput: [{\n      type: HostListener,\n      args: ['input', ['$event']]\n    }],\n    onCompositionStart: [{\n      type: HostListener,\n      args: ['compositionstart', ['$event']]\n    }],\n    onCompositionEnd: [{\n      type: HostListener,\n      args: ['compositionend', ['$event']]\n    }],\n    onBlur: [{\n      type: HostListener,\n      args: ['blur', ['$event']]\n    }],\n    onClick: [{\n      type: HostListener,\n      args: ['click', ['$event']]\n    }],\n    onKeyDown: [{\n      type: HostListener,\n      args: ['keydown', ['$event']]\n    }]\n  });\n})();\nclass NgxMaskPipe {\n  defaultOptions = inject(NGX_MASK_CONFIG);\n  _maskService = inject(NgxMaskService);\n  _maskExpressionArray = [];\n  mask = '';\n  transform(value, mask, {\n    patterns,\n    ...config\n  } = {}) {\n    let processedValue = value;\n    const currentConfig = {\n      maskExpression: mask,\n      ...this.defaultOptions,\n      ...config,\n      patterns: {\n        ...this._maskService.patterns,\n        ...patterns\n      }\n    };\n    Object.entries(currentConfig).forEach(([key, val]) => {\n      this._maskService[key] = val;\n    });\n    if (mask.includes('||')) {\n      const maskParts = mask.split('||');\n      if (maskParts.length > 1) {\n        this._maskExpressionArray = maskParts.sort((a, b) => a.length - b.length);\n        this._setMask(`${processedValue}`);\n        return this._maskService.applyMask(`${processedValue}`, this.mask);\n      } else {\n        this._maskExpressionArray = [];\n        return this._maskService.applyMask(`${processedValue}`, this.mask);\n      }\n    }\n    if (mask.includes(MaskExpression.CURLY_BRACKETS_LEFT)) {\n      return this._maskService.applyMask(`${processedValue}`, this._maskService._repeatPatternSymbols(mask));\n    }\n    if (mask.startsWith(MaskExpression.SEPARATOR)) {\n      if (config.decimalMarker) {\n        this._maskService.decimalMarker = config.decimalMarker;\n      }\n      if (config.thousandSeparator) {\n        this._maskService.thousandSeparator = config.thousandSeparator;\n      }\n      if (config.leadZero) {\n        this._maskService.leadZero = config.leadZero;\n      }\n      processedValue = String(processedValue);\n      const localeDecimalMarker = this._maskService.currentLocaleDecimalMarker();\n      if (!Array.isArray(this._maskService.decimalMarker)) {\n        processedValue = this._maskService.decimalMarker !== localeDecimalMarker ? processedValue.replace(localeDecimalMarker, this._maskService.decimalMarker) : processedValue;\n      }\n      if (this._maskService.leadZero && processedValue && this._maskService.dropSpecialCharacters !== false) {\n        processedValue = this._maskService._checkPrecision(mask, processedValue);\n      }\n      if (this._maskService.decimalMarker === MaskExpression.COMMA) {\n        processedValue = processedValue.replace(MaskExpression.DOT, MaskExpression.COMMA);\n      }\n      this._maskService.isNumberValue = true;\n    }\n    if (processedValue === null || typeof processedValue === 'undefined') {\n      return this._maskService.applyMask('', mask);\n    }\n    return this._maskService.applyMask(`${processedValue}`, mask);\n  }\n  _setMask(value) {\n    if (this._maskExpressionArray.length > 0) {\n      this._maskExpressionArray.some(mask => {\n        const test = this._maskService.removeMask(value)?.length <= this._maskService.removeMask(mask)?.length;\n        if (value && test) {\n          this.mask = mask;\n          return test;\n        } else {\n          this.mask = this._maskExpressionArray[this._maskExpressionArray.length - 1] ?? MaskExpression.EMPTY_STRING;\n        }\n      });\n    }\n  }\n  static ɵfac = function NgxMaskPipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxMaskPipe)();\n  };\n  static ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"mask\",\n    type: NgxMaskPipe,\n    pure: true\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxMaskPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'mask',\n      pure: true,\n      standalone: true\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_CONFIG, NEW_CONFIG, NGX_MASK_CONFIG, NgxMaskDirective, NgxMaskPipe, NgxMaskService, initialConfig, provideEnvironmentNgxMask, provideNgxMask, timeMasks, withoutValidation };","map":{"version":3,"names":["i0","InjectionToken","EventEmitter","inject","Injectable","ElementRef","Renderer2","makeEnvironmentProviders","input","output","signal","HostListener","Directive","Pipe","DOCUMENT","NG_VALUE_ACCESSOR","NG_VALIDATORS","MaskExpression","NGX_MASK_CONFIG","NEW_CONFIG","INITIAL_CONFIG","initialConfig","suffix","prefix","thousandSeparator","decimalMarker","clearIfNotMatch","showMaskTyped","instantPrefix","placeHolderCharacter","dropSpecialCharacters","hiddenInput","shownMaskExpression","separatorLimit","allowNegativeNumbers","validation","specialCharacters","leadZeroDateTime","apm","leadZero","keepCharacterPositions","triggerOnMaskChange","inputTransformFn","value","outputTransformFn","maskFilled","patterns","pattern","RegExp","optional","X","symbol","A","S","U","L","d","m","M","H","h","s","timeMasks","HOURS_MINUTES_SECONDS","HOURS_MINUTES","MINUTES_SECONDS","withoutValidation","PERCENT","HOURS_HOUR","SECONDS","MINUTES","SEPARATOR","DAYS_MONTHS_YEARS","DAYS_MONTHS","DAYS","MONTHS","NgxMaskApplierService","_config","customPattern","_shift","Set","plusOnePosition","maskExpression","actualValue","showKeepCharacterExp","deletedSpecialCharacter","ipError","cpfCnpjError","applyMask","inputValue","position","justPasted","backspaced","cb","EMPTY_STRING","cursor","result","multi","backspaceShift","shift","stepBack","processedValue","processedPosition","startsWithPrefix","slice","length","pastedFullWithPrefix","looksLikeFullPrefixPaste","checkAndRemoveSuffix","inputArray","toString","split","MINUS","IP","valuesIP","DOT","_validIP","arr","i","match","push","CPF_CNPJ","startsWith","_stripToDecimal","precision","getPrecision","checkInputPrecision","indexOf","percentage","substring","base","_splitPercentZero","Array","isArray","includes","find","dm","decimalMarkerIndex","nonZeroIndex","_findFirstNonZeroAndDecimalIndex","zeroIndexMinus","zeroIndexNumberZero","NUMBER_ZERO","zeroIndexDecimalMarker","firstIndexDecimalMarker","COMMA","thousandSeparatorCharEscaped","_charToRegExpExpression","invalidChars","replace","marker","invalidCharRegexp","strForSep","_formatWithSeparators","commaShift","shiftStep","backspacedDecimalMarkerWithSeparatorLimit","add","clear","inputSymbol","symbolStarInPattern","SYMBOL_STAR","_checkSymbolMask","SYMBOL_QUESTION","HOURS","Number","_shiftStep","HOUR","MINUTE","SECOND","daysCount","inputValueCursor","inputValueCursorPlusOne","inputValueCursorPlusTwo","inputValueCursorMinusOne","inputValueCursorMinusTwo","inputValueSliceMinusThreeMinusOne","inputValueSliceMinusOnePlusOne","inputValueSliceCursorPlusTwo","inputValueSliceMinusTwoCursor","DAY","maskStartWithMonth","startWithMonthInput","MONTH","monthsCount","withoutDays","specialChart","day1monthInput","day2monthInput","day2monthInputDot","day1monthPaste","day2monthPaste","NUMBER_NINE","_findSpecialChar","newPosition","has","actualShift","onlySpecial","every","char","res","isSpecialCharacterMaskFirstSymbol","join","_findDropSpecialChar","val","maskSymbol","test","str","thousandSeparatorChar","decimalChars","x","decimalChar","regExp","map","v","decimals","rgx","sanitizedStr","isNaN","Infinity","substr","processedInputValue","processedDecimalMarker","precisionRegEx","precisionMatch","precisionMatchLength","diff","_compareOrIncludes","filter","idx","isDecimalMarker","charsToEscape","comparedValue","excludedValue","some","index","decimalIndex","emptyOrMinus","parsedValue","parseInt","integerPart","decimalPart","integerString","decimal","inputString","ɵfac","NgxMaskApplierService_Factory","__ngFactoryType__","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","ɵsetClassMetadata","type","NgxMaskService","isNumberValue","maskIsShown","selStart","selEnd","maskChanged","maskExpressionArray","previousValue","currentValue","writingValue","isInitialized","_emitValue","_start","_end","onChange","_","_elementRef","document","_renderer","showMaskInInput","HASH","formControlResult","getSymbol","newInputValue","actualResult","concat","removeMask","splice","shiftTypedSymbols","Boolean","getActualValue","item","hideInput","resLen","prefNmask","countSkipedSymbol","_numberSkipedSymbols","regex","exec","applyValueChanges","formElement","nativeElement","_getActiveElement","clearIfNotMatchFn","curr","compare","maskChar","symbolToReplace","currSymbol","replaceSymbol","numberToString","String","toLocaleString","useGrouping","maximumFractionDigits","inputVal","Error","_checkForIp","_checkForCpfCnpj","formElementProperty","name","Promise","resolve","then","setProperty","checkDropSpecialCharAmount","mask","chars","_removeMask","_removeSuffix","_removePrefix","cpf","cnpj","shadowRootEl","activeElement","shadowRoot","_toNumber","_checkSymbols","num","specialCharactersForRemove","_regExpForRemove","_retrieveSeparatorValue","_checkPatternForSpace","WHITE_SPACE","_replaceDecimalMarkerToDot","markers","processedResult","separatorPrecision","_retrieveSeparatorPrecision","separatorValue","_checkPrecision","key","hasOwnProperty","patternString","maskExpretion","matcher","separatorExpression","isFinite","toFixed","_repeatPatternSymbols","maskExp","reduce","accum","currVal","CURLY_BRACKETS_LEFT","CURLY_BRACKETS_RIGHT","repeatNumber","replaceWith","LETTER_S","symbols","currentLocaleDecimalMarker","ɵNgxMaskService_BaseFactory","NgxMaskService_Factory","ɵɵgetInheritedFactory","_configFactory","initConfig","configValue","Function","provideNgxMask","provide","useValue","useFactory","provideEnvironmentNgxMask","NgxMaskDirective","debugName","_maskValue","_inputValue","_position","_code","_maskExpressionArray","_justPasted","_isFocused","_isComposing","_maskService","self","onTouch","ngOnChanges","changes","firstChange","OR","set","sort","a","b","_setMask","c","previousDecimalMarker","requestAnimationFrame","click","_applyMask","validate","maskValue","_createValidationError","_validateTime","EMAIL_MASK","emailPattern","counterOfOpt","lengthInsideCurlyBrackets","lastIndexOf","opt","array","lastIndexArray","special","emit","onPaste","onFocus","onModelChange","onInput","e","el","target","transformedValue","selectionStart","prefixLength","checkSymbols","checkSpecialCharacter","selectRangeBackspace","backspaceOrDelete","BACKSPACE","DELETE","part1","part2","caretShift","DOUBLE_ZERO","_backspaceShift","specialChartMinusOne","allowFewMaskChangeMask","specialChartPlusOne","positionToApply","_getActualInputLength","setSelectionRange","console","warn","onCompositionStart","onCompositionEnd","onBlur","repeat","onClick","posStart","posEnd","selectionEnd","keyCode","focus","nextValue","specialCharactersAtTheStart","onKeyDown","code","isTextarea","tagName","toLowerCase","ARROW_UP","preventDefault","ARROW_LEFT","checkSelectionOnDeletion","cursorStart","readOnly","ctrlKey","metaKey","writeValue","controlValue","_this","_asyncToGenerator","setDisabledState","disable","localeDecimalMarker","registerOnChange","fn","registerOnTouched","suffixLength","inputValueLength","Math","min","max","isDisabled","rowMaskLen","requiredMask","_areAllCharactersInEachStringSame","expression","cleanMask","check","character","indexMask","charAt","removeSpecialCharacters","ch","processedArr","uniqueCharacters","size","NgxMaskDirective_Factory","ɵdir","ɵɵdefineDirective","selectors","hostBindings","NgxMaskDirective_HostBindings","rf","ctx","ɵɵlistener","NgxMaskDirective_paste_HostBindingHandler","NgxMaskDirective_focus_HostBindingHandler","$event","NgxMaskDirective_ngModelChange_HostBindingHandler","NgxMaskDirective_input_HostBindingHandler","NgxMaskDirective_compositionstart_HostBindingHandler","NgxMaskDirective_compositionend_HostBindingHandler","NgxMaskDirective_blur_HostBindingHandler","NgxMaskDirective_click_HostBindingHandler","NgxMaskDirective_keydown_HostBindingHandler","inputs","outputs","exportAs","features","ɵɵProvidersFeature","useExisting","ɵɵNgOnChangesFeature","args","selector","standalone","providers","NgxMaskPipe","defaultOptions","transform","config","currentConfig","Object","entries","forEach","maskParts","NgxMaskPipe_Factory","ɵpipe","ɵɵdefinePipe","pure"],"sources":["/home/danilo/Área de trabalho/formsync-nx/apps/front/node_modules/ngx-mask/fesm2022/ngx-mask.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, inject, Injectable, ElementRef, Renderer2, makeEnvironmentProviders, input, output, signal, HostListener, Directive, Pipe } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';\n\nvar MaskExpression;\n(function (MaskExpression) {\n    MaskExpression[\"SEPARATOR\"] = \"separator\";\n    MaskExpression[\"PERCENT\"] = \"percent\";\n    MaskExpression[\"IP\"] = \"IP\";\n    MaskExpression[\"CPF_CNPJ\"] = \"CPF_CNPJ\";\n    MaskExpression[\"MONTH\"] = \"M\";\n    MaskExpression[\"MONTHS\"] = \"M0\";\n    MaskExpression[\"MINUTE\"] = \"m\";\n    MaskExpression[\"HOUR\"] = \"h\";\n    MaskExpression[\"HOURS\"] = \"H\";\n    MaskExpression[\"MINUTES\"] = \"m0\";\n    MaskExpression[\"HOURS_HOUR\"] = \"Hh\";\n    MaskExpression[\"SECONDS\"] = \"s0\";\n    MaskExpression[\"HOURS_MINUTES_SECONDS\"] = \"Hh:m0:s0\";\n    MaskExpression[\"EMAIL_MASK\"] = \"A*@A*.A*\";\n    MaskExpression[\"HOURS_MINUTES\"] = \"Hh:m0\";\n    MaskExpression[\"MINUTES_SECONDS\"] = \"m0:s0\";\n    MaskExpression[\"DAYS_MONTHS_YEARS\"] = \"d0/M0/0000\";\n    MaskExpression[\"DAYS_MONTHS\"] = \"d0/M0\";\n    MaskExpression[\"DAYS\"] = \"d0\";\n    MaskExpression[\"DAY\"] = \"d\";\n    MaskExpression[\"SECOND\"] = \"s\";\n    MaskExpression[\"LETTER_S\"] = \"S\";\n    MaskExpression[\"DOT\"] = \".\";\n    MaskExpression[\"COMMA\"] = \",\";\n    MaskExpression[\"CURLY_BRACKETS_LEFT\"] = \"{\";\n    MaskExpression[\"CURLY_BRACKETS_RIGHT\"] = \"}\";\n    MaskExpression[\"MINUS\"] = \"-\";\n    MaskExpression[\"OR\"] = \"||\";\n    MaskExpression[\"HASH\"] = \"#\";\n    MaskExpression[\"EMPTY_STRING\"] = \"\";\n    MaskExpression[\"SYMBOL_STAR\"] = \"*\";\n    MaskExpression[\"SYMBOL_QUESTION\"] = \"?\";\n    MaskExpression[\"SLASH\"] = \"/\";\n    MaskExpression[\"WHITE_SPACE\"] = \" \";\n    MaskExpression[\"NUMBER_ZERO\"] = \"0\";\n    MaskExpression[\"NUMBER_NINE\"] = \"9\";\n    MaskExpression[\"BACKSPACE\"] = \"Backspace\";\n    MaskExpression[\"DELETE\"] = \"Delete\";\n    MaskExpression[\"ARROW_LEFT\"] = \"ArrowLeft\";\n    MaskExpression[\"ARROW_UP\"] = \"ArrowUp\";\n    MaskExpression[\"DOUBLE_ZERO\"] = \"00\";\n})(MaskExpression || (MaskExpression = {}));\n\nconst NGX_MASK_CONFIG = new InjectionToken('ngx-mask config');\nconst NEW_CONFIG = new InjectionToken('new ngx-mask config');\nconst INITIAL_CONFIG = new InjectionToken('initial ngx-mask config');\nconst initialConfig = {\n    suffix: '',\n    prefix: '',\n    thousandSeparator: ' ',\n    decimalMarker: ['.', ','],\n    clearIfNotMatch: false,\n    showMaskTyped: false,\n    instantPrefix: false,\n    placeHolderCharacter: '_',\n    dropSpecialCharacters: true,\n    hiddenInput: false,\n    shownMaskExpression: '',\n    separatorLimit: '',\n    allowNegativeNumbers: false,\n    validation: true,\n    specialCharacters: ['-', '/', '(', ')', '.', ':', ' ', '+', ',', '@', '[', ']', '\"', \"'\"],\n    leadZeroDateTime: false,\n    apm: false,\n    leadZero: false,\n    keepCharacterPositions: false,\n    triggerOnMaskChange: false,\n    inputTransformFn: (value) => value,\n    outputTransformFn: (value) => value,\n    maskFilled: new EventEmitter(),\n    patterns: {\n        '0': {\n            pattern: new RegExp('\\\\d'),\n        },\n        '9': {\n            pattern: new RegExp('\\\\d'),\n            optional: true,\n        },\n        X: {\n            pattern: new RegExp('\\\\d'),\n            symbol: '*',\n        },\n        A: {\n            pattern: new RegExp('[a-zA-Z0-9]'),\n        },\n        S: {\n            pattern: new RegExp('[a-zA-Z]'),\n        },\n        U: {\n            pattern: new RegExp('[A-Z]'),\n        },\n        L: {\n            pattern: new RegExp('[a-z]'),\n        },\n        d: {\n            pattern: new RegExp('\\\\d'),\n        },\n        m: {\n            pattern: new RegExp('\\\\d'),\n        },\n        M: {\n            pattern: new RegExp('\\\\d'),\n        },\n        H: {\n            pattern: new RegExp('\\\\d'),\n        },\n        h: {\n            pattern: new RegExp('\\\\d'),\n        },\n        s: {\n            pattern: new RegExp('\\\\d'),\n        },\n    },\n};\nconst timeMasks = [\n    MaskExpression.HOURS_MINUTES_SECONDS,\n    MaskExpression.HOURS_MINUTES,\n    MaskExpression.MINUTES_SECONDS,\n];\nconst withoutValidation = [\n    MaskExpression.PERCENT,\n    MaskExpression.HOURS_HOUR,\n    MaskExpression.SECONDS,\n    MaskExpression.MINUTES,\n    MaskExpression.SEPARATOR,\n    MaskExpression.DAYS_MONTHS_YEARS,\n    MaskExpression.DAYS_MONTHS,\n    MaskExpression.DAYS,\n    MaskExpression.MONTHS,\n];\n\nclass NgxMaskApplierService {\n    _config = inject(NGX_MASK_CONFIG);\n    dropSpecialCharacters = this._config.dropSpecialCharacters;\n    hiddenInput = this._config.hiddenInput;\n    clearIfNotMatch = this._config.clearIfNotMatch;\n    specialCharacters = this._config.specialCharacters;\n    patterns = this._config.patterns;\n    prefix = this._config.prefix;\n    suffix = this._config.suffix;\n    thousandSeparator = this._config.thousandSeparator;\n    decimalMarker = this._config.decimalMarker;\n    customPattern;\n    showMaskTyped = this._config.showMaskTyped;\n    placeHolderCharacter = this._config.placeHolderCharacter;\n    validation = this._config.validation;\n    separatorLimit = this._config.separatorLimit;\n    allowNegativeNumbers = this._config.allowNegativeNumbers;\n    leadZeroDateTime = this._config.leadZeroDateTime;\n    leadZero = this._config.leadZero;\n    apm = this._config.apm;\n    inputTransformFn = this._config.inputTransformFn;\n    outputTransformFn = this._config.outputTransformFn;\n    keepCharacterPositions = this._config.keepCharacterPositions;\n    instantPrefix = this._config.instantPrefix;\n    triggerOnMaskChange = this._config.triggerOnMaskChange;\n    _shift = new Set();\n    plusOnePosition = false;\n    maskExpression = '';\n    actualValue = '';\n    showKeepCharacterExp = '';\n    shownMaskExpression = this._config.shownMaskExpression;\n    deletedSpecialCharacter = false;\n    ipError;\n    cpfCnpjError;\n    applyMask(inputValue, maskExpression, position = 0, justPasted = false, backspaced = false, \n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    cb = () => { }) {\n        if (!maskExpression || typeof inputValue !== 'string') {\n            return MaskExpression.EMPTY_STRING;\n        }\n        let cursor = 0;\n        let result = '';\n        let multi = false;\n        let backspaceShift = false;\n        let shift = 1;\n        let stepBack = false;\n        let processedValue = inputValue;\n        let processedPosition = position;\n        const startsWithPrefix = processedValue.slice(0, this.prefix.length) === this.prefix;\n        const pastedFullWithPrefix = justPasted && processedValue.length === this.prefix.length + maskExpression.length;\n        const looksLikeFullPrefixPaste = processedValue === this.prefix + processedValue.slice(this.prefix.length);\n        if (startsWithPrefix && (pastedFullWithPrefix || looksLikeFullPrefixPaste)) {\n            processedValue = processedValue.slice(this.prefix.length);\n        }\n        if (!!this.suffix && processedValue.length > 0) {\n            processedValue = this.checkAndRemoveSuffix(processedValue);\n        }\n        if (processedValue === '(' && this.prefix) {\n            processedValue = '';\n        }\n        const inputArray = processedValue.toString().split(MaskExpression.EMPTY_STRING);\n        if (this.allowNegativeNumbers &&\n            processedValue.slice(cursor, cursor + 1) === MaskExpression.MINUS) {\n            result += processedValue.slice(cursor, cursor + 1);\n        }\n        if (maskExpression === MaskExpression.IP) {\n            const valuesIP = processedValue.split(MaskExpression.DOT);\n            this.ipError = this._validIP(valuesIP);\n            // eslint-disable-next-line no-param-reassign\n            maskExpression = '099.099.099.099';\n        }\n        const arr = [];\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < processedValue.length; i++) {\n            if (processedValue[i]?.match('\\\\d')) {\n                arr.push(processedValue[i] ?? MaskExpression.EMPTY_STRING);\n            }\n        }\n        if (maskExpression === MaskExpression.CPF_CNPJ) {\n            this.cpfCnpjError = arr.length !== 11 && arr.length !== 14;\n            if (arr.length > 11) {\n                // eslint-disable-next-line no-param-reassign\n                maskExpression = '00.000.000/0000-00';\n            }\n            else {\n                // eslint-disable-next-line no-param-reassign\n                maskExpression = '000.000.000-00';\n            }\n        }\n        if (maskExpression.startsWith(MaskExpression.PERCENT)) {\n            if (processedValue.match('[a-z]|[A-Z]') ||\n                // eslint-disable-next-line no-useless-escape\n                (processedValue.match(/[-!$%^&*()_+|~=`{}\\[\\]:\";'<>?,\\/.]/) && !backspaced)) {\n                processedValue = this._stripToDecimal(processedValue);\n                const precision = this.getPrecision(maskExpression);\n                processedValue = this.checkInputPrecision(processedValue, precision, this.decimalMarker);\n            }\n            const decimalMarker = typeof this.decimalMarker === 'string' ? this.decimalMarker : MaskExpression.DOT;\n            if (processedValue.indexOf(decimalMarker) > 0 &&\n                !this.percentage(processedValue.substring(0, processedValue.indexOf(decimalMarker)))) {\n                let base = processedValue.substring(0, processedValue.indexOf(decimalMarker) - 1);\n                if (this.allowNegativeNumbers &&\n                    processedValue.slice(cursor, cursor + 1) === MaskExpression.MINUS &&\n                    !backspaced) {\n                    base = processedValue.substring(0, processedValue.indexOf(decimalMarker));\n                }\n                processedValue = `${base}${processedValue.substring(processedValue.indexOf(decimalMarker), processedValue.length)}`;\n            }\n            let value = '';\n            // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n            this.allowNegativeNumbers &&\n                processedValue.slice(cursor, cursor + 1) === MaskExpression.MINUS\n                ? (value = `${MaskExpression.MINUS}${processedValue.slice(cursor + 1, cursor + processedValue.length)}`)\n                : (value = processedValue);\n            if (this.percentage(value)) {\n                result = this._splitPercentZero(processedValue);\n            }\n            else {\n                result = this._splitPercentZero(processedValue.substring(0, processedValue.length - 1));\n            }\n        }\n        else if (maskExpression.startsWith(MaskExpression.SEPARATOR)) {\n            if (processedValue.match('[wа-яА-Я]') ||\n                processedValue.match('[ЁёА-я]') ||\n                processedValue.match('[a-z]|[A-Z]') ||\n                processedValue.match(/[-@#!$%\\\\^&*()_£¬'+|~=`{}\\]:\";<>.?/]/) ||\n                processedValue.match('[^A-Za-z0-9,]')) {\n                processedValue = this._stripToDecimal(processedValue);\n            }\n            const precision = this.getPrecision(maskExpression);\n            let decimalMarker = this.decimalMarker;\n            if (Array.isArray(this.decimalMarker)) {\n                if (this.actualValue.includes(this.decimalMarker[0]) ||\n                    this.actualValue.includes(this.decimalMarker[1])) {\n                    decimalMarker = this.actualValue.includes(this.decimalMarker[0])\n                        ? this.decimalMarker[0]\n                        : this.decimalMarker[1];\n                }\n                else {\n                    decimalMarker = this.decimalMarker.find((dm) => dm !== this.thousandSeparator);\n                }\n            }\n            if (backspaced) {\n                const { decimalMarkerIndex, nonZeroIndex } = this._findFirstNonZeroAndDecimalIndex(processedValue, decimalMarker);\n                const zeroIndexMinus = processedValue[0] === MaskExpression.MINUS;\n                const zeroIndexNumberZero = processedValue[0] === MaskExpression.NUMBER_ZERO;\n                const zeroIndexDecimalMarker = processedValue[0] === decimalMarker;\n                const firstIndexDecimalMarker = processedValue[1] === decimalMarker;\n                if ((zeroIndexDecimalMarker && !nonZeroIndex) ||\n                    (zeroIndexMinus && firstIndexDecimalMarker && !nonZeroIndex) ||\n                    (zeroIndexNumberZero && !decimalMarkerIndex && !nonZeroIndex)) {\n                    processedValue = MaskExpression.NUMBER_ZERO;\n                }\n                if (decimalMarkerIndex &&\n                    nonZeroIndex &&\n                    zeroIndexMinus &&\n                    processedPosition === 1) {\n                    if (decimalMarkerIndex < nonZeroIndex || decimalMarkerIndex > nonZeroIndex) {\n                        processedValue = MaskExpression.MINUS + processedValue.slice(nonZeroIndex);\n                    }\n                }\n                if (!decimalMarkerIndex && nonZeroIndex && processedValue.length > nonZeroIndex) {\n                    processedValue = zeroIndexMinus\n                        ? MaskExpression.MINUS + processedValue.slice(nonZeroIndex)\n                        : processedValue.slice(nonZeroIndex);\n                }\n                if (decimalMarkerIndex && nonZeroIndex && processedPosition === 0) {\n                    if (decimalMarkerIndex < nonZeroIndex) {\n                        processedValue = processedValue.slice(decimalMarkerIndex - 1);\n                    }\n                    if (decimalMarkerIndex > nonZeroIndex) {\n                        processedValue = processedValue.slice(nonZeroIndex);\n                    }\n                }\n            }\n            if (precision === 0) {\n                processedValue = this.allowNegativeNumbers\n                    ? processedValue.length > 2 &&\n                        processedValue[0] === MaskExpression.MINUS &&\n                        processedValue[1] === MaskExpression.NUMBER_ZERO &&\n                        processedValue[2] !== this.thousandSeparator &&\n                        processedValue[2] !== MaskExpression.COMMA &&\n                        processedValue[2] !== MaskExpression.DOT\n                        ? '-' + processedValue.slice(2, processedValue.length)\n                        : processedValue[0] === MaskExpression.NUMBER_ZERO &&\n                            processedValue.length > 1 &&\n                            processedValue[1] !== this.thousandSeparator &&\n                            processedValue[1] !== MaskExpression.COMMA &&\n                            processedValue[1] !== MaskExpression.DOT\n                            ? processedValue.slice(1, processedValue.length)\n                            : processedValue\n                    : processedValue.length > 1 &&\n                        processedValue[0] === MaskExpression.NUMBER_ZERO &&\n                        processedValue[1] !== this.thousandSeparator &&\n                        processedValue[1] !== MaskExpression.COMMA &&\n                        processedValue[1] !== MaskExpression.DOT\n                        ? processedValue.slice(1, processedValue.length)\n                        : processedValue;\n            }\n            else {\n                if (processedValue[0] === decimalMarker &&\n                    processedValue.length > 1 &&\n                    !backspaced) {\n                    processedValue =\n                        MaskExpression.NUMBER_ZERO +\n                            processedValue.slice(0, processedValue.length + 1);\n                    this.plusOnePosition = true;\n                }\n                if (processedValue[0] === MaskExpression.NUMBER_ZERO &&\n                    processedValue[1] !== decimalMarker &&\n                    processedValue[1] !== this.thousandSeparator &&\n                    !backspaced) {\n                    processedValue =\n                        processedValue.length > 1\n                            ? processedValue.slice(0, 1) +\n                                decimalMarker +\n                                processedValue.slice(1, processedValue.length + 1)\n                            : processedValue;\n                    this.plusOnePosition = true;\n                }\n                if (this.allowNegativeNumbers &&\n                    !backspaced &&\n                    processedValue[0] === MaskExpression.MINUS &&\n                    (processedValue[1] === decimalMarker ||\n                        processedValue[1] === MaskExpression.NUMBER_ZERO)) {\n                    processedValue =\n                        processedValue[1] === decimalMarker && processedValue.length > 2\n                            ? processedValue.slice(0, 1) +\n                                MaskExpression.NUMBER_ZERO +\n                                processedValue.slice(1, processedValue.length)\n                            : processedValue[1] === MaskExpression.NUMBER_ZERO &&\n                                processedValue.length > 2 &&\n                                processedValue[2] !== decimalMarker\n                                ? processedValue.slice(0, 2) +\n                                    decimalMarker +\n                                    processedValue.slice(2, processedValue.length)\n                                : processedValue;\n                    this.plusOnePosition = true;\n                }\n            }\n            // TODO: we had different rexexps here for the different cases... but tests dont seam to bother - check this\n            //  separator: no COMMA, dot-sep: no SPACE, COMMA OK, comma-sep: no SPACE, COMMA OK\n            const thousandSeparatorCharEscaped = this._charToRegExpExpression(this.thousandSeparator);\n            let invalidChars = '@#!$%^&*()_+|~=`{}\\\\[\\\\]:\\\\s,\\\\.\";<>?\\\\/'.replace(thousandSeparatorCharEscaped, '');\n            //.replace(decimalMarkerEscaped, '');\n            if (Array.isArray(this.decimalMarker)) {\n                for (const marker of this.decimalMarker) {\n                    invalidChars = invalidChars.replace(this._charToRegExpExpression(marker), MaskExpression.EMPTY_STRING);\n                }\n            }\n            else {\n                invalidChars = invalidChars.replace(this._charToRegExpExpression(this.decimalMarker), '');\n            }\n            const invalidCharRegexp = new RegExp('[' + invalidChars + ']');\n            if (processedValue.match(invalidCharRegexp)) {\n                processedValue = processedValue.substring(0, processedValue.length - 1);\n            }\n            processedValue = this.checkInputPrecision(processedValue, precision, this.decimalMarker);\n            const strForSep = processedValue.replace(new RegExp(thousandSeparatorCharEscaped, 'g'), '');\n            result = this._formatWithSeparators(strForSep, this.thousandSeparator, this.decimalMarker, precision);\n            const commaShift = result.indexOf(MaskExpression.COMMA) - processedValue.indexOf(MaskExpression.COMMA);\n            const shiftStep = result.length - processedValue.length;\n            const backspacedDecimalMarkerWithSeparatorLimit = backspaced &&\n                result.length < inputValue.length - this.suffix.length &&\n                this.separatorLimit;\n            if ((result[processedPosition - 1] === this.thousandSeparator ||\n                result[processedPosition - this.prefix.length]) &&\n                this.prefix &&\n                backspaced) {\n                processedPosition = processedPosition - 1;\n            }\n            else if ((shiftStep > 0 && result[processedPosition] !== this.thousandSeparator) ||\n                backspacedDecimalMarkerWithSeparatorLimit) {\n                backspaceShift = true;\n                let _shift = 0;\n                do {\n                    this._shift.add(processedPosition + _shift);\n                    _shift++;\n                } while (_shift < shiftStep);\n            }\n            else if (result[processedPosition - 1] === this.thousandSeparator ||\n                shiftStep === -4 ||\n                shiftStep === -3 ||\n                result[processedPosition] === this.thousandSeparator) {\n                this._shift.clear();\n                this._shift.add(processedPosition - 1);\n            }\n            else if ((commaShift !== 0 &&\n                processedPosition > 0 &&\n                !(result.indexOf(MaskExpression.COMMA) >= processedPosition &&\n                    processedPosition > 3)) ||\n                (!(result.indexOf(MaskExpression.DOT) >= processedPosition && processedPosition > 3) &&\n                    shiftStep <= 0)) {\n                this._shift.clear();\n                backspaceShift = true;\n                shift = shiftStep;\n                processedPosition += shiftStep;\n                this._shift.add(processedPosition);\n            }\n            else {\n                this._shift.clear();\n            }\n        }\n        else {\n            for (\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            let i = 0, inputSymbol = inputArray[0]; i < inputArray.length; i++, inputSymbol = inputArray[i] ?? MaskExpression.EMPTY_STRING) {\n                if (cursor === maskExpression.length) {\n                    break;\n                }\n                const symbolStarInPattern = MaskExpression.SYMBOL_STAR in this.patterns;\n                if (this._checkSymbolMask(inputSymbol, maskExpression[cursor] ?? MaskExpression.EMPTY_STRING) &&\n                    maskExpression[cursor + 1] === MaskExpression.SYMBOL_QUESTION) {\n                    result += inputSymbol;\n                    cursor += 2;\n                }\n                else if (maskExpression[cursor + 1] === MaskExpression.SYMBOL_STAR &&\n                    multi &&\n                    this._checkSymbolMask(inputSymbol, maskExpression[cursor + 2] ?? MaskExpression.EMPTY_STRING)) {\n                    result += inputSymbol;\n                    cursor += 3;\n                    multi = false;\n                }\n                else if (this._checkSymbolMask(inputSymbol, maskExpression[cursor] ?? MaskExpression.EMPTY_STRING) &&\n                    maskExpression[cursor + 1] === MaskExpression.SYMBOL_STAR &&\n                    !symbolStarInPattern) {\n                    result += inputSymbol;\n                    multi = true;\n                }\n                else if (maskExpression[cursor + 1] === MaskExpression.SYMBOL_QUESTION &&\n                    this._checkSymbolMask(inputSymbol, maskExpression[cursor + 2] ?? MaskExpression.EMPTY_STRING)) {\n                    result += inputSymbol;\n                    cursor += 3;\n                }\n                else if (this._checkSymbolMask(inputSymbol, maskExpression[cursor] ?? MaskExpression.EMPTY_STRING)) {\n                    if (maskExpression[cursor] === MaskExpression.HOURS) {\n                        if (this.apm ? Number(inputSymbol) > 9 : Number(inputSymbol) > 2) {\n                            processedPosition = !this.leadZeroDateTime\n                                ? processedPosition + 1\n                                : processedPosition;\n                            cursor += 1;\n                            this._shiftStep(cursor);\n                            i--;\n                            if (this.leadZeroDateTime) {\n                                result += '0';\n                            }\n                            continue;\n                        }\n                    }\n                    if (maskExpression[cursor] === MaskExpression.HOUR) {\n                        if (this.apm\n                            ? (result.length === 1 && Number(result) > 1) ||\n                                (result === '1' && Number(inputSymbol) > 2) ||\n                                (processedValue.slice(cursor - 1, cursor).length === 1 &&\n                                    Number(processedValue.slice(cursor - 1, cursor)) > 2) ||\n                                (processedValue.slice(cursor - 1, cursor) === '1' &&\n                                    Number(inputSymbol) > 2)\n                            : (result === '2' && Number(inputSymbol) > 3) ||\n                                ((result.slice(cursor - 2, cursor) === '2' ||\n                                    result.slice(cursor - 3, cursor) === '2' ||\n                                    result.slice(cursor - 4, cursor) === '2' ||\n                                    result.slice(cursor - 1, cursor) === '2') &&\n                                    Number(inputSymbol) > 3 &&\n                                    cursor > 10)) {\n                            processedPosition = processedPosition + 1;\n                            cursor += 1;\n                            i--;\n                            continue;\n                        }\n                    }\n                    if (maskExpression[cursor] === MaskExpression.MINUTE ||\n                        maskExpression[cursor] === MaskExpression.SECOND) {\n                        if (Number(inputSymbol) > 5) {\n                            processedPosition = !this.leadZeroDateTime\n                                ? processedPosition + 1\n                                : processedPosition;\n                            cursor += 1;\n                            this._shiftStep(cursor);\n                            i--;\n                            if (this.leadZeroDateTime) {\n                                result += '0';\n                            }\n                            continue;\n                        }\n                    }\n                    const daysCount = 31;\n                    const inputValueCursor = processedValue[cursor];\n                    const inputValueCursorPlusOne = processedValue[cursor + 1];\n                    const inputValueCursorPlusTwo = processedValue[cursor + 2];\n                    const inputValueCursorMinusOne = processedValue[cursor - 1];\n                    const inputValueCursorMinusTwo = processedValue[cursor - 2];\n                    const inputValueSliceMinusThreeMinusOne = processedValue.slice(cursor - 3, cursor - 1);\n                    const inputValueSliceMinusOnePlusOne = processedValue.slice(cursor - 1, cursor + 1);\n                    const inputValueSliceCursorPlusTwo = processedValue.slice(cursor, cursor + 2);\n                    const inputValueSliceMinusTwoCursor = processedValue.slice(cursor - 2, cursor);\n                    if (maskExpression[cursor] === MaskExpression.DAY) {\n                        const maskStartWithMonth = maskExpression.slice(0, 2) === MaskExpression.MONTHS;\n                        const startWithMonthInput = maskExpression.slice(0, 2) === MaskExpression.MONTHS &&\n                            this.specialCharacters.includes(inputValueCursorMinusTwo);\n                        if ((Number(inputSymbol) > 3 && this.leadZeroDateTime) ||\n                            (!maskStartWithMonth &&\n                                (Number(inputValueSliceCursorPlusTwo) > daysCount ||\n                                    Number(inputValueSliceMinusOnePlusOne) > daysCount ||\n                                    this.specialCharacters.includes(inputValueCursorPlusOne))) ||\n                            (startWithMonthInput\n                                ? Number(inputValueSliceMinusOnePlusOne) > daysCount ||\n                                    (!this.specialCharacters.includes(inputValueCursor) &&\n                                        this.specialCharacters.includes(inputValueCursorPlusTwo)) ||\n                                    this.specialCharacters.includes(inputValueCursor)\n                                : Number(inputValueSliceCursorPlusTwo) > daysCount ||\n                                    (this.specialCharacters.includes(inputValueCursorPlusOne) &&\n                                        !backspaced))) {\n                            processedPosition = !this.leadZeroDateTime\n                                ? processedPosition + 1\n                                : processedPosition;\n                            cursor += 1;\n                            this._shiftStep(cursor);\n                            i--;\n                            if (this.leadZeroDateTime) {\n                                result += '0';\n                            }\n                            continue;\n                        }\n                    }\n                    if (maskExpression[cursor] === MaskExpression.MONTH) {\n                        const monthsCount = 12;\n                        // mask without day\n                        const withoutDays = cursor === 0 &&\n                            (Number(inputSymbol) > 2 ||\n                                Number(inputValueSliceCursorPlusTwo) > monthsCount ||\n                                (this.specialCharacters.includes(inputValueCursorPlusOne) &&\n                                    !backspaced));\n                        // day<10 && month<12 for input\n                        const specialChart = maskExpression.slice(cursor + 2, cursor + 3);\n                        const day1monthInput = inputValueSliceMinusThreeMinusOne.includes(specialChart) &&\n                            maskExpression.includes('d0') &&\n                            ((this.specialCharacters.includes(inputValueCursorMinusTwo) &&\n                                Number(inputValueSliceMinusOnePlusOne) > monthsCount &&\n                                !this.specialCharacters.includes(inputValueCursor)) ||\n                                this.specialCharacters.includes(inputValueCursor));\n                        //  month<12 && day<10 for input\n                        const day2monthInput = Number(inputValueSliceMinusThreeMinusOne) <= daysCount &&\n                            !this.specialCharacters.includes(inputValueSliceMinusThreeMinusOne) &&\n                            this.specialCharacters.includes(inputValueCursorMinusOne) &&\n                            (Number(inputValueSliceCursorPlusTwo) > monthsCount ||\n                                this.specialCharacters.includes(inputValueCursorPlusOne));\n                        // cursor === 5 && without days\n                        const day2monthInputDot = (Number(inputValueSliceCursorPlusTwo) > monthsCount && cursor === 5) ||\n                            (this.specialCharacters.includes(inputValueCursorPlusOne) &&\n                                cursor === 5);\n                        // // day<10 && month<12 for paste whole data\n                        const day1monthPaste = Number(inputValueSliceMinusThreeMinusOne) > daysCount &&\n                            !this.specialCharacters.includes(inputValueSliceMinusThreeMinusOne) &&\n                            !this.specialCharacters.includes(inputValueSliceMinusTwoCursor) &&\n                            Number(inputValueSliceMinusTwoCursor) > monthsCount &&\n                            maskExpression.includes('d0');\n                        // 10<day<31 && month<12 for paste whole data\n                        const day2monthPaste = Number(inputValueSliceMinusThreeMinusOne) <= daysCount &&\n                            !this.specialCharacters.includes(inputValueSliceMinusThreeMinusOne) &&\n                            !this.specialCharacters.includes(inputValueCursorMinusOne) &&\n                            Number(inputValueSliceMinusOnePlusOne) > monthsCount;\n                        if ((Number(inputSymbol) > 1 && this.leadZeroDateTime) ||\n                            withoutDays ||\n                            day1monthInput ||\n                            day2monthPaste ||\n                            day1monthPaste ||\n                            day2monthInput ||\n                            (day2monthInputDot && !this.leadZeroDateTime)) {\n                            processedPosition = !this.leadZeroDateTime\n                                ? processedPosition + 1\n                                : processedPosition;\n                            cursor += 1;\n                            this._shiftStep(cursor);\n                            i--;\n                            if (this.leadZeroDateTime) {\n                                result += '0';\n                            }\n                            continue;\n                        }\n                    }\n                    result += inputSymbol;\n                    cursor++;\n                }\n                else if (this.specialCharacters.includes(inputSymbol) &&\n                    maskExpression[cursor] === inputSymbol) {\n                    result += inputSymbol;\n                    cursor++;\n                }\n                else if (this.specialCharacters.indexOf(maskExpression[cursor] ?? MaskExpression.EMPTY_STRING) !== -1) {\n                    result += maskExpression[cursor];\n                    cursor++;\n                    this._shiftStep(cursor);\n                    i--;\n                }\n                else if (maskExpression[cursor] === MaskExpression.NUMBER_NINE &&\n                    this.showMaskTyped) {\n                    this._shiftStep(cursor);\n                }\n                else if (this.patterns[maskExpression[cursor] ?? MaskExpression.EMPTY_STRING] &&\n                    this.patterns[maskExpression[cursor] ?? MaskExpression.EMPTY_STRING]?.optional) {\n                    if (!!inputArray[cursor] &&\n                        maskExpression !== '099.099.099.099' &&\n                        maskExpression !== '000.000.000-00' &&\n                        maskExpression !== '00.000.000/0000-00' &&\n                        !maskExpression.match(/^9+\\.0+$/) &&\n                        !this.patterns[maskExpression[cursor] ?? MaskExpression.EMPTY_STRING]\n                            ?.optional) {\n                        result += inputArray[cursor];\n                    }\n                    if (maskExpression.includes(MaskExpression.NUMBER_NINE + MaskExpression.SYMBOL_STAR) &&\n                        maskExpression.includes(MaskExpression.NUMBER_ZERO + MaskExpression.SYMBOL_STAR)) {\n                        cursor++;\n                    }\n                    cursor++;\n                    i--;\n                }\n                else if (this.maskExpression[cursor + 1] === MaskExpression.SYMBOL_STAR &&\n                    this._findSpecialChar(this.maskExpression[cursor + 2] ?? MaskExpression.EMPTY_STRING) &&\n                    this._findSpecialChar(inputSymbol) === this.maskExpression[cursor + 2] &&\n                    multi) {\n                    cursor += 3;\n                    result += inputSymbol;\n                }\n                else if (this.maskExpression[cursor + 1] === MaskExpression.SYMBOL_QUESTION &&\n                    this._findSpecialChar(this.maskExpression[cursor + 2] ?? MaskExpression.EMPTY_STRING) &&\n                    this._findSpecialChar(inputSymbol) === this.maskExpression[cursor + 2] &&\n                    multi) {\n                    cursor += 3;\n                    result += inputSymbol;\n                }\n                else if (this.showMaskTyped &&\n                    this.specialCharacters.indexOf(inputSymbol) < 0 &&\n                    inputSymbol !== this.placeHolderCharacter &&\n                    this.placeHolderCharacter.length === 1) {\n                    stepBack = true;\n                }\n            }\n        }\n        if (result[processedPosition - 1] &&\n            result.length + 1 === maskExpression.length &&\n            this.specialCharacters.indexOf(maskExpression[maskExpression.length - 1] ?? MaskExpression.EMPTY_STRING) !== -1) {\n            result += maskExpression[maskExpression.length - 1];\n        }\n        let newPosition = processedPosition + 1;\n        while (this._shift.has(newPosition)) {\n            shift++;\n            newPosition++;\n        }\n        let actualShift = justPasted && !maskExpression.startsWith(MaskExpression.SEPARATOR)\n            ? cursor\n            : this._shift.has(processedPosition)\n                ? shift\n                : 0;\n        if (stepBack) {\n            actualShift--;\n        }\n        cb(actualShift, backspaceShift);\n        if (shift < 0) {\n            this._shift.clear();\n        }\n        let onlySpecial = false;\n        if (backspaced) {\n            onlySpecial = inputArray.every((char) => this.specialCharacters.includes(char));\n        }\n        let res = `${this.prefix}${onlySpecial ? MaskExpression.EMPTY_STRING : result}${this.showMaskTyped ? '' : this.suffix}`;\n        if (result.length === 0) {\n            res = this.instantPrefix ? `${this.prefix}${result}` : `${result}`;\n        }\n        const isSpecialCharacterMaskFirstSymbol = processedValue.length === 1 &&\n            this.specialCharacters.includes(maskExpression[0]) &&\n            processedValue !== maskExpression[0];\n        if (!this._checkSymbolMask(processedValue, maskExpression[1]) &&\n            isSpecialCharacterMaskFirstSymbol) {\n            return '';\n        }\n        if (result.includes(MaskExpression.MINUS) && this.prefix && this.allowNegativeNumbers) {\n            if (backspaced && result === MaskExpression.MINUS) {\n                return '';\n            }\n            res = `${MaskExpression.MINUS}${this.prefix}${result\n                .split(MaskExpression.MINUS)\n                .join(MaskExpression.EMPTY_STRING)}${this.suffix}`;\n        }\n        return res;\n    }\n    _findDropSpecialChar(inputSymbol) {\n        if (Array.isArray(this.dropSpecialCharacters)) {\n            return this.dropSpecialCharacters.find((val) => val === inputSymbol);\n        }\n        return this._findSpecialChar(inputSymbol);\n    }\n    _findSpecialChar(inputSymbol) {\n        return this.specialCharacters.find((val) => val === inputSymbol);\n    }\n    _checkSymbolMask(inputSymbol, maskSymbol) {\n        this.patterns = this.customPattern ? this.customPattern : this.patterns;\n        return ((this.patterns[maskSymbol]?.pattern &&\n            this.patterns[maskSymbol]?.pattern.test(inputSymbol)) ??\n            false);\n    }\n    _formatWithSeparators = (str, thousandSeparatorChar, decimalChars, precision) => {\n        let x = [];\n        let decimalChar = '';\n        if (Array.isArray(decimalChars)) {\n            const regExp = new RegExp(decimalChars.map((v) => ('[\\\\^$.|?*+()'.indexOf(v) >= 0 ? `\\\\${v}` : v)).join('|'));\n            x = str.split(regExp);\n            decimalChar = str.match(regExp)?.[0] ?? MaskExpression.EMPTY_STRING;\n        }\n        else {\n            x = str.split(decimalChars);\n            decimalChar = decimalChars;\n        }\n        const decimals = x.length > 1 ? `${decimalChar}${x[1]}` : MaskExpression.EMPTY_STRING;\n        let res = x[0] ?? MaskExpression.EMPTY_STRING;\n        const separatorLimit = this.separatorLimit.replace(/\\s/g, MaskExpression.EMPTY_STRING);\n        if (separatorLimit && +separatorLimit) {\n            if (res[0] === MaskExpression.MINUS) {\n                res = `-${res.slice(1, res.length).slice(0, separatorLimit.length)}`;\n            }\n            else {\n                res = res.slice(0, separatorLimit.length);\n            }\n        }\n        const rgx = /(\\d+)(\\d{3})/;\n        while (thousandSeparatorChar && rgx.test(res)) {\n            res = res.replace(rgx, '$1' + thousandSeparatorChar + '$2');\n        }\n        if (typeof precision === 'undefined') {\n            return res + decimals;\n        }\n        else if (precision === 0) {\n            return res;\n        }\n        return res + decimals.substring(0, precision + 1);\n    };\n    percentage = (str) => {\n        const sanitizedStr = str.replace(',', '.');\n        const value = Number(this.allowNegativeNumbers && str.includes(MaskExpression.MINUS)\n            ? sanitizedStr.slice(1, str.length)\n            : sanitizedStr);\n        return !isNaN(value) && value >= 0 && value <= 100;\n    };\n    getPrecision = (maskExpression) => {\n        const x = maskExpression.split(MaskExpression.DOT);\n        if (x.length > 1) {\n            return Number(x[x.length - 1]);\n        }\n        return Infinity;\n    };\n    checkAndRemoveSuffix = (inputValue) => {\n        for (let i = this.suffix?.length - 1; i >= 0; i--) {\n            const substr = this.suffix.substring(i, this.suffix?.length);\n            if (inputValue.includes(substr) &&\n                i !== this.suffix?.length - 1 &&\n                (i - 1 < 0 ||\n                    !inputValue.includes(this.suffix.substring(i - 1, this.suffix?.length)))) {\n                return inputValue.replace(substr, MaskExpression.EMPTY_STRING);\n            }\n        }\n        return inputValue;\n    };\n    checkInputPrecision = (inputValue, precision, decimalMarker) => {\n        let processedInputValue = inputValue;\n        let processedDecimalMarker = decimalMarker;\n        if (precision < Infinity) {\n            // TODO need think about decimalMarker\n            if (Array.isArray(processedDecimalMarker)) {\n                const marker = processedDecimalMarker.find((dm) => dm !== this.thousandSeparator);\n                processedDecimalMarker = marker ? marker : processedDecimalMarker[0];\n            }\n            const precisionRegEx = new RegExp(this._charToRegExpExpression(processedDecimalMarker) + `\\\\d{${precision}}.*$`);\n            const precisionMatch = processedInputValue.match(precisionRegEx);\n            const precisionMatchLength = (precisionMatch && precisionMatch[0]?.length) ?? 0;\n            if (precisionMatchLength - 1 > precision) {\n                const diff = precisionMatchLength - 1 - precision;\n                processedInputValue = processedInputValue.substring(0, processedInputValue.length - diff);\n            }\n            if (precision === 0 &&\n                this._compareOrIncludes(processedInputValue[processedInputValue.length - 1], processedDecimalMarker, this.thousandSeparator)) {\n                processedInputValue = processedInputValue.substring(0, processedInputValue.length - 1);\n            }\n        }\n        return processedInputValue;\n    };\n    _stripToDecimal(str) {\n        return str\n            .split(MaskExpression.EMPTY_STRING)\n            .filter((i, idx) => {\n            const isDecimalMarker = typeof this.decimalMarker === 'string'\n                ? i === this.decimalMarker\n                : // TODO (inepipenko) use utility type\n                    this.decimalMarker.includes(i);\n            return (i.match('^-?\\\\d') ||\n                i === this.thousandSeparator ||\n                isDecimalMarker ||\n                (i === MaskExpression.MINUS && idx === 0 && this.allowNegativeNumbers));\n        })\n            .join(MaskExpression.EMPTY_STRING);\n    }\n    _charToRegExpExpression(char) {\n        // if (Array.isArray(char)) {\n        // \treturn char.map((v) => ('[\\\\^$.|?*+()'.indexOf(v) >= 0 ? `\\\\${v}` : v)).join('|');\n        // }\n        if (char) {\n            const charsToEscape = '[\\\\^$.|?*+()';\n            return char === ' ' ? '\\\\s' : charsToEscape.indexOf(char) >= 0 ? `\\\\${char}` : char;\n        }\n        return char;\n    }\n    _shiftStep(cursor) {\n        this._shift.add(cursor + this.prefix.length || 0);\n    }\n    _compareOrIncludes(value, comparedValue, excludedValue) {\n        return Array.isArray(comparedValue)\n            ? comparedValue.filter((v) => v !== excludedValue).includes(value)\n            : value === comparedValue;\n    }\n    _validIP(valuesIP) {\n        return !(valuesIP.length === 4 &&\n            !valuesIP.some((value, index) => {\n                if (valuesIP.length !== index + 1) {\n                    return value === MaskExpression.EMPTY_STRING || Number(value) > 255;\n                }\n                return value === MaskExpression.EMPTY_STRING || Number(value.substring(0, 3)) > 255;\n            }));\n    }\n    _splitPercentZero(value) {\n        if (value === MaskExpression.MINUS && this.allowNegativeNumbers) {\n            return value;\n        }\n        const decimalIndex = typeof this.decimalMarker === 'string'\n            ? value.indexOf(this.decimalMarker)\n            : value.indexOf(MaskExpression.DOT);\n        const emptyOrMinus = this.allowNegativeNumbers && value.includes(MaskExpression.MINUS) ? '-' : '';\n        if (decimalIndex === -1) {\n            const parsedValue = parseInt(emptyOrMinus ? value.slice(1, value.length) : value, 10);\n            return isNaN(parsedValue)\n                ? MaskExpression.EMPTY_STRING\n                : `${emptyOrMinus}${parsedValue}`;\n        }\n        else {\n            const integerPart = parseInt(value.replace('-', '').substring(0, decimalIndex), 10);\n            const decimalPart = value.substring(decimalIndex + 1);\n            const integerString = isNaN(integerPart) ? '' : integerPart.toString();\n            const decimal = typeof this.decimalMarker === 'string' ? this.decimalMarker : MaskExpression.DOT;\n            return integerString === MaskExpression.EMPTY_STRING\n                ? MaskExpression.EMPTY_STRING\n                : `${emptyOrMinus}${integerString}${decimal}${decimalPart}`;\n        }\n    }\n    _findFirstNonZeroAndDecimalIndex(inputString, decimalMarker) {\n        let decimalMarkerIndex = null;\n        let nonZeroIndex = null;\n        for (let i = 0; i < inputString.length; i++) {\n            const char = inputString[i];\n            if (char === decimalMarker && decimalMarkerIndex === null) {\n                decimalMarkerIndex = i;\n            }\n            if (char && char >= '1' && char <= '9' && nonZeroIndex === null) {\n                nonZeroIndex = i;\n            }\n            if (decimalMarkerIndex !== null && nonZeroIndex !== null) {\n                break;\n            }\n        }\n        return {\n            decimalMarkerIndex,\n            nonZeroIndex,\n        };\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.2\", ngImport: i0, type: NgxMaskApplierService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.2\", ngImport: i0, type: NgxMaskApplierService });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.2\", ngImport: i0, type: NgxMaskApplierService, decorators: [{\n            type: Injectable\n        }] });\n\nclass NgxMaskService extends NgxMaskApplierService {\n    isNumberValue = false;\n    maskIsShown = '';\n    selStart = null;\n    selEnd = null;\n    maskChanged = false;\n    maskExpressionArray = [];\n    previousValue = '';\n    currentValue = '';\n    /**\n     * Whether we are currently in writeValue function, in this case when applying the mask we don't want to trigger onChange function,\n     * since writeValue should be a one way only process of writing the DOM value based on the Angular model value.\n     */\n    writingValue = false;\n    isInitialized = false;\n    _emitValue = false;\n    _start;\n    _end;\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onChange = (_) => { };\n    _elementRef = inject(ElementRef, { optional: true });\n    document = inject(DOCUMENT);\n    _config = inject(NGX_MASK_CONFIG);\n    _renderer = inject(Renderer2, { optional: true });\n    /**\n     * Applies the mask to the input value.\n     * @param inputValue The input value to be masked.\n     * @param maskExpression The mask expression to apply.\n     * @param position The position in the input value.\n     * @param justPasted Whether the value was just pasted.\n     * @param backspaced Whether the value was backspaced.\n     * @param cb Callback function.\n     * @returns The masked value.\n     */\n    applyMask(inputValue, maskExpression, position = 0, justPasted = false, backspaced = false, \n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    cb = () => { }) {\n        // If no mask expression, return the input value or the actual value\n        if (!maskExpression) {\n            return inputValue !== this.actualValue ? this.actualValue : inputValue;\n        }\n        // Show mask in input if required\n        this.maskIsShown = this.showMaskTyped\n            ? this.showMaskInInput()\n            : MaskExpression.EMPTY_STRING;\n        // Handle specific mask expressions\n        if (this.maskExpression === MaskExpression.IP && this.showMaskTyped) {\n            this.maskIsShown = this.showMaskInInput(inputValue || MaskExpression.HASH);\n        }\n        if (this.maskExpression === MaskExpression.CPF_CNPJ && this.showMaskTyped) {\n            this.maskIsShown = this.showMaskInInput(inputValue || MaskExpression.HASH);\n        }\n        // Handle empty input value with mask typed\n        if (!inputValue && this.showMaskTyped) {\n            this.formControlResult(this.prefix);\n            return `${this.prefix}${this.maskIsShown}${this.suffix}`;\n        }\n        const getSymbol = !!inputValue && typeof this.selStart === 'number'\n            ? (inputValue[this.selStart] ?? MaskExpression.EMPTY_STRING)\n            : MaskExpression.EMPTY_STRING;\n        let newInputValue = '';\n        let newPosition = position;\n        // Handle hidden input or input with asterisk symbol\n        if ((this.hiddenInput ||\n            (inputValue && inputValue.indexOf(MaskExpression.SYMBOL_STAR) >= 0)) &&\n            !this.writingValue) {\n            let actualResult = inputValue && inputValue.length === 1\n                ? inputValue.split(MaskExpression.EMPTY_STRING)\n                : this.actualValue.split(MaskExpression.EMPTY_STRING);\n            // Handle backspace\n            if (backspaced) {\n                actualResult = actualResult\n                    .slice(0, position)\n                    .concat(actualResult.slice(position + 1));\n            }\n            // Remove mask if showMaskTyped is true\n            if (this.showMaskTyped) {\n                // eslint-disable-next-line no-param-reassign\n                inputValue = this.removeMask(inputValue);\n                actualResult = this.removeMask(actualResult.join('')).split(MaskExpression.EMPTY_STRING);\n            }\n            // Handle selection start and end\n            if (typeof this.selStart === 'object' && typeof this.selEnd === 'object') {\n                this.selStart = Number(this.selStart);\n                this.selEnd = Number(this.selEnd);\n            }\n            else {\n                if (inputValue !== MaskExpression.EMPTY_STRING && actualResult.length) {\n                    if (typeof this.selStart === 'number' && typeof this.selEnd === 'number') {\n                        if (inputValue.length > actualResult.length) {\n                            actualResult.splice(this.selStart, 0, getSymbol);\n                        }\n                        else if (inputValue.length < actualResult.length) {\n                            if (actualResult.length - inputValue.length === 1) {\n                                if (backspaced) {\n                                    actualResult.splice(this.selStart - 1, 1);\n                                }\n                                else {\n                                    actualResult.splice(inputValue.length - 1, 1);\n                                }\n                            }\n                            else {\n                                actualResult.splice(this.selStart, this.selEnd - this.selStart);\n                            }\n                        }\n                    }\n                }\n                else {\n                    actualResult = [];\n                }\n            }\n            // Remove mask if showMaskTyped is true and hiddenInput is false\n            if (this.showMaskTyped && !this.hiddenInput) {\n                newInputValue = this.removeMask(inputValue);\n            }\n            // Handle actual value length\n            if (this.actualValue.length) {\n                if (actualResult.length < inputValue.length) {\n                    newInputValue = this.shiftTypedSymbols(actualResult.join(MaskExpression.EMPTY_STRING));\n                }\n                else if (actualResult.length === inputValue.length) {\n                    newInputValue = actualResult.join(MaskExpression.EMPTY_STRING);\n                }\n                else {\n                    newInputValue = inputValue;\n                }\n            }\n            else {\n                newInputValue = inputValue;\n            }\n        }\n        // Handle just pasted input\n        if (justPasted && (this.hiddenInput || !this.hiddenInput)) {\n            newInputValue = inputValue;\n        }\n        // Handle backspace with special characters\n        if (backspaced &&\n            this.specialCharacters.indexOf(this.maskExpression[newPosition] ?? MaskExpression.EMPTY_STRING) !== -1 &&\n            this.showMaskTyped &&\n            !this.prefix) {\n            newInputValue = this.currentValue;\n        }\n        // Handle deleted special character\n        if (this.deletedSpecialCharacter && newPosition) {\n            if (this.specialCharacters.includes(this.actualValue.slice(newPosition, newPosition + 1))) {\n                newPosition = newPosition + 1;\n            }\n            else if (maskExpression.slice(newPosition - 1, newPosition + 1) !== MaskExpression.MONTHS) {\n                newPosition = newPosition - 2;\n            }\n            this.deletedSpecialCharacter = false;\n        }\n        // Remove mask if showMaskTyped is true and placeHolderCharacter length is 1\n        if (this.showMaskTyped &&\n            this.placeHolderCharacter.length === 1 &&\n            !this.leadZeroDateTime) {\n            newInputValue = this.removeMask(newInputValue);\n        }\n        // Handle mask changed\n        if (this.maskChanged) {\n            newInputValue = inputValue;\n        }\n        else {\n            newInputValue =\n                Boolean(newInputValue) && newInputValue.length ? newInputValue : inputValue;\n        }\n        // Handle showMaskTyped and keepCharacterPositions\n        if (this.showMaskTyped &&\n            this.keepCharacterPositions &&\n            this.actualValue &&\n            !justPasted &&\n            !this.writingValue) {\n            const value = this.dropSpecialCharacters\n                ? this.removeMask(this.actualValue)\n                : this.actualValue;\n            this.formControlResult(value);\n            return this.actualValue\n                ? this.actualValue\n                : `${this.prefix}${this.maskIsShown}${this.suffix}`;\n        }\n        // Apply the mask using the parent class method\n        const result = super.applyMask(newInputValue, maskExpression, newPosition, justPasted, backspaced, cb);\n        this.actualValue = this.getActualValue(result);\n        // handle some separator implications:\n        // a.) adjust decimalMarker default (. -> ,) if thousandSeparator is a dot\n        if (this.thousandSeparator === MaskExpression.DOT &&\n            this.decimalMarker === MaskExpression.DOT) {\n            this.decimalMarker = MaskExpression.COMMA;\n        }\n        // b) remove decimal marker from list of special characters to mask\n        if (this.maskExpression.startsWith(MaskExpression.SEPARATOR) &&\n            this.dropSpecialCharacters === true) {\n            this.specialCharacters = this.specialCharacters.filter((item) => !this._compareOrIncludes(item, this.decimalMarker, this.thousandSeparator) //item !== this.decimalMarker, // !\n            );\n        }\n        // Update previous and current values\n        if (result || result === '') {\n            this.previousValue = this.currentValue;\n            this.currentValue = result;\n            this._emitValue =\n                this.previousValue !== this.currentValue ||\n                    (this.previousValue === this.currentValue && justPasted);\n        }\n        // Propagate the input value back to the Angular model\n        // eslint-disable-next-line no-unused-expressions,@typescript-eslint/no-unused-expressions\n        this._emitValue ? this.formControlResult(result) : '';\n        // Handle hidden input and showMaskTyped\n        if (!this.showMaskTyped || (this.showMaskTyped && this.hiddenInput)) {\n            if (this.hiddenInput) {\n                return `${this.hideInput(result, this.maskExpression)}${this.maskIsShown.slice(result.length)}`;\n            }\n            return result;\n        }\n        const resLen = result.length;\n        const prefNmask = `${this.prefix}${this.maskIsShown}${this.suffix}`;\n        // Handle specific mask expressions\n        if (this.maskExpression.includes(MaskExpression.HOURS)) {\n            const countSkipedSymbol = this._numberSkipedSymbols(result);\n            return `${result}${prefNmask.slice(resLen + countSkipedSymbol)}`;\n        }\n        else if (this.maskExpression === MaskExpression.IP ||\n            this.maskExpression === MaskExpression.CPF_CNPJ) {\n            return `${result}${prefNmask}`;\n        }\n        return `${result}${prefNmask.slice(resLen)}`;\n    }\n    // get the number of characters that were shifted\n    _numberSkipedSymbols(value) {\n        const regex = /(^|\\D)(\\d\\D)/g;\n        let match = regex.exec(value);\n        let countSkipedSymbol = 0;\n        while (match != null) {\n            countSkipedSymbol += 1;\n            match = regex.exec(value);\n        }\n        return countSkipedSymbol;\n    }\n    applyValueChanges(position, justPasted, backspaced, \n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    cb = () => { }) {\n        const formElement = this._elementRef?.nativeElement;\n        if (!formElement) {\n            return;\n        }\n        formElement.value = this.applyMask(formElement.value, this.maskExpression, position, justPasted, backspaced, cb);\n        if (formElement === this._getActiveElement()) {\n            return;\n        }\n        this.clearIfNotMatchFn();\n    }\n    hideInput(inputValue, maskExpression) {\n        return inputValue\n            .split(MaskExpression.EMPTY_STRING)\n            .map((curr, index) => {\n            if (this.patterns &&\n                this.patterns[maskExpression[index] ?? MaskExpression.EMPTY_STRING] &&\n                this.patterns[maskExpression[index] ?? MaskExpression.EMPTY_STRING]?.symbol) {\n                return this.patterns[maskExpression[index] ?? MaskExpression.EMPTY_STRING]\n                    ?.symbol;\n            }\n            return curr;\n        })\n            .join(MaskExpression.EMPTY_STRING);\n    }\n    // this function is not necessary, it checks result against maskExpression\n    getActualValue(res) {\n        const compare = res\n            .split(MaskExpression.EMPTY_STRING)\n            .filter((symbol, i) => {\n            const maskChar = this.maskExpression[i] ?? MaskExpression.EMPTY_STRING;\n            return (this._checkSymbolMask(symbol, maskChar) ||\n                (this.specialCharacters.includes(maskChar) && symbol === maskChar));\n        });\n        if (compare.join(MaskExpression.EMPTY_STRING) === res) {\n            return compare.join(MaskExpression.EMPTY_STRING);\n        }\n        return res;\n    }\n    shiftTypedSymbols(inputValue) {\n        let symbolToReplace = '';\n        const newInputValue = (inputValue &&\n            inputValue\n                .split(MaskExpression.EMPTY_STRING)\n                .map((currSymbol, index) => {\n                if (this.specialCharacters.includes(inputValue[index + 1] ?? MaskExpression.EMPTY_STRING) &&\n                    inputValue[index + 1] !== this.maskExpression[index + 1]) {\n                    symbolToReplace = currSymbol;\n                    return inputValue[index + 1];\n                }\n                if (symbolToReplace.length) {\n                    const replaceSymbol = symbolToReplace;\n                    symbolToReplace = MaskExpression.EMPTY_STRING;\n                    return replaceSymbol;\n                }\n                return currSymbol;\n            })) ||\n            [];\n        return newInputValue.join(MaskExpression.EMPTY_STRING);\n    }\n    /**\n     * Convert number value to string\n     * 3.1415 -> '3.1415'\n     * 1e-7 -> '0.0000001'\n     */\n    numberToString(value) {\n        if ((!value && value !== 0) ||\n            (this.maskExpression.startsWith(MaskExpression.SEPARATOR) &&\n                (this.leadZero || !this.dropSpecialCharacters)) ||\n            (this.maskExpression.startsWith(MaskExpression.SEPARATOR) &&\n                this.separatorLimit.length > 14 &&\n                String(value).length > 14)) {\n            return String(value);\n        }\n        return Number(value)\n            .toLocaleString('fullwide', {\n            useGrouping: false,\n            maximumFractionDigits: 20,\n        })\n            .replace(`/${MaskExpression.MINUS}/`, MaskExpression.MINUS);\n    }\n    showMaskInInput(inputVal) {\n        if (this.showMaskTyped && !!this.shownMaskExpression) {\n            if (this.maskExpression.length !== this.shownMaskExpression.length) {\n                throw new Error('Mask expression must match mask placeholder length');\n            }\n            else {\n                return this.shownMaskExpression;\n            }\n        }\n        else if (this.showMaskTyped) {\n            if (inputVal) {\n                if (this.maskExpression === MaskExpression.IP) {\n                    return this._checkForIp(inputVal);\n                }\n                if (this.maskExpression === MaskExpression.CPF_CNPJ) {\n                    return this._checkForCpfCnpj(inputVal);\n                }\n            }\n            if (this.placeHolderCharacter.length === this.maskExpression.length) {\n                return this.placeHolderCharacter;\n            }\n            return this.maskExpression.replace(/\\w/g, this.placeHolderCharacter);\n        }\n        return '';\n    }\n    clearIfNotMatchFn() {\n        const formElement = this._elementRef?.nativeElement;\n        if (!formElement) {\n            return;\n        }\n        if (this.clearIfNotMatch &&\n            this.prefix.length + this.maskExpression.length + this.suffix.length !==\n                formElement.value.replace(this.placeHolderCharacter, MaskExpression.EMPTY_STRING)\n                    .length) {\n            this.formElementProperty = ['value', MaskExpression.EMPTY_STRING];\n            this.applyMask('', this.maskExpression);\n        }\n    }\n    set formElementProperty([name, value]) {\n        if (!this._renderer || !this._elementRef) {\n            return;\n        }\n        //[TODO]: andriikamaldinov1 find better solution\n        Promise.resolve().then(() => this._renderer?.setProperty(this._elementRef?.nativeElement, name, value));\n    }\n    checkDropSpecialCharAmount(mask) {\n        const chars = mask\n            .split(MaskExpression.EMPTY_STRING)\n            .filter((item) => this._findDropSpecialChar(item));\n        return chars.length;\n    }\n    removeMask(inputValue) {\n        return this._removeMask(this._removeSuffix(this._removePrefix(inputValue)), this.specialCharacters.concat('_').concat(this.placeHolderCharacter));\n    }\n    _checkForIp(inputVal) {\n        if (inputVal === MaskExpression.HASH) {\n            return `${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n        }\n        const arr = [];\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < inputVal.length; i++) {\n            const value = inputVal[i] ?? MaskExpression.EMPTY_STRING;\n            if (!value) {\n                continue;\n            }\n            if (value.match('\\\\d')) {\n                arr.push(value);\n            }\n        }\n        if (arr.length <= 3) {\n            return `${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n        }\n        if (arr.length > 3 && arr.length <= 6) {\n            return `${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n        }\n        if (arr.length > 6 && arr.length <= 9) {\n            return this.placeHolderCharacter;\n        }\n        if (arr.length > 9 && arr.length <= 12) {\n            return '';\n        }\n        return '';\n    }\n    _checkForCpfCnpj(inputVal) {\n        const cpf = `${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n            `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n            `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n            `-${this.placeHolderCharacter}${this.placeHolderCharacter}`;\n        const cnpj = `${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n            `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n            `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n            `/${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` +\n            `-${this.placeHolderCharacter}${this.placeHolderCharacter}`;\n        if (inputVal === MaskExpression.HASH) {\n            return cpf;\n        }\n        const arr = [];\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < inputVal.length; i++) {\n            const value = inputVal[i] ?? MaskExpression.EMPTY_STRING;\n            if (!value) {\n                continue;\n            }\n            if (value.match('\\\\d')) {\n                arr.push(value);\n            }\n        }\n        if (arr.length <= 3) {\n            return cpf.slice(arr.length, cpf.length);\n        }\n        if (arr.length > 3 && arr.length <= 6) {\n            return cpf.slice(arr.length + 1, cpf.length);\n        }\n        if (arr.length > 6 && arr.length <= 9) {\n            return cpf.slice(arr.length + 2, cpf.length);\n        }\n        if (arr.length > 9 && arr.length < 11) {\n            return cpf.slice(arr.length + 3, cpf.length);\n        }\n        if (arr.length === 11) {\n            return '';\n        }\n        if (arr.length === 12) {\n            if (inputVal.length === 17) {\n                return cnpj.slice(16, cnpj.length);\n            }\n            return cnpj.slice(15, cnpj.length);\n        }\n        if (arr.length > 12 && arr.length <= 14) {\n            return cnpj.slice(arr.length + 4, cnpj.length);\n        }\n        return '';\n    }\n    /**\n     * Recursively determine the current active element by navigating the Shadow DOM until the Active Element is found.\n     */\n    _getActiveElement(document = this.document) {\n        const shadowRootEl = document?.activeElement?.shadowRoot;\n        if (!shadowRootEl?.activeElement) {\n            return document.activeElement;\n        }\n        else {\n            return this._getActiveElement(shadowRootEl);\n        }\n    }\n    /**\n     * Propogates the input value back to the Angular model by triggering the onChange function. It won't do this if writingValue\n     * is true. If that is true it means we are currently in the writeValue function, which is supposed to only update the actual\n     * DOM element based on the Angular model value. It should be a one way process, i.e. writeValue should not be modifying the Angular\n     * model value too. Therefore, we don't trigger onChange in this scenario.\n     * @param inputValue the current form input value\n     */\n    formControlResult(inputValue) {\n        const outputTransformFn = this.outputTransformFn\n            ? this.outputTransformFn\n            : (v) => v;\n        this.writingValue = false;\n        this.maskChanged = false;\n        if (!this.isInitialized && this._emitValue) {\n            return;\n        }\n        if (Array.isArray(this.dropSpecialCharacters)) {\n            this.onChange(outputTransformFn(this._toNumber(this._checkSymbols(this._removeMask(this._removeSuffix(this._removePrefix(inputValue)), this.dropSpecialCharacters)))));\n        }\n        else if (this.dropSpecialCharacters ||\n            (!this.dropSpecialCharacters && this.prefix === inputValue)) {\n            this.onChange(outputTransformFn(this._toNumber(this._checkSymbols(this._removeSuffix(this._removePrefix(inputValue))))));\n        }\n        else {\n            this.onChange(outputTransformFn(this._toNumber(inputValue)));\n        }\n    }\n    _toNumber(value) {\n        if (!this.isNumberValue || value === MaskExpression.EMPTY_STRING) {\n            return value;\n        }\n        if (this.maskExpression.startsWith(MaskExpression.SEPARATOR) &&\n            (this.leadZero || !this.dropSpecialCharacters)) {\n            return value;\n        }\n        if (String(value).length > 14 && this.maskExpression.startsWith(MaskExpression.SEPARATOR)) {\n            return String(value);\n        }\n        const num = Number(value);\n        if (this.maskExpression.startsWith(MaskExpression.SEPARATOR) && Number.isNaN(num)) {\n            const val = String(value).replace(',', '.');\n            return Number(val);\n        }\n        return Number.isNaN(num) ? value : num;\n    }\n    _removeMask(value, specialCharactersForRemove) {\n        if (this.maskExpression.startsWith(MaskExpression.PERCENT) &&\n            value.includes(MaskExpression.DOT)) {\n            return value;\n        }\n        return value\n            ? value.replace(this._regExpForRemove(specialCharactersForRemove), MaskExpression.EMPTY_STRING)\n            : value;\n    }\n    _removePrefix(value) {\n        if (!this.prefix) {\n            return value;\n        }\n        return value ? value.replace(this.prefix, MaskExpression.EMPTY_STRING) : value;\n    }\n    _removeSuffix(value) {\n        if (!this.suffix) {\n            return value;\n        }\n        return value ? value.replace(this.suffix, MaskExpression.EMPTY_STRING) : value;\n    }\n    _retrieveSeparatorValue(result) {\n        let specialCharacters = Array.isArray(this.dropSpecialCharacters)\n            ? this.specialCharacters.filter((v) => {\n                return this.dropSpecialCharacters.includes(v);\n            })\n            : this.specialCharacters;\n        if (!this.deletedSpecialCharacter &&\n            this._checkPatternForSpace() &&\n            result.includes(MaskExpression.WHITE_SPACE) &&\n            this.maskExpression.includes(MaskExpression.SYMBOL_STAR)) {\n            specialCharacters = specialCharacters.filter((char) => char !== MaskExpression.WHITE_SPACE);\n        }\n        return this._removeMask(result, specialCharacters);\n    }\n    _regExpForRemove(specialCharactersForRemove) {\n        return new RegExp(specialCharactersForRemove.map((item) => `\\\\${item}`).join('|'), 'gi');\n    }\n    _replaceDecimalMarkerToDot(value) {\n        const markers = Array.isArray(this.decimalMarker)\n            ? this.decimalMarker\n            : [this.decimalMarker];\n        return value.replace(this._regExpForRemove(markers), MaskExpression.DOT);\n    }\n    _checkSymbols(result) {\n        let processedResult = result;\n        if (processedResult === MaskExpression.EMPTY_STRING) {\n            return processedResult;\n        }\n        if (this.maskExpression.startsWith(MaskExpression.PERCENT) &&\n            this.decimalMarker === MaskExpression.COMMA) {\n            processedResult = processedResult.replace(MaskExpression.COMMA, MaskExpression.DOT);\n        }\n        const separatorPrecision = this._retrieveSeparatorPrecision(this.maskExpression);\n        const separatorValue = this.specialCharacters.length === 0\n            ? this._retrieveSeparatorValue(processedResult)\n            : this._replaceDecimalMarkerToDot(this._retrieveSeparatorValue(processedResult));\n        if (!this.isNumberValue) {\n            return separatorValue;\n        }\n        if (separatorPrecision) {\n            if (processedResult === this.decimalMarker) {\n                return null;\n            }\n            if (separatorValue.length > 14) {\n                return String(separatorValue);\n            }\n            return this._checkPrecision(this.maskExpression, separatorValue);\n        }\n        else {\n            return separatorValue;\n        }\n    }\n    _checkPatternForSpace() {\n        for (const key in this.patterns) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (this.patterns[key] && this.patterns[key]?.hasOwnProperty('pattern')) {\n                const patternString = this.patterns[key]?.pattern.toString();\n                const pattern = this.patterns[key]?.pattern;\n                if (patternString?.includes(MaskExpression.WHITE_SPACE) &&\n                    pattern?.test(this.maskExpression)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    // TODO should think about helpers or separting decimal precision to own property\n    _retrieveSeparatorPrecision(maskExpretion) {\n        const matcher = maskExpretion.match(new RegExp(`^separator\\\\.([^d]*)`));\n        return matcher ? Number(matcher[1]) : null;\n    }\n    _checkPrecision(separatorExpression, separatorValue) {\n        const separatorPrecision = this.getPrecision(separatorExpression);\n        let value = separatorValue;\n        if (separatorExpression.indexOf('2') > 0 ||\n            (this.leadZero && Number(separatorPrecision) > 0 && Number.isFinite(separatorPrecision))) {\n            if (this.decimalMarker === MaskExpression.COMMA && this.leadZero) {\n                value = value.replace(',', '.');\n            }\n            return this.leadZero\n                ? Number(value).toFixed(Number(separatorPrecision))\n                : Number(value).toFixed(2);\n        }\n        return this.numberToString(value);\n    }\n    _repeatPatternSymbols(maskExp) {\n        return ((maskExp.match(/{[0-9]+}/) &&\n            maskExp\n                .split(MaskExpression.EMPTY_STRING)\n                .reduce((accum, currVal, index) => {\n                this._start =\n                    currVal === MaskExpression.CURLY_BRACKETS_LEFT ? index : this._start;\n                if (currVal !== MaskExpression.CURLY_BRACKETS_RIGHT) {\n                    return this._findSpecialChar(currVal) ? accum + currVal : accum;\n                }\n                this._end = index;\n                const repeatNumber = Number(maskExp.slice(this._start + 1, this._end));\n                const replaceWith = new Array(repeatNumber + 1).join(maskExp[this._start - 1]);\n                if (maskExp.slice(0, this._start).length > 1 &&\n                    maskExp.includes(MaskExpression.LETTER_S)) {\n                    const symbols = maskExp.slice(0, this._start - 1);\n                    return symbols.includes(MaskExpression.CURLY_BRACKETS_LEFT)\n                        ? accum + replaceWith\n                        : symbols + accum + replaceWith;\n                }\n                else {\n                    return accum + replaceWith;\n                }\n            }, '')) ||\n            maskExp);\n    }\n    currentLocaleDecimalMarker() {\n        return (1.1).toLocaleString().substring(1, 2);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.2\", ngImport: i0, type: NgxMaskService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.2\", ngImport: i0, type: NgxMaskService });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.2\", ngImport: i0, type: NgxMaskService, decorators: [{\n            type: Injectable\n        }] });\n\n/**\n * @internal\n */\nfunction _configFactory() {\n    const initConfig = inject(INITIAL_CONFIG);\n    const configValue = inject(NEW_CONFIG);\n    return configValue instanceof Function\n        ? { ...initConfig, ...configValue() }\n        : { ...initConfig, ...configValue };\n}\nfunction provideNgxMask(configValue) {\n    return [\n        {\n            provide: NEW_CONFIG,\n            useValue: configValue,\n        },\n        {\n            provide: INITIAL_CONFIG,\n            useValue: initialConfig,\n        },\n        {\n            provide: NGX_MASK_CONFIG,\n            useFactory: _configFactory,\n        },\n        NgxMaskService,\n    ];\n}\nfunction provideEnvironmentNgxMask(configValue) {\n    return makeEnvironmentProviders(provideNgxMask(configValue));\n}\n\nclass NgxMaskDirective {\n    mask = input('', ...(ngDevMode ? [{ debugName: \"mask\" }] : []));\n    specialCharacters = input([], ...(ngDevMode ? [{ debugName: \"specialCharacters\" }] : []));\n    patterns = input({}, ...(ngDevMode ? [{ debugName: \"patterns\" }] : []));\n    prefix = input('', ...(ngDevMode ? [{ debugName: \"prefix\" }] : []));\n    suffix = input('', ...(ngDevMode ? [{ debugName: \"suffix\" }] : []));\n    thousandSeparator = input(' ', ...(ngDevMode ? [{ debugName: \"thousandSeparator\" }] : []));\n    decimalMarker = input('.', ...(ngDevMode ? [{ debugName: \"decimalMarker\" }] : []));\n    dropSpecialCharacters = input(null, ...(ngDevMode ? [{ debugName: \"dropSpecialCharacters\" }] : []));\n    hiddenInput = input(null, ...(ngDevMode ? [{ debugName: \"hiddenInput\" }] : []));\n    showMaskTyped = input(null, ...(ngDevMode ? [{ debugName: \"showMaskTyped\" }] : []));\n    placeHolderCharacter = input(null, ...(ngDevMode ? [{ debugName: \"placeHolderCharacter\" }] : []));\n    shownMaskExpression = input(null, ...(ngDevMode ? [{ debugName: \"shownMaskExpression\" }] : []));\n    clearIfNotMatch = input(null, ...(ngDevMode ? [{ debugName: \"clearIfNotMatch\" }] : []));\n    validation = input(null, ...(ngDevMode ? [{ debugName: \"validation\" }] : []));\n    separatorLimit = input('', ...(ngDevMode ? [{ debugName: \"separatorLimit\" }] : []));\n    allowNegativeNumbers = input(null, ...(ngDevMode ? [{ debugName: \"allowNegativeNumbers\" }] : []));\n    leadZeroDateTime = input(null, ...(ngDevMode ? [{ debugName: \"leadZeroDateTime\" }] : []));\n    leadZero = input(null, ...(ngDevMode ? [{ debugName: \"leadZero\" }] : []));\n    triggerOnMaskChange = input(null, ...(ngDevMode ? [{ debugName: \"triggerOnMaskChange\" }] : []));\n    apm = input(null, ...(ngDevMode ? [{ debugName: \"apm\" }] : []));\n    inputTransformFn = input(null, ...(ngDevMode ? [{ debugName: \"inputTransformFn\" }] : []));\n    outputTransformFn = input(null, ...(ngDevMode ? [{ debugName: \"outputTransformFn\" }] : []));\n    keepCharacterPositions = input(null, ...(ngDevMode ? [{ debugName: \"keepCharacterPositions\" }] : []));\n    instantPrefix = input(null, ...(ngDevMode ? [{ debugName: \"instantPrefix\" }] : []));\n    maskFilled = output();\n    _maskValue = signal('', ...(ngDevMode ? [{ debugName: \"_maskValue\" }] : []));\n    _inputValue = signal('', ...(ngDevMode ? [{ debugName: \"_inputValue\" }] : []));\n    _position = signal(null, ...(ngDevMode ? [{ debugName: \"_position\" }] : []));\n    _code = signal('', ...(ngDevMode ? [{ debugName: \"_code\" }] : []));\n    _maskExpressionArray = signal([], ...(ngDevMode ? [{ debugName: \"_maskExpressionArray\" }] : []));\n    _justPasted = signal(false, ...(ngDevMode ? [{ debugName: \"_justPasted\" }] : []));\n    _isFocused = signal(false, ...(ngDevMode ? [{ debugName: \"_isFocused\" }] : []));\n    /**For IME composition event */\n    _isComposing = signal(false, ...(ngDevMode ? [{ debugName: \"_isComposing\" }] : []));\n    _maskService = inject(NgxMaskService, { self: true });\n    document = inject(DOCUMENT);\n    _config = inject(NGX_MASK_CONFIG);\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onChange = (_) => { };\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onTouch = () => { };\n    ngOnChanges(changes) {\n        const { mask, specialCharacters, patterns, prefix, suffix, thousandSeparator, decimalMarker, dropSpecialCharacters, hiddenInput, showMaskTyped, placeHolderCharacter, shownMaskExpression, clearIfNotMatch, validation, separatorLimit, allowNegativeNumbers, leadZeroDateTime, leadZero, triggerOnMaskChange, apm, inputTransformFn, outputTransformFn, keepCharacterPositions, instantPrefix, } = changes;\n        if (mask) {\n            if (mask.currentValue !== mask.previousValue && !mask.firstChange) {\n                this._maskService.maskChanged = true;\n            }\n            if (mask.currentValue && mask.currentValue.split(MaskExpression.OR).length > 1) {\n                this._maskExpressionArray.set(mask.currentValue.split(MaskExpression.OR).sort((a, b) => {\n                    return a.length - b.length;\n                }));\n                this._setMask();\n            }\n            else {\n                this._maskExpressionArray.set([]);\n                this._maskValue.set(mask.currentValue || MaskExpression.EMPTY_STRING);\n                this._maskService.maskExpression = this._maskValue();\n            }\n        }\n        if (specialCharacters) {\n            if (!specialCharacters.currentValue || !Array.isArray(specialCharacters.currentValue)) {\n                return;\n            }\n            else {\n                this._maskService.specialCharacters = specialCharacters.currentValue || [];\n            }\n        }\n        if (allowNegativeNumbers) {\n            this._maskService.allowNegativeNumbers = allowNegativeNumbers.currentValue;\n            if (this._maskService.allowNegativeNumbers) {\n                this._maskService.specialCharacters = this._maskService.specialCharacters.filter((c) => c !== MaskExpression.MINUS);\n            }\n        }\n        // Only overwrite the mask available patterns if a pattern has actually been passed in\n        if (patterns && patterns.currentValue) {\n            this._maskService.patterns = patterns.currentValue;\n        }\n        if (apm && apm.currentValue) {\n            this._maskService.apm = apm.currentValue;\n        }\n        if (instantPrefix) {\n            this._maskService.instantPrefix = instantPrefix.currentValue;\n        }\n        if (prefix) {\n            this._maskService.prefix = prefix.currentValue;\n        }\n        if (suffix) {\n            this._maskService.suffix = suffix.currentValue;\n        }\n        if (thousandSeparator) {\n            this._maskService.thousandSeparator = thousandSeparator.currentValue;\n            if (thousandSeparator.previousValue && thousandSeparator.currentValue) {\n                const previousDecimalMarker = this._maskService.decimalMarker;\n                if (thousandSeparator.currentValue === this._maskService.decimalMarker) {\n                    this._maskService.decimalMarker =\n                        thousandSeparator.currentValue === MaskExpression.COMMA\n                            ? MaskExpression.DOT\n                            : MaskExpression.COMMA;\n                }\n                if (this._maskService.dropSpecialCharacters === true) {\n                    this._maskService.specialCharacters = this._config.specialCharacters;\n                }\n                if (typeof previousDecimalMarker === 'string' &&\n                    typeof this._maskService.decimalMarker === 'string') {\n                    this._inputValue.set(this._inputValue()\n                        .split(thousandSeparator.previousValue)\n                        .join('')\n                        .replace(previousDecimalMarker, this._maskService.decimalMarker));\n                    this._maskService.actualValue = this._inputValue();\n                }\n                this._maskService.writingValue = true;\n            }\n        }\n        if (decimalMarker) {\n            this._maskService.decimalMarker = decimalMarker.currentValue;\n        }\n        if (dropSpecialCharacters) {\n            this._maskService.dropSpecialCharacters = dropSpecialCharacters.currentValue;\n        }\n        if (hiddenInput) {\n            this._maskService.hiddenInput = hiddenInput.currentValue;\n            if (hiddenInput.previousValue === true && hiddenInput.currentValue === false) {\n                this._inputValue.set(this._maskService.actualValue);\n            }\n        }\n        if (showMaskTyped) {\n            this._maskService.showMaskTyped = showMaskTyped.currentValue;\n            if (showMaskTyped.previousValue === false &&\n                showMaskTyped.currentValue === true &&\n                this._isFocused()) {\n                requestAnimationFrame(() => {\n                    this._maskService._elementRef?.nativeElement.click();\n                });\n            }\n        }\n        if (placeHolderCharacter) {\n            this._maskService.placeHolderCharacter = placeHolderCharacter.currentValue;\n        }\n        if (shownMaskExpression) {\n            this._maskService.shownMaskExpression = shownMaskExpression.currentValue;\n        }\n        if (clearIfNotMatch) {\n            this._maskService.clearIfNotMatch = clearIfNotMatch.currentValue;\n        }\n        if (validation) {\n            this._maskService.validation = validation.currentValue;\n        }\n        if (separatorLimit) {\n            this._maskService.separatorLimit = separatorLimit.currentValue;\n        }\n        if (leadZeroDateTime) {\n            this._maskService.leadZeroDateTime = leadZeroDateTime.currentValue;\n        }\n        if (leadZero) {\n            this._maskService.leadZero = leadZero.currentValue;\n        }\n        if (triggerOnMaskChange) {\n            this._maskService.triggerOnMaskChange = triggerOnMaskChange.currentValue;\n        }\n        if (inputTransformFn) {\n            this._maskService.inputTransformFn = inputTransformFn.currentValue;\n        }\n        if (outputTransformFn) {\n            this._maskService.outputTransformFn = outputTransformFn.currentValue;\n        }\n        if (keepCharacterPositions) {\n            this._maskService.keepCharacterPositions = keepCharacterPositions.currentValue;\n        }\n        this._applyMask();\n    }\n    validate({ value }) {\n        const processedValue = typeof value === 'number' ? String(value) : value;\n        const maskValue = this._maskValue();\n        if (!this._maskService.validation || !maskValue) {\n            return null;\n        }\n        if (this._maskService.ipError) {\n            return this._createValidationError(processedValue);\n        }\n        if (this._maskService.cpfCnpjError) {\n            return this._createValidationError(processedValue);\n        }\n        if (maskValue.startsWith(MaskExpression.SEPARATOR)) {\n            return null;\n        }\n        if (withoutValidation.includes(maskValue)) {\n            return null;\n        }\n        if (this._maskService.clearIfNotMatch) {\n            return null;\n        }\n        if (timeMasks.includes(maskValue)) {\n            return this._validateTime(processedValue);\n        }\n        if (maskValue === MaskExpression.EMAIL_MASK) {\n            const emailPattern = /^[^@]+@[^@]+\\.[^@]+$/;\n            if (!emailPattern.test(processedValue) && processedValue) {\n                return this._createValidationError(processedValue);\n            }\n            else {\n                return null;\n            }\n        }\n        if (processedValue && processedValue.length >= 1) {\n            let counterOfOpt = 0;\n            if (maskValue.includes(MaskExpression.CURLY_BRACKETS_LEFT) &&\n                maskValue.includes(MaskExpression.CURLY_BRACKETS_RIGHT)) {\n                const lengthInsideCurlyBrackets = maskValue.slice(maskValue.indexOf(MaskExpression.CURLY_BRACKETS_LEFT) + 1, maskValue.indexOf(MaskExpression.CURLY_BRACKETS_RIGHT));\n                return lengthInsideCurlyBrackets === String(processedValue.length)\n                    ? null\n                    : this._createValidationError(processedValue);\n            }\n            if (maskValue.startsWith(MaskExpression.PERCENT)) {\n                return null;\n            }\n            for (const key in this._maskService.patterns) {\n                if (this._maskService.patterns[key]?.optional) {\n                    if (maskValue.indexOf(key) !== maskValue.lastIndexOf(key)) {\n                        const opt = maskValue\n                            .split(MaskExpression.EMPTY_STRING)\n                            .filter((i) => i === key)\n                            .join(MaskExpression.EMPTY_STRING);\n                        counterOfOpt += opt.length;\n                    }\n                    else if (maskValue.indexOf(key) !== -1) {\n                        counterOfOpt++;\n                    }\n                    if (maskValue.indexOf(key) !== -1 &&\n                        processedValue.length >= maskValue.indexOf(key)) {\n                        return null;\n                    }\n                    if (counterOfOpt === maskValue.length) {\n                        return null;\n                    }\n                }\n            }\n            if ((maskValue.indexOf(MaskExpression.SYMBOL_STAR) > 1 &&\n                processedValue.length < maskValue.indexOf(MaskExpression.SYMBOL_STAR)) ||\n                (maskValue.indexOf(MaskExpression.SYMBOL_QUESTION) > 1 &&\n                    processedValue.length < maskValue.indexOf(MaskExpression.SYMBOL_QUESTION))) {\n                return this._createValidationError(processedValue);\n            }\n            if (maskValue.indexOf(MaskExpression.SYMBOL_STAR) === -1 ||\n                maskValue.indexOf(MaskExpression.SYMBOL_QUESTION) === -1) {\n                const array = maskValue.split('*');\n                const length = this._maskService.dropSpecialCharacters\n                    ? maskValue.length -\n                        this._maskService.checkDropSpecialCharAmount(maskValue) -\n                        counterOfOpt\n                    : this.prefix()\n                        ? maskValue.length + this.prefix().length - counterOfOpt\n                        : maskValue.length - counterOfOpt;\n                if (array.length === 1) {\n                    if (processedValue.length < length) {\n                        return this._createValidationError(processedValue);\n                    }\n                }\n                if (array.length > 1) {\n                    const lastIndexArray = array[array.length - 1];\n                    if (lastIndexArray &&\n                        this._maskService.specialCharacters.includes(lastIndexArray[0]) &&\n                        String(processedValue).includes(lastIndexArray[0] ?? '') &&\n                        !this.dropSpecialCharacters()) {\n                        const special = value.split(lastIndexArray[0]);\n                        return special[special.length - 1].length === lastIndexArray.length - 1\n                            ? null\n                            : this._createValidationError(processedValue);\n                    }\n                    else if (((lastIndexArray &&\n                        !this._maskService.specialCharacters.includes(lastIndexArray[0])) ||\n                        !lastIndexArray ||\n                        this._maskService.dropSpecialCharacters) &&\n                        processedValue.length >= length - 1) {\n                        return null;\n                    }\n                    else {\n                        return this._createValidationError(processedValue);\n                    }\n                }\n            }\n            if (maskValue.indexOf(MaskExpression.SYMBOL_STAR) === 1 ||\n                maskValue.indexOf(MaskExpression.SYMBOL_QUESTION) === 1) {\n                return null;\n            }\n        }\n        if (value) {\n            this.maskFilled.emit();\n            return null;\n        }\n        return null;\n    }\n    onPaste() {\n        this._justPasted.set(true);\n    }\n    onFocus() {\n        this._isFocused.set(true);\n    }\n    onModelChange(value) {\n        // on form reset we need to update the actualValue\n        if ((value === MaskExpression.EMPTY_STRING ||\n            value === null ||\n            typeof value === 'undefined') &&\n            this._maskService.actualValue) {\n            this._maskService.actualValue = this._maskService.getActualValue(MaskExpression.EMPTY_STRING);\n        }\n    }\n    onInput(e) {\n        this._maskService.isInitialized = true;\n        // If IME is composing text, we wait for the composed text.\n        if (this._isComposing()) {\n            return;\n        }\n        const el = e.target;\n        const transformedValue = this._maskService.inputTransformFn\n            ? this._maskService.inputTransformFn(el.value)\n            : el.value;\n        if (el.type !== 'number') {\n            if (typeof transformedValue === 'string' || typeof transformedValue === 'number') {\n                el.value = transformedValue.toString();\n                this._inputValue.set(el.value);\n                this._setMask();\n                if (!this._maskValue()) {\n                    this.onChange(el.value);\n                    return;\n                }\n                let position = el.selectionStart === 1\n                    ? el.selectionStart + this._maskService.prefix.length\n                    : el.selectionStart;\n                if (this.showMaskTyped() &&\n                    this.keepCharacterPositions() &&\n                    this._maskService.placeHolderCharacter.length === 1) {\n                    const suffix = this.suffix();\n                    const prefix = this.prefix();\n                    const inputSymbol = el.value.slice(position - 1, position);\n                    const prefixLength = prefix.length;\n                    const checkSymbols = this._maskService._checkSymbolMask(inputSymbol, this._maskService.maskExpression[position - 1 - prefixLength] ??\n                        MaskExpression.EMPTY_STRING);\n                    const checkSpecialCharacter = this._maskService._checkSymbolMask(inputSymbol, this._maskService.maskExpression[position + 1 - prefixLength] ??\n                        MaskExpression.EMPTY_STRING);\n                    const selectRangeBackspace = this._maskService.selStart === this._maskService.selEnd;\n                    const selStart = Number(this._maskService.selStart) - prefixLength;\n                    const selEnd = Number(this._maskService.selEnd) - prefixLength;\n                    const backspaceOrDelete = this._code() === MaskExpression.BACKSPACE ||\n                        this._code() === MaskExpression.DELETE;\n                    if (backspaceOrDelete) {\n                        if (!selectRangeBackspace) {\n                            if (this._maskService.selStart === prefixLength) {\n                                this._maskService.actualValue = `${prefix}${this._maskService.maskIsShown.slice(0, selEnd)}${this._inputValue().split(prefix).join('')}`;\n                            }\n                            else if (this._maskService.selStart ===\n                                this._maskService.maskIsShown.length + prefixLength) {\n                                this._maskService.actualValue = `${this._inputValue()}${this._maskService.maskIsShown.slice(selStart, selEnd)}`;\n                            }\n                            else {\n                                this._maskService.actualValue = `${prefix}${this._inputValue()\n                                    .split(prefix)\n                                    .join('')\n                                    .slice(0, selStart)}${this._maskService.maskIsShown.slice(selStart, selEnd)}${this._maskService.actualValue.slice(selEnd + prefixLength, this._maskService.maskIsShown.length + prefixLength)}${suffix}`;\n                            }\n                        }\n                        else if (!this._maskService.specialCharacters.includes(this._maskService.maskExpression.slice(position - prefixLength, position + 1 - prefixLength)) &&\n                            selectRangeBackspace) {\n                            if (selStart === 1 && prefix) {\n                                this._maskService.actualValue = `${prefix}${this._maskService.placeHolderCharacter}${el.value\n                                    .split(prefix)\n                                    .join('')\n                                    .split(suffix)\n                                    .join('')}${suffix}`;\n                                position = position - 1;\n                            }\n                            else {\n                                const part1 = el.value.substring(0, position);\n                                const part2 = el.value.substring(position);\n                                this._maskService.actualValue = `${part1}${this._maskService.placeHolderCharacter}${part2}`;\n                            }\n                        }\n                        position = this._code() === MaskExpression.DELETE ? position + 1 : position;\n                    }\n                    if (!backspaceOrDelete) {\n                        if (!checkSymbols && !checkSpecialCharacter && selectRangeBackspace) {\n                            position = Number(el.selectionStart) - 1;\n                        }\n                        else if (this._maskService.specialCharacters.includes(el.value.slice(position, position + 1)) &&\n                            checkSpecialCharacter &&\n                            !this._maskService.specialCharacters.includes(el.value.slice(position + 1, position + 2))) {\n                            this._maskService.actualValue = `${el.value.slice(0, position - 1)}${el.value.slice(position, position + 1)}${inputSymbol}${el.value.slice(position + 2)}`;\n                            position = position + 1;\n                        }\n                        else if (checkSymbols) {\n                            if (el.value.length === 1 && position === 1) {\n                                this._maskService.actualValue = `${prefix}${inputSymbol}${this._maskService.maskIsShown.slice(1, this._maskService.maskIsShown.length)}${suffix}`;\n                            }\n                            else {\n                                this._maskService.actualValue = `${el.value.slice(0, position - 1)}${inputSymbol}${el.value\n                                    .slice(position + 1)\n                                    .split(suffix)\n                                    .join('')}${suffix}`;\n                            }\n                        }\n                        else if (prefix &&\n                            el.value.length === 1 &&\n                            position - prefixLength === 1 &&\n                            this._maskService._checkSymbolMask(el.value, this._maskService.maskExpression[position - 1 - prefixLength] ??\n                                MaskExpression.EMPTY_STRING)) {\n                            this._maskService.actualValue = `${prefix}${el.value}${this._maskService.maskIsShown.slice(1, this._maskService.maskIsShown.length)}${suffix}`;\n                        }\n                    }\n                }\n                let caretShift = 0;\n                let backspaceShift = false;\n                if (this._code() === MaskExpression.DELETE && MaskExpression.SEPARATOR) {\n                    this._maskService.deletedSpecialCharacter = true;\n                }\n                if (this._inputValue().length >= this._maskService.maskExpression.length - 1 &&\n                    this._code() !== MaskExpression.BACKSPACE &&\n                    this._maskService.maskExpression === MaskExpression.DAYS_MONTHS_YEARS &&\n                    position < 10) {\n                    const inputSymbol = this._inputValue().slice(position - 1, position);\n                    el.value =\n                        this._inputValue().slice(0, position - 1) +\n                            inputSymbol +\n                            this._inputValue().slice(position + 1);\n                }\n                if (this._maskService.maskExpression === MaskExpression.DAYS_MONTHS_YEARS &&\n                    this.leadZeroDateTime()) {\n                    if ((position < 3 && Number(el.value) > 31 && Number(el.value) < 40) ||\n                        (position === 5 && Number(el.value.slice(3, 5)) > 12)) {\n                        position = position + 2;\n                    }\n                }\n                if (this._maskService.maskExpression === MaskExpression.HOURS_MINUTES_SECONDS &&\n                    this.apm()) {\n                    if (this._justPasted() && el.value.slice(0, 2) === MaskExpression.DOUBLE_ZERO) {\n                        el.value = el.value.slice(1, 2) + el.value.slice(2, el.value.length);\n                    }\n                    el.value =\n                        el.value === MaskExpression.DOUBLE_ZERO\n                            ? MaskExpression.NUMBER_ZERO\n                            : el.value;\n                }\n                this._maskService.applyValueChanges(position, this._justPasted(), this._code() === MaskExpression.BACKSPACE ||\n                    this._code() === MaskExpression.DELETE, (shift, _backspaceShift) => {\n                    this._justPasted.set(false);\n                    caretShift = shift;\n                    backspaceShift = _backspaceShift;\n                });\n                // only set the selection if the element is active\n                if (this._getActiveElement() !== el) {\n                    return;\n                }\n                if (this._maskService.plusOnePosition) {\n                    position = position + 1;\n                    this._maskService.plusOnePosition = false;\n                }\n                // update position after applyValueChanges to prevent cursor on wrong position when it has an array of maskExpression\n                if (this._maskExpressionArray().length) {\n                    if (this._code() === MaskExpression.BACKSPACE) {\n                        const specialChartMinusOne = this.specialCharacters().includes(this._maskService.actualValue.slice(position - 1, position));\n                        const allowFewMaskChangeMask = this._maskService.removeMask(this._inputValue())?.length ===\n                            this._maskService.removeMask(this._maskService.maskExpression)?.length;\n                        const specialChartPlusOne = this.specialCharacters().includes(this._maskService.actualValue.slice(position, position + 1));\n                        if (allowFewMaskChangeMask && !specialChartPlusOne) {\n                            position = el.selectionStart + 1;\n                        }\n                        else {\n                            position = specialChartMinusOne ? position - 1 : position;\n                        }\n                    }\n                    else {\n                        position =\n                            el.selectionStart === 1\n                                ? el.selectionStart + this._maskService.prefix.length\n                                : el.selectionStart;\n                    }\n                }\n                this._position.set(this._position() === 1 && this._inputValue().length === 1\n                    ? null\n                    : this._position());\n                let positionToApply = this._position()\n                    ? this._inputValue().length + position + caretShift\n                    : position +\n                        (this._code() === MaskExpression.BACKSPACE && !backspaceShift\n                            ? 0\n                            : caretShift);\n                if (positionToApply > this._getActualInputLength()) {\n                    positionToApply =\n                        el.value === this._maskService.decimalMarker && el.value.length === 1\n                            ? this._getActualInputLength() + 1\n                            : this._getActualInputLength();\n                }\n                if (positionToApply < 0) {\n                    positionToApply = 0;\n                }\n                el.setSelectionRange(positionToApply, positionToApply);\n                this._position.set(null);\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.warn('Ngx-mask writeValue work with string | number, your current value:', typeof transformedValue);\n            }\n        }\n        else {\n            if (!this._maskValue()) {\n                this.onChange(el.value);\n                return;\n            }\n            this._maskService.applyValueChanges(el.value.length, this._justPasted(), this._code() === MaskExpression.BACKSPACE || this._code() === MaskExpression.DELETE);\n        }\n    }\n    // IME starts\n    onCompositionStart() {\n        this._isComposing.set(true);\n    }\n    // IME completes\n    onCompositionEnd(e) {\n        this._isComposing.set(false);\n        this._justPasted.set(true);\n        this.onInput(e);\n    }\n    onBlur(e) {\n        if (this._maskValue()) {\n            const el = e.target;\n            if (this._maskService.leadZero &&\n                el.value.length > 0 &&\n                typeof this._maskService.decimalMarker === 'string') {\n                const maskExpression = this._maskService.maskExpression;\n                const decimalMarker = this._maskService.decimalMarker;\n                const suffix = this._maskService.suffix;\n                const precision = Number(this._maskService.maskExpression.slice(maskExpression.length - 1, maskExpression.length));\n                if (precision > 0) {\n                    el.value = suffix ? el.value.split(suffix).join('') : el.value;\n                    const decimalPart = el.value.split(decimalMarker)[1];\n                    el.value = el.value.includes(decimalMarker)\n                        ? el.value +\n                            MaskExpression.NUMBER_ZERO.repeat(precision - decimalPart.length) +\n                            suffix\n                        : el.value +\n                            decimalMarker +\n                            MaskExpression.NUMBER_ZERO.repeat(precision) +\n                            suffix;\n                    this._maskService.actualValue = el.value;\n                }\n            }\n            this._maskService.clearIfNotMatchFn();\n        }\n        this._isFocused.set(false);\n        this.onTouch();\n    }\n    onClick(e) {\n        if (!this._maskValue()) {\n            return;\n        }\n        const el = e.target;\n        const posStart = 0;\n        const posEnd = 0;\n        if (el !== null &&\n            el.selectionStart !== null &&\n            el.selectionStart === el.selectionEnd &&\n            el.selectionStart > this._maskService.prefix.length &&\n            e.keyCode !== 38) {\n            if (this._maskService.showMaskTyped && !this.keepCharacterPositions()) {\n                // We are showing the mask in the input\n                this._maskService.maskIsShown = this._maskService.showMaskInInput();\n                if (el.setSelectionRange &&\n                    this._maskService.prefix + this._maskService.maskIsShown === el.value) {\n                    // the input ONLY contains the mask, so position the cursor at the start\n                    el.focus();\n                    el.setSelectionRange(posStart, posEnd);\n                }\n                else {\n                    // the input contains some characters already\n                    if (el.selectionStart > this._maskService.actualValue.length) {\n                        // if the user clicked beyond our value's length, position the cursor at the end of our value\n                        el.setSelectionRange(this._maskService.actualValue.length, this._maskService.actualValue.length);\n                    }\n                }\n            }\n        }\n        const nextValue = el &&\n            (el.value === this._maskService.prefix\n                ? this._maskService.prefix + this._maskService.maskIsShown\n                : el.value);\n        /** Fix of cursor position jumping to end in most browsers no matter where cursor is inserted onFocus */\n        if (el && el.value !== nextValue) {\n            el.value = nextValue;\n        }\n        /** fix of cursor position with prefix when mouse click occur */\n        if (el &&\n            el.type !== 'number' &&\n            (el.selectionStart || el.selectionEnd) <=\n                this._maskService.prefix.length) {\n            const specialCharactersAtTheStart = this._maskService.maskExpression.match(new RegExp(`^[${this._maskService.specialCharacters.map((c) => `\\\\${c}`).join('')}]+`))?.[0].length || 0;\n            el.selectionStart = this._maskService.prefix.length + specialCharactersAtTheStart;\n            return;\n        }\n        /** select only inserted text */\n        if (el && el.selectionEnd > this._getActualInputLength()) {\n            el.selectionEnd = this._getActualInputLength();\n        }\n    }\n    onKeyDown(e) {\n        if (!this._maskValue()) {\n            return;\n        }\n        if (this._isComposing()) {\n            // User finalize their choice from IME composition, so trigger onInput() for the composed text.\n            if (e.key === 'Enter') {\n                this.onCompositionEnd(e);\n            }\n            return;\n        }\n        this._code.set(e.code ? e.code : e.key);\n        const el = e.target;\n        this._inputValue.set(el.value);\n        this._setMask();\n        const isTextarea = el.tagName.toLowerCase() === 'textarea';\n        if (el.type !== 'number') {\n            if (e.key === MaskExpression.ARROW_UP && !isTextarea) {\n                e.preventDefault();\n            }\n            if (e.key === MaskExpression.ARROW_LEFT ||\n                e.key === MaskExpression.BACKSPACE ||\n                e.key === MaskExpression.DELETE) {\n                if (e.key === MaskExpression.BACKSPACE && el.value.length === 0) {\n                    el.selectionStart = el.selectionEnd;\n                }\n                if (e.key === MaskExpression.BACKSPACE && el.selectionStart !== 0) {\n                    const prefixLength = this.prefix().length;\n                    // If specialChars is false, (shouldn't ever happen) then set to the defaults\n                    const specialCharacters = this.specialCharacters().length\n                        ? this.specialCharacters()\n                        : this._config.specialCharacters;\n                    if (prefixLength > 1 && el.selectionStart <= prefixLength) {\n                        el.setSelectionRange(prefixLength, el.selectionEnd);\n                    }\n                    else {\n                        if (this._inputValue().length !== el.selectionStart &&\n                            el.selectionStart !== 1) {\n                            while (specialCharacters.includes((this._inputValue()[el.selectionStart - 1] ??\n                                MaskExpression.EMPTY_STRING).toString()) &&\n                                ((prefixLength >= 1 &&\n                                    el.selectionStart > prefixLength) ||\n                                    prefixLength === 0)) {\n                                el.setSelectionRange(el.selectionStart - 1, el.selectionEnd);\n                            }\n                        }\n                    }\n                }\n                this.checkSelectionOnDeletion(el);\n                if (this._maskService.prefix.length &&\n                    el.selectionStart <= this._maskService.prefix.length &&\n                    el.selectionEnd <= this._maskService.prefix.length) {\n                    e.preventDefault();\n                }\n                const cursorStart = el.selectionStart;\n                if (e.key === MaskExpression.BACKSPACE &&\n                    !el.readOnly &&\n                    cursorStart === 0 &&\n                    el.selectionEnd === el.value.length &&\n                    el.value.length !== 0) {\n                    this._position.set(this._maskService.prefix ? this._maskService.prefix.length : 0);\n                    this._maskService.applyMask(this._maskService.prefix, this._maskService.maskExpression, this._position());\n                }\n            }\n            if (!!this.suffix() &&\n                this.suffix().length > 1 &&\n                this._inputValue().length - this.suffix().length < el.selectionStart) {\n                el.setSelectionRange(this._inputValue().length - this.suffix().length, this._inputValue().length);\n            }\n            else if ((e.code === 'KeyA' && e.ctrlKey) ||\n                (e.code === 'KeyA' && e.metaKey) // Cmd + A (Mac)\n            ) {\n                el.setSelectionRange(0, this._getActualInputLength());\n                e.preventDefault();\n            }\n            this._maskService.selStart = el.selectionStart;\n            this._maskService.selEnd = el.selectionEnd;\n        }\n    }\n    /** It writes the value in the input */\n    async writeValue(controlValue) {\n        let value = controlValue;\n        const inputTransformFn = this._maskService.inputTransformFn;\n        if (typeof value === 'object' && value !== null && 'value' in value) {\n            if ('disable' in value) {\n                this.setDisabledState(Boolean(value.disable));\n            }\n            value = value.value;\n        }\n        if (value !== null) {\n            value = inputTransformFn ? inputTransformFn(value) : value;\n        }\n        if (typeof value === 'string' ||\n            typeof value === 'number' ||\n            value === null ||\n            typeof value === 'undefined') {\n            if (value === null || typeof value === 'undefined' || value === '') {\n                this._maskService.currentValue = '';\n                this._maskService.previousValue = '';\n            }\n            let inputValue = value;\n            if (typeof inputValue === 'number' ||\n                this._maskValue().startsWith(MaskExpression.SEPARATOR)) {\n                inputValue = String(inputValue);\n                const localeDecimalMarker = this._maskService.currentLocaleDecimalMarker();\n                if (!Array.isArray(this._maskService.decimalMarker)) {\n                    inputValue =\n                        this._maskService.decimalMarker !== localeDecimalMarker\n                            ? inputValue.replace(localeDecimalMarker, this._maskService.decimalMarker)\n                            : inputValue;\n                }\n                if (this._maskService.leadZero &&\n                    inputValue &&\n                    this.mask() &&\n                    this.dropSpecialCharacters() !== false) {\n                    inputValue = this._maskService._checkPrecision(this._maskService.maskExpression, inputValue);\n                }\n                if (this._maskService.decimalMarker === MaskExpression.COMMA ||\n                    (Array.isArray(this._maskService.decimalMarker) &&\n                        this._maskService.thousandSeparator === MaskExpression.DOT)) {\n                    inputValue = inputValue\n                        .toString()\n                        .replace(MaskExpression.DOT, MaskExpression.COMMA);\n                }\n                if (this.mask()?.startsWith(MaskExpression.SEPARATOR) && this.leadZero()) {\n                    requestAnimationFrame(() => {\n                        this._maskService.applyMask(inputValue?.toString() ?? '', this._maskService.maskExpression);\n                    });\n                }\n                this._maskService.isNumberValue = true;\n            }\n            if (typeof inputValue !== 'string' || value === null || typeof value === 'undefined') {\n                inputValue = '';\n            }\n            this._inputValue.set(inputValue);\n            this._setMask();\n            if ((inputValue && this._maskService.maskExpression) ||\n                (this._maskService.maskExpression &&\n                    (this._maskService.prefix || this._maskService.showMaskTyped))) {\n                // Let the service we know we are writing value so that triggering onChange function won't happen during applyMask\n                this._maskService.writingValue = true;\n                this._maskService.formElementProperty = [\n                    'value',\n                    this._maskService.applyMask(inputValue, this._maskService.maskExpression),\n                ];\n                // Let the service know we've finished writing value\n                this._maskService.writingValue = false;\n                this._maskService.isInitialized = true;\n            }\n            else {\n                this._maskService.formElementProperty = ['value', inputValue];\n                this._maskService.isInitialized = true;\n            }\n            this._inputValue.set(inputValue);\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.warn('Ngx-mask writeValue work with string | number, your current value:', typeof value);\n        }\n    }\n    registerOnChange(fn) {\n        this._maskService.onChange = this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n        this.onTouch = fn;\n    }\n    _getActiveElement(document = this.document) {\n        const shadowRootEl = document?.activeElement?.shadowRoot;\n        if (!shadowRootEl?.activeElement) {\n            return document.activeElement;\n        }\n        else {\n            return this._getActiveElement(shadowRootEl);\n        }\n    }\n    checkSelectionOnDeletion(el) {\n        const prefixLength = this.prefix().length;\n        const suffixLength = this.suffix().length;\n        const inputValueLength = this._inputValue().length;\n        el.selectionStart = Math.min(Math.max(prefixLength, el.selectionStart), inputValueLength - suffixLength);\n        el.selectionEnd = Math.min(Math.max(prefixLength, el.selectionEnd), inputValueLength - suffixLength);\n    }\n    /** It disables the input element */\n    setDisabledState(isDisabled) {\n        this._maskService.formElementProperty = ['disabled', isDisabled];\n    }\n    _applyMask() {\n        this._maskService.maskExpression = this._maskService._repeatPatternSymbols(this._maskValue() || '');\n        this._maskService.formElementProperty = [\n            'value',\n            this._maskService.applyMask(this._inputValue(), this._maskService.maskExpression),\n        ];\n    }\n    _validateTime(value) {\n        const rowMaskLen = this._maskValue()\n            .split(MaskExpression.EMPTY_STRING)\n            .filter((s) => s !== ':').length;\n        if (!value) {\n            return null; // Don't validate empty values to allow for optional form control\n        }\n        if ((+(value[value.length - 1] ?? -1) === 0 && value.length < rowMaskLen) ||\n            value.length <= rowMaskLen - 2) {\n            return this._createValidationError(value);\n        }\n        return null;\n    }\n    _getActualInputLength() {\n        return (this._maskService.actualValue.length ||\n            this._maskService.actualValue.length + this._maskService.prefix.length);\n    }\n    _createValidationError(actualValue) {\n        return {\n            mask: {\n                requiredMask: this._maskValue(),\n                actualValue,\n            },\n        };\n    }\n    _setMask() {\n        this._maskExpressionArray().some((mask) => {\n            const specialChart = mask\n                .split(MaskExpression.EMPTY_STRING)\n                .some((char) => this._maskService.specialCharacters.includes(char));\n            if ((specialChart &&\n                this._inputValue() &&\n                this._areAllCharactersInEachStringSame(this._maskExpressionArray())) ||\n                mask.includes(MaskExpression.CURLY_BRACKETS_LEFT)) {\n                const test = this._maskService.removeMask(this._inputValue())?.length <=\n                    this._maskService.removeMask(mask)?.length;\n                if (test) {\n                    const maskValue = mask.includes(MaskExpression.CURLY_BRACKETS_LEFT)\n                        ? this._maskService._repeatPatternSymbols(mask)\n                        : mask;\n                    this._maskValue.set(maskValue);\n                    this._maskService.maskExpression = maskValue;\n                    return test;\n                }\n                else {\n                    const expression = this._maskExpressionArray()[this._maskExpressionArray().length - 1] ??\n                        MaskExpression.EMPTY_STRING;\n                    const maskValue = expression.includes(MaskExpression.CURLY_BRACKETS_LEFT)\n                        ? this._maskService._repeatPatternSymbols(expression)\n                        : expression;\n                    this._maskValue.set(maskValue);\n                    this._maskService.maskExpression = maskValue;\n                }\n            }\n            else {\n                const cleanMask = this._maskService.removeMask(mask);\n                const check = this._maskService\n                    .removeMask(this._inputValue())\n                    ?.split(MaskExpression.EMPTY_STRING)\n                    .every((character, index) => {\n                    const indexMask = cleanMask.charAt(index);\n                    return this._maskService._checkSymbolMask(character, indexMask);\n                });\n                if (check || this._justPasted()) {\n                    this._maskValue.set(mask);\n                    this._maskService.maskExpression = mask;\n                    return check;\n                }\n            }\n        });\n    }\n    _areAllCharactersInEachStringSame(array) {\n        const specialCharacters = this._maskService.specialCharacters;\n        function removeSpecialCharacters(str) {\n            const regex = new RegExp(`[${specialCharacters.map((ch) => `\\\\${ch}`).join('')}]`, 'g');\n            return str.replace(regex, '');\n        }\n        const processedArr = array.map(removeSpecialCharacters);\n        return processedArr.every((str) => {\n            const uniqueCharacters = new Set(str);\n            return uniqueCharacters.size === 1;\n        });\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.2\", ngImport: i0, type: NgxMaskDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"17.1.0\", version: \"20.1.2\", type: NgxMaskDirective, isStandalone: true, selector: \"input[mask], textarea[mask]\", inputs: { mask: { classPropertyName: \"mask\", publicName: \"mask\", isSignal: true, isRequired: false, transformFunction: null }, specialCharacters: { classPropertyName: \"specialCharacters\", publicName: \"specialCharacters\", isSignal: true, isRequired: false, transformFunction: null }, patterns: { classPropertyName: \"patterns\", publicName: \"patterns\", isSignal: true, isRequired: false, transformFunction: null }, prefix: { classPropertyName: \"prefix\", publicName: \"prefix\", isSignal: true, isRequired: false, transformFunction: null }, suffix: { classPropertyName: \"suffix\", publicName: \"suffix\", isSignal: true, isRequired: false, transformFunction: null }, thousandSeparator: { classPropertyName: \"thousandSeparator\", publicName: \"thousandSeparator\", isSignal: true, isRequired: false, transformFunction: null }, decimalMarker: { classPropertyName: \"decimalMarker\", publicName: \"decimalMarker\", isSignal: true, isRequired: false, transformFunction: null }, dropSpecialCharacters: { classPropertyName: \"dropSpecialCharacters\", publicName: \"dropSpecialCharacters\", isSignal: true, isRequired: false, transformFunction: null }, hiddenInput: { classPropertyName: \"hiddenInput\", publicName: \"hiddenInput\", isSignal: true, isRequired: false, transformFunction: null }, showMaskTyped: { classPropertyName: \"showMaskTyped\", publicName: \"showMaskTyped\", isSignal: true, isRequired: false, transformFunction: null }, placeHolderCharacter: { classPropertyName: \"placeHolderCharacter\", publicName: \"placeHolderCharacter\", isSignal: true, isRequired: false, transformFunction: null }, shownMaskExpression: { classPropertyName: \"shownMaskExpression\", publicName: \"shownMaskExpression\", isSignal: true, isRequired: false, transformFunction: null }, clearIfNotMatch: { classPropertyName: \"clearIfNotMatch\", publicName: \"clearIfNotMatch\", isSignal: true, isRequired: false, transformFunction: null }, validation: { classPropertyName: \"validation\", publicName: \"validation\", isSignal: true, isRequired: false, transformFunction: null }, separatorLimit: { classPropertyName: \"separatorLimit\", publicName: \"separatorLimit\", isSignal: true, isRequired: false, transformFunction: null }, allowNegativeNumbers: { classPropertyName: \"allowNegativeNumbers\", publicName: \"allowNegativeNumbers\", isSignal: true, isRequired: false, transformFunction: null }, leadZeroDateTime: { classPropertyName: \"leadZeroDateTime\", publicName: \"leadZeroDateTime\", isSignal: true, isRequired: false, transformFunction: null }, leadZero: { classPropertyName: \"leadZero\", publicName: \"leadZero\", isSignal: true, isRequired: false, transformFunction: null }, triggerOnMaskChange: { classPropertyName: \"triggerOnMaskChange\", publicName: \"triggerOnMaskChange\", isSignal: true, isRequired: false, transformFunction: null }, apm: { classPropertyName: \"apm\", publicName: \"apm\", isSignal: true, isRequired: false, transformFunction: null }, inputTransformFn: { classPropertyName: \"inputTransformFn\", publicName: \"inputTransformFn\", isSignal: true, isRequired: false, transformFunction: null }, outputTransformFn: { classPropertyName: \"outputTransformFn\", publicName: \"outputTransformFn\", isSignal: true, isRequired: false, transformFunction: null }, keepCharacterPositions: { classPropertyName: \"keepCharacterPositions\", publicName: \"keepCharacterPositions\", isSignal: true, isRequired: false, transformFunction: null }, instantPrefix: { classPropertyName: \"instantPrefix\", publicName: \"instantPrefix\", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { maskFilled: \"maskFilled\" }, host: { listeners: { \"paste\": \"onPaste()\", \"focus\": \"onFocus($event)\", \"ngModelChange\": \"onModelChange($event)\", \"input\": \"onInput($event)\", \"compositionstart\": \"onCompositionStart($event)\", \"compositionend\": \"onCompositionEnd($event)\", \"blur\": \"onBlur($event)\", \"click\": \"onClick($event)\", \"keydown\": \"onKeyDown($event)\" } }, providers: [\n            {\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: NgxMaskDirective,\n                multi: true,\n            },\n            {\n                provide: NG_VALIDATORS,\n                useExisting: NgxMaskDirective,\n                multi: true,\n            },\n            NgxMaskService,\n        ], exportAs: [\"mask\", \"ngxMask\"], usesOnChanges: true, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.2\", ngImport: i0, type: NgxMaskDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'input[mask], textarea[mask]',\n                    standalone: true,\n                    providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: NgxMaskDirective,\n                            multi: true,\n                        },\n                        {\n                            provide: NG_VALIDATORS,\n                            useExisting: NgxMaskDirective,\n                            multi: true,\n                        },\n                        NgxMaskService,\n                    ],\n                    exportAs: 'mask,ngxMask',\n                }]\n        }], propDecorators: { onPaste: [{\n                type: HostListener,\n                args: ['paste']\n            }], onFocus: [{\n                type: HostListener,\n                args: ['focus', ['$event']]\n            }], onModelChange: [{\n                type: HostListener,\n                args: ['ngModelChange', ['$event']]\n            }], onInput: [{\n                type: HostListener,\n                args: ['input', ['$event']]\n            }], onCompositionStart: [{\n                type: HostListener,\n                args: ['compositionstart', ['$event']]\n            }], onCompositionEnd: [{\n                type: HostListener,\n                args: ['compositionend', ['$event']]\n            }], onBlur: [{\n                type: HostListener,\n                args: ['blur', ['$event']]\n            }], onClick: [{\n                type: HostListener,\n                args: ['click', ['$event']]\n            }], onKeyDown: [{\n                type: HostListener,\n                args: ['keydown', ['$event']]\n            }] } });\n\nclass NgxMaskPipe {\n    defaultOptions = inject(NGX_MASK_CONFIG);\n    _maskService = inject(NgxMaskService);\n    _maskExpressionArray = [];\n    mask = '';\n    transform(value, mask, { patterns, ...config } = {}) {\n        let processedValue = value;\n        const currentConfig = {\n            maskExpression: mask,\n            ...this.defaultOptions,\n            ...config,\n            patterns: {\n                ...this._maskService.patterns,\n                ...patterns,\n            },\n        };\n        Object.entries(currentConfig).forEach(([key, val]) => {\n            this._maskService[key] = val;\n        });\n        if (mask.includes('||')) {\n            const maskParts = mask.split('||');\n            if (maskParts.length > 1) {\n                this._maskExpressionArray = maskParts.sort((a, b) => a.length - b.length);\n                this._setMask(`${processedValue}`);\n                return this._maskService.applyMask(`${processedValue}`, this.mask);\n            }\n            else {\n                this._maskExpressionArray = [];\n                return this._maskService.applyMask(`${processedValue}`, this.mask);\n            }\n        }\n        if (mask.includes(MaskExpression.CURLY_BRACKETS_LEFT)) {\n            return this._maskService.applyMask(`${processedValue}`, this._maskService._repeatPatternSymbols(mask));\n        }\n        if (mask.startsWith(MaskExpression.SEPARATOR)) {\n            if (config.decimalMarker) {\n                this._maskService.decimalMarker = config.decimalMarker;\n            }\n            if (config.thousandSeparator) {\n                this._maskService.thousandSeparator = config.thousandSeparator;\n            }\n            if (config.leadZero) {\n                this._maskService.leadZero = config.leadZero;\n            }\n            processedValue = String(processedValue);\n            const localeDecimalMarker = this._maskService.currentLocaleDecimalMarker();\n            if (!Array.isArray(this._maskService.decimalMarker)) {\n                processedValue =\n                    this._maskService.decimalMarker !== localeDecimalMarker\n                        ? processedValue.replace(localeDecimalMarker, this._maskService.decimalMarker)\n                        : processedValue;\n            }\n            if (this._maskService.leadZero &&\n                processedValue &&\n                this._maskService.dropSpecialCharacters !== false) {\n                processedValue = this._maskService._checkPrecision(mask, processedValue);\n            }\n            if (this._maskService.decimalMarker === MaskExpression.COMMA) {\n                processedValue = processedValue.replace(MaskExpression.DOT, MaskExpression.COMMA);\n            }\n            this._maskService.isNumberValue = true;\n        }\n        if (processedValue === null || typeof processedValue === 'undefined') {\n            return this._maskService.applyMask('', mask);\n        }\n        return this._maskService.applyMask(`${processedValue}`, mask);\n    }\n    _setMask(value) {\n        if (this._maskExpressionArray.length > 0) {\n            this._maskExpressionArray.some((mask) => {\n                const test = this._maskService.removeMask(value)?.length <=\n                    this._maskService.removeMask(mask)?.length;\n                if (value && test) {\n                    this.mask = mask;\n                    return test;\n                }\n                else {\n                    this.mask =\n                        this._maskExpressionArray[this._maskExpressionArray.length - 1] ??\n                            MaskExpression.EMPTY_STRING;\n                }\n            });\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.2\", ngImport: i0, type: NgxMaskPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });\n    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: \"14.0.0\", version: \"20.1.2\", ngImport: i0, type: NgxMaskPipe, isStandalone: true, name: \"mask\" });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.2\", ngImport: i0, type: NgxMaskPipe, decorators: [{\n            type: Pipe,\n            args: [{\n                    name: 'mask',\n                    pure: true,\n                    standalone: true,\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_CONFIG, NEW_CONFIG, NGX_MASK_CONFIG, NgxMaskDirective, NgxMaskPipe, NgxMaskService, initialConfig, provideEnvironmentNgxMask, provideNgxMask, timeMasks, withoutValidation };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}