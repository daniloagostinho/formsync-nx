{"ast":null,"code":"import { signal, QueryList, isSignal, effect } from '@angular/core';\nimport { Subscription, Subject } from 'rxjs';\nimport { Typeahead } from './typeahead.mjs';\nimport { hasModifierKey } from './keycodes.mjs';\nimport { PAGE_DOWN, PAGE_UP, END, HOME, LEFT_ARROW, RIGHT_ARROW, UP_ARROW, DOWN_ARROW, TAB } from './keycodes2.mjs';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nclass ListKeyManager {\n  _items;\n  _activeItemIndex = signal(-1, ...(ngDevMode ? [{\n    debugName: \"_activeItemIndex\"\n  }] : []));\n  _activeItem = signal(null, ...(ngDevMode ? [{\n    debugName: \"_activeItem\"\n  }] : []));\n  _wrap = false;\n  _typeaheadSubscription = Subscription.EMPTY;\n  _itemChangesSubscription;\n  _vertical = true;\n  _horizontal;\n  _allowedModifierKeys = [];\n  _homeAndEnd = false;\n  _pageUpAndDown = {\n    enabled: false,\n    delta: 10\n  };\n  _effectRef;\n  _typeahead;\n  /**\n   * Predicate function that can be used to check whether an item should be skipped\n   * by the key manager. By default, disabled items are skipped.\n   */\n  _skipPredicateFn = item => item.disabled;\n  constructor(_items, injector) {\n    this._items = _items;\n    // We allow for the items to be an array because, in some cases, the consumer may\n    // not have access to a QueryList of the items they want to manage (e.g. when the\n    // items aren't being collected via `ViewChildren` or `ContentChildren`).\n    if (_items instanceof QueryList) {\n      this._itemChangesSubscription = _items.changes.subscribe(newItems => this._itemsChanged(newItems.toArray()));\n    } else if (isSignal(_items)) {\n      if (!injector && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw new Error('ListKeyManager constructed with a signal must receive an injector');\n      }\n      this._effectRef = effect(() => this._itemsChanged(_items()), ...(ngDevMode ? [{\n        debugName: \"_effectRef\",\n        injector\n      }] : [{\n        injector\n      }]));\n    }\n  }\n  /**\n   * Stream that emits any time the TAB key is pressed, so components can react\n   * when focus is shifted off of the list.\n   */\n  tabOut = new Subject();\n  /** Stream that emits whenever the active item of the list manager changes. */\n  change = new Subject();\n  /**\n   * Sets the predicate function that determines which items should be skipped by the\n   * list key manager.\n   * @param predicate Function that determines whether the given item should be skipped.\n   */\n  skipPredicate(predicate) {\n    this._skipPredicateFn = predicate;\n    return this;\n  }\n  /**\n   * Configures wrapping mode, which determines whether the active item will wrap to\n   * the other end of list when there are no more items in the given direction.\n   * @param shouldWrap Whether the list should wrap when reaching the end.\n   */\n  withWrap(shouldWrap = true) {\n    this._wrap = shouldWrap;\n    return this;\n  }\n  /**\n   * Configures whether the key manager should be able to move the selection vertically.\n   * @param enabled Whether vertical selection should be enabled.\n   */\n  withVerticalOrientation(enabled = true) {\n    this._vertical = enabled;\n    return this;\n  }\n  /**\n   * Configures the key manager to move the selection horizontally.\n   * Passing in `null` will disable horizontal movement.\n   * @param direction Direction in which the selection can be moved.\n   */\n  withHorizontalOrientation(direction) {\n    this._horizontal = direction;\n    return this;\n  }\n  /**\n   * Modifier keys which are allowed to be held down and whose default actions will be prevented\n   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n   */\n  withAllowedModifierKeys(keys) {\n    this._allowedModifierKeys = keys;\n    return this;\n  }\n  /**\n   * Turns on typeahead mode which allows users to set the active item by typing.\n   * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n   */\n  withTypeAhead(debounceInterval = 200) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const items = this._getItemsArray();\n      if (items.length > 0 && items.some(item => typeof item.getLabel !== 'function')) {\n        throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n      }\n    }\n    this._typeaheadSubscription.unsubscribe();\n    const items = this._getItemsArray();\n    this._typeahead = new Typeahead(items, {\n      debounceInterval: typeof debounceInterval === 'number' ? debounceInterval : undefined,\n      skipPredicate: item => this._skipPredicateFn(item)\n    });\n    this._typeaheadSubscription = this._typeahead.selectedItem.subscribe(item => {\n      this.setActiveItem(item);\n    });\n    return this;\n  }\n  /** Cancels the current typeahead sequence. */\n  cancelTypeahead() {\n    this._typeahead?.reset();\n    return this;\n  }\n  /**\n   * Configures the key manager to activate the first and last items\n   * respectively when the Home or End key is pressed.\n   * @param enabled Whether pressing the Home or End key activates the first/last item.\n   */\n  withHomeAndEnd(enabled = true) {\n    this._homeAndEnd = enabled;\n    return this;\n  }\n  /**\n   * Configures the key manager to activate every 10th, configured or first/last element in up/down direction\n   * respectively when the Page-Up or Page-Down key is pressed.\n   * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.\n   * @param delta Whether pressing the Home or End key activates the first/last item.\n   */\n  withPageUpDown(enabled = true, delta = 10) {\n    this._pageUpAndDown = {\n      enabled,\n      delta\n    };\n    return this;\n  }\n  setActiveItem(item) {\n    const previousActiveItem = this._activeItem();\n    this.updateActiveItem(item);\n    if (this._activeItem() !== previousActiveItem) {\n      this.change.next(this._activeItemIndex());\n    }\n  }\n  /**\n   * Sets the active item depending on the key event passed in.\n   * @param event Keyboard event to be used for determining which element should be active.\n   */\n  onKeydown(event) {\n    const keyCode = event.keyCode;\n    const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n    const isModifierAllowed = modifiers.every(modifier => {\n      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n    });\n    switch (keyCode) {\n      case TAB:\n        this.tabOut.next();\n        return;\n      case DOWN_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n      case UP_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n      case RIGHT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n      case LEFT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n      case HOME:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setFirstItemActive();\n          break;\n        } else {\n          return;\n        }\n      case END:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setLastItemActive();\n          break;\n        } else {\n          return;\n        }\n      case PAGE_UP:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex() - this._pageUpAndDown.delta;\n          this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);\n          break;\n        } else {\n          return;\n        }\n      case PAGE_DOWN:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex() + this._pageUpAndDown.delta;\n          const itemsLength = this._getItemsArray().length;\n          this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);\n          break;\n        } else {\n          return;\n        }\n      default:\n        if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n          this._typeahead?.handleKey(event);\n        }\n        // Note that we return here, in order to avoid preventing\n        // the default action of non-navigational keys.\n        return;\n    }\n    this._typeahead?.reset();\n    event.preventDefault();\n  }\n  /** Index of the currently active item. */\n  get activeItemIndex() {\n    return this._activeItemIndex();\n  }\n  /** The active item. */\n  get activeItem() {\n    return this._activeItem();\n  }\n  /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n  isTyping() {\n    return !!this._typeahead && this._typeahead.isTyping();\n  }\n  /** Sets the active item to the first enabled item in the list. */\n  setFirstItemActive() {\n    this._setActiveItemByIndex(0, 1);\n  }\n  /** Sets the active item to the last enabled item in the list. */\n  setLastItemActive() {\n    this._setActiveItemByIndex(this._getItemsArray().length - 1, -1);\n  }\n  /** Sets the active item to the next enabled item in the list. */\n  setNextItemActive() {\n    this._activeItemIndex() < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n  /** Sets the active item to a previous enabled item in the list. */\n  setPreviousItemActive() {\n    this._activeItemIndex() < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1);\n  }\n  updateActiveItem(item) {\n    const itemArray = this._getItemsArray();\n    const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n    const activeItem = itemArray[index];\n    // Explicitly check for `null` and `undefined` because other falsy values are valid.\n    this._activeItem.set(activeItem == null ? null : activeItem);\n    this._activeItemIndex.set(index);\n    this._typeahead?.setCurrentSelectedItemIndex(index);\n  }\n  /** Cleans up the key manager. */\n  destroy() {\n    this._typeaheadSubscription.unsubscribe();\n    this._itemChangesSubscription?.unsubscribe();\n    this._effectRef?.destroy();\n    this._typeahead?.destroy();\n    this.tabOut.complete();\n    this.change.complete();\n  }\n  /**\n   * This method sets the active item, given a list of items and the delta between the\n   * currently active item and the new active item. It will calculate differently\n   * depending on whether wrap mode is turned on.\n   */\n  _setActiveItemByDelta(delta) {\n    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n  }\n  /**\n   * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n   * down the list until it finds an item that is not disabled, and it will wrap if it\n   * encounters either end of the list.\n   */\n  _setActiveInWrapMode(delta) {\n    const items = this._getItemsArray();\n    for (let i = 1; i <= items.length; i++) {\n      const index = (this._activeItemIndex() + delta * i + items.length) % items.length;\n      const item = items[index];\n      if (!this._skipPredicateFn(item)) {\n        this.setActiveItem(index);\n        return;\n      }\n    }\n  }\n  /**\n   * Sets the active item properly given the default mode. In other words, it will\n   * continue to move down the list until it finds an item that is not disabled. If\n   * it encounters either end of the list, it will stop and not wrap.\n   */\n  _setActiveInDefaultMode(delta) {\n    this._setActiveItemByIndex(this._activeItemIndex() + delta, delta);\n  }\n  /**\n   * Sets the active item to the first enabled item starting at the index specified. If the\n   * item is disabled, it will move in the fallbackDelta direction until it either\n   * finds an enabled item or encounters the end of the list.\n   */\n  _setActiveItemByIndex(index, fallbackDelta) {\n    const items = this._getItemsArray();\n    if (!items[index]) {\n      return;\n    }\n    while (this._skipPredicateFn(items[index])) {\n      index += fallbackDelta;\n      if (!items[index]) {\n        return;\n      }\n    }\n    this.setActiveItem(index);\n  }\n  /** Returns the items as an array. */\n  _getItemsArray() {\n    if (isSignal(this._items)) {\n      return this._items();\n    }\n    return this._items instanceof QueryList ? this._items.toArray() : this._items;\n  }\n  /** Callback for when the items have changed. */\n  _itemsChanged(newItems) {\n    this._typeahead?.setItems(newItems);\n    const activeItem = this._activeItem();\n    if (activeItem) {\n      const newIndex = newItems.indexOf(activeItem);\n      if (newIndex > -1 && newIndex !== this._activeItemIndex()) {\n        this._activeItemIndex.set(newIndex);\n        this._typeahead?.setCurrentSelectedItemIndex(newIndex);\n      }\n    }\n  }\n}\nexport { ListKeyManager };","map":{"version":3,"names":["signal","QueryList","isSignal","effect","Subscription","Subject","Typeahead","hasModifierKey","PAGE_DOWN","PAGE_UP","END","HOME","LEFT_ARROW","RIGHT_ARROW","UP_ARROW","DOWN_ARROW","TAB","ListKeyManager","_items","_activeItemIndex","ngDevMode","debugName","_activeItem","_wrap","_typeaheadSubscription","EMPTY","_itemChangesSubscription","_vertical","_horizontal","_allowedModifierKeys","_homeAndEnd","_pageUpAndDown","enabled","delta","_effectRef","_typeahead","_skipPredicateFn","item","disabled","constructor","injector","changes","subscribe","newItems","_itemsChanged","toArray","Error","tabOut","change","skipPredicate","predicate","withWrap","shouldWrap","withVerticalOrientation","withHorizontalOrientation","direction","withAllowedModifierKeys","keys","withTypeAhead","debounceInterval","items","_getItemsArray","length","some","getLabel","unsubscribe","undefined","selectedItem","setActiveItem","cancelTypeahead","reset","withHomeAndEnd","withPageUpDown","previousActiveItem","updateActiveItem","next","onKeydown","event","keyCode","modifiers","isModifierAllowed","every","modifier","indexOf","setNextItemActive","setPreviousItemActive","setFirstItemActive","setLastItemActive","targetIndex","_setActiveItemByIndex","itemsLength","handleKey","preventDefault","activeItemIndex","activeItem","isTyping","_setActiveItemByDelta","itemArray","index","set","setCurrentSelectedItemIndex","destroy","complete","_setActiveInWrapMode","_setActiveInDefaultMode","i","fallbackDelta","setItems","newIndex"],"sources":["/home/danilo/Ãrea de trabalho/formsync-nx/apps/front/node_modules/@angular/cdk/fesm2022/list-key-manager.mjs"],"sourcesContent":["import { signal, QueryList, isSignal, effect } from '@angular/core';\nimport { Subscription, Subject } from 'rxjs';\nimport { Typeahead } from './typeahead.mjs';\nimport { hasModifierKey } from './keycodes.mjs';\nimport { PAGE_DOWN, PAGE_UP, END, HOME, LEFT_ARROW, RIGHT_ARROW, UP_ARROW, DOWN_ARROW, TAB } from './keycodes2.mjs';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nclass ListKeyManager {\n    _items;\n    _activeItemIndex = signal(-1, ...(ngDevMode ? [{ debugName: \"_activeItemIndex\" }] : []));\n    _activeItem = signal(null, ...(ngDevMode ? [{ debugName: \"_activeItem\" }] : []));\n    _wrap = false;\n    _typeaheadSubscription = Subscription.EMPTY;\n    _itemChangesSubscription;\n    _vertical = true;\n    _horizontal;\n    _allowedModifierKeys = [];\n    _homeAndEnd = false;\n    _pageUpAndDown = { enabled: false, delta: 10 };\n    _effectRef;\n    _typeahead;\n    /**\n     * Predicate function that can be used to check whether an item should be skipped\n     * by the key manager. By default, disabled items are skipped.\n     */\n    _skipPredicateFn = (item) => item.disabled;\n    constructor(_items, injector) {\n        this._items = _items;\n        // We allow for the items to be an array because, in some cases, the consumer may\n        // not have access to a QueryList of the items they want to manage (e.g. when the\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\n        if (_items instanceof QueryList) {\n            this._itemChangesSubscription = _items.changes.subscribe((newItems) => this._itemsChanged(newItems.toArray()));\n        }\n        else if (isSignal(_items)) {\n            if (!injector && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw new Error('ListKeyManager constructed with a signal must receive an injector');\n            }\n            this._effectRef = effect(() => this._itemsChanged(_items()), ...(ngDevMode ? [{ debugName: \"_effectRef\", injector }] : [{ injector }]));\n        }\n    }\n    /**\n     * Stream that emits any time the TAB key is pressed, so components can react\n     * when focus is shifted off of the list.\n     */\n    tabOut = new Subject();\n    /** Stream that emits whenever the active item of the list manager changes. */\n    change = new Subject();\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    skipPredicate(predicate) {\n        this._skipPredicateFn = predicate;\n        return this;\n    }\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param shouldWrap Whether the list should wrap when reaching the end.\n     */\n    withWrap(shouldWrap = true) {\n        this._wrap = shouldWrap;\n        return this;\n    }\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    withVerticalOrientation(enabled = true) {\n        this._vertical = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    withHorizontalOrientation(direction) {\n        this._horizontal = direction;\n        return this;\n    }\n    /**\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n     */\n    withAllowedModifierKeys(keys) {\n        this._allowedModifierKeys = keys;\n        return this;\n    }\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    withTypeAhead(debounceInterval = 200) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const items = this._getItemsArray();\n            if (items.length > 0 && items.some(item => typeof item.getLabel !== 'function')) {\n                throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n            }\n        }\n        this._typeaheadSubscription.unsubscribe();\n        const items = this._getItemsArray();\n        this._typeahead = new Typeahead(items, {\n            debounceInterval: typeof debounceInterval === 'number' ? debounceInterval : undefined,\n            skipPredicate: item => this._skipPredicateFn(item),\n        });\n        this._typeaheadSubscription = this._typeahead.selectedItem.subscribe(item => {\n            this.setActiveItem(item);\n        });\n        return this;\n    }\n    /** Cancels the current typeahead sequence. */\n    cancelTypeahead() {\n        this._typeahead?.reset();\n        return this;\n    }\n    /**\n     * Configures the key manager to activate the first and last items\n     * respectively when the Home or End key is pressed.\n     * @param enabled Whether pressing the Home or End key activates the first/last item.\n     */\n    withHomeAndEnd(enabled = true) {\n        this._homeAndEnd = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to activate every 10th, configured or first/last element in up/down direction\n     * respectively when the Page-Up or Page-Down key is pressed.\n     * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.\n     * @param delta Whether pressing the Home or End key activates the first/last item.\n     */\n    withPageUpDown(enabled = true, delta = 10) {\n        this._pageUpAndDown = { enabled, delta };\n        return this;\n    }\n    setActiveItem(item) {\n        const previousActiveItem = this._activeItem();\n        this.updateActiveItem(item);\n        if (this._activeItem() !== previousActiveItem) {\n            this.change.next(this._activeItemIndex());\n        }\n    }\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    onKeydown(event) {\n        const keyCode = event.keyCode;\n        const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n        const isModifierAllowed = modifiers.every(modifier => {\n            return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n        });\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case UP_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case HOME:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setFirstItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case END:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setLastItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case PAGE_UP:\n                if (this._pageUpAndDown.enabled && isModifierAllowed) {\n                    const targetIndex = this._activeItemIndex() - this._pageUpAndDown.delta;\n                    this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);\n                    break;\n                }\n                else {\n                    return;\n                }\n            case PAGE_DOWN:\n                if (this._pageUpAndDown.enabled && isModifierAllowed) {\n                    const targetIndex = this._activeItemIndex() + this._pageUpAndDown.delta;\n                    const itemsLength = this._getItemsArray().length;\n                    this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);\n                    break;\n                }\n                else {\n                    return;\n                }\n            default:\n                if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n                    this._typeahead?.handleKey(event);\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._typeahead?.reset();\n        event.preventDefault();\n    }\n    /** Index of the currently active item. */\n    get activeItemIndex() {\n        return this._activeItemIndex();\n    }\n    /** The active item. */\n    get activeItem() {\n        return this._activeItem();\n    }\n    /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n    isTyping() {\n        return !!this._typeahead && this._typeahead.isTyping();\n    }\n    /** Sets the active item to the first enabled item in the list. */\n    setFirstItemActive() {\n        this._setActiveItemByIndex(0, 1);\n    }\n    /** Sets the active item to the last enabled item in the list. */\n    setLastItemActive() {\n        this._setActiveItemByIndex(this._getItemsArray().length - 1, -1);\n    }\n    /** Sets the active item to the next enabled item in the list. */\n    setNextItemActive() {\n        this._activeItemIndex() < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    }\n    /** Sets the active item to a previous enabled item in the list. */\n    setPreviousItemActive() {\n        this._activeItemIndex() < 0 && this._wrap\n            ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    }\n    updateActiveItem(item) {\n        const itemArray = this._getItemsArray();\n        const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n        const activeItem = itemArray[index];\n        // Explicitly check for `null` and `undefined` because other falsy values are valid.\n        this._activeItem.set(activeItem == null ? null : activeItem);\n        this._activeItemIndex.set(index);\n        this._typeahead?.setCurrentSelectedItemIndex(index);\n    }\n    /** Cleans up the key manager. */\n    destroy() {\n        this._typeaheadSubscription.unsubscribe();\n        this._itemChangesSubscription?.unsubscribe();\n        this._effectRef?.destroy();\n        this._typeahead?.destroy();\n        this.tabOut.complete();\n        this.change.complete();\n    }\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     */\n    _setActiveItemByDelta(delta) {\n        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n    }\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     */\n    _setActiveInWrapMode(delta) {\n        const items = this._getItemsArray();\n        for (let i = 1; i <= items.length; i++) {\n            const index = (this._activeItemIndex() + delta * i + items.length) % items.length;\n            const item = items[index];\n            if (!this._skipPredicateFn(item)) {\n                this.setActiveItem(index);\n                return;\n            }\n        }\n    }\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     */\n    _setActiveInDefaultMode(delta) {\n        this._setActiveItemByIndex(this._activeItemIndex() + delta, delta);\n    }\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     */\n    _setActiveItemByIndex(index, fallbackDelta) {\n        const items = this._getItemsArray();\n        if (!items[index]) {\n            return;\n        }\n        while (this._skipPredicateFn(items[index])) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    }\n    /** Returns the items as an array. */\n    _getItemsArray() {\n        if (isSignal(this._items)) {\n            return this._items();\n        }\n        return this._items instanceof QueryList ? this._items.toArray() : this._items;\n    }\n    /** Callback for when the items have changed. */\n    _itemsChanged(newItems) {\n        this._typeahead?.setItems(newItems);\n        const activeItem = this._activeItem();\n        if (activeItem) {\n            const newIndex = newItems.indexOf(activeItem);\n            if (newIndex > -1 && newIndex !== this._activeItemIndex()) {\n                this._activeItemIndex.set(newIndex);\n                this._typeahead?.setCurrentSelectedItemIndex(newIndex);\n            }\n        }\n    }\n}\n\nexport { ListKeyManager };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}